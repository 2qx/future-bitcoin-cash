pragma cashscript ^0.10.0;

// [WIP] 2024-04-17

// Future BCH fungible token vault
//
//  Flow:
//
//  inputs              outputs
//  [0] contract    ->  [0] contract
//  [1] userPkh     =>  [1] userPkh
//  [2] coupon?     ^
//

contract Vault(bytes4 locktime, bytes32 tokenCategory) {

    function placeOrRedeem(bool isRedeem) {

        // If Is Redeem
        // enforce BIP65 timelocks and the direction of the swap 
        // tokens may be redeemed in any amount after the future has matured
        int deltaToken = tx.inputs[0].tokenAmount - tx.outputs[0].tokenAmount;
        if(isRedeem){
          require(tx.time >= int(locktime));
          // Check this is the correct token and not a random token
          require(tx.inputs[1].tokenCategory == tokenCategory);

          // Check the transaction took no tokens from the contract
          require(tx.inputs[0].tokenAmount == 0);

          // Check the user isn't taking more sats than tokens placed
          require(tx.inputs[0].value >= deltaToken);
        } 
        // else Placement
        else{
          // Check this is the correct token and not a random token
          require(tx.inputs[0].tokenCategory == tokenCategory);
          
          // The user input may not contain tokens in placement
          require(tx.inputs[1].tokenAmount == 0);

          // Check the user isn't taking more tokens than value placed
          require(tx.outputs[0].value >= deltaToken);
          
        }

        // Make sure this contract is the the first output, 
        // and by extension from the next require, the first input
        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2SH32(hash256(this.activeBytecode)));

        // Enforce that this contract lives on
        require(
          tx.outputs[this.activeInputIndex].lockingBytecode 
          == 
          tx.inputs[this.activeInputIndex].lockingBytecode
          );

        require(
          tx.inputs[this.activeInputIndex].tokenAmount + 
          tx.inputs[this.activeInputIndex].value 
          == 
          tx.outputs[this.activeInputIndex].tokenAmount + 
          tx.outputs[this.activeInputIndex].value
         );
    }

    // shard or split
    // 
}
