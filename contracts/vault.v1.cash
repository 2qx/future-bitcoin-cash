pragma cashscript ^0.10.0;

// Vault - Store coins locked for tokens until they maturation date. 
//
// From: Future Bitcoin Cash
//
// Author: 2qx <2qx_in_the_future@small.neomailbox.ch>
//
//     If redeeming tokens for coins in the vault: 
// [ ]   enforce the timelock is met.
// [ ]   enforce the token category matches.
//
// [ ] Assure the utxo token category matches that of the output.
// [ ] Assure the the utxo and output lock match per in the transaction.
// [ ] Assure an equal amounts of coins are exchanged for tokens
//
// [WIP] 2024-04-25
//
//  inputs              outputs
//  [0] contract    ->  [0] contract
//  [1] userPkh     =>  [1] userPkh
//  [2] coupon?     -^
//

contract Vault(bytes4 locktime, bytes32 tokenCategory) {

    function swap() {
        
        // If tokens are being redeemed to the vault
        // tokens may be redeemed in any amount after the future has matured
        bool tokensRedeemed = (
          tx.outputs[this.activeInputIndex].tokenAmount 
          - tx.inputs[this.activeInputIndex].tokenAmount
          ) > 0;
        bool toVault = tx.outputs[this.activeInputIndex].lockingBytecode 
                 == new LockingBytecodeP2SH32(hash256(this.activeBytecode));

        // Restrict redemption unil after locktime
        if(toVault && tokensRedeemed){
          
            // enforce a BIP65 timelock 
            require(tx.time >= int(locktime));

            // of the correct category.
            require(tx.outputs[this.activeInputIndex].tokenCategory == tokenCategory);
        } 

        // 
        // Inspired by wrapped.cash c.Nov 2023
        // Author: Dagur Valberg Johannsson <dagurval@pvv.ntnu.no> 
        // License: MIT
        //
        require(
          tx.inputs[this.activeInputIndex].tokenCategory 
          == 
          tx.outputs[this.activeInputIndex].tokenCategory
          );

        // Enforce that this contract lives on
        require(
          tx.outputs[this.activeInputIndex].lockingBytecode 
          == 
          tx.inputs[this.activeInputIndex].lockingBytecode
          );

        require(
          tx.inputs[this.activeInputIndex].tokenAmount + 
          tx.inputs[this.activeInputIndex].value 
          == 
          tx.outputs[this.activeInputIndex].tokenAmount + 
          tx.outputs[this.activeInputIndex].value
         );
    }

}
