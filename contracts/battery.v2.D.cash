pragma cashscript ^0.10.0;

// [WIP] 2024-05-18

// DETERMISTIC(?) Battery - Spawn an array of vault deploying gantries from a single utxo.
//
// From: Future Bitcoin Cash
//
// Author: 2qx <2qx_in_the_future@small.neomailbox.ch>
//
// A Battery releases a series of Gantries at different powers of 10 that 
// go on to create Futures Vaults on those respective intervals.
//
// Given a minting NFT with the commitment containing a power of 10, 
// mint a sequence of NFTs with minting capability
// sending mutable batons NFTs to the corresponting Gantry.
//
//  execute():
//
//  inputs                           outputs
//  [0] Battery + NFT 0x40420F00 10ᴇ6 ->  [0] Battery    + NFT  0xA0860100
//                                    =>  [1] Gantry10ᴇ6 + NFT* <startTime>
//
//  [0] Battery + NFT 0xA0860100 10ᴇ5 ->  [0] Battery    + NFT  0x10270000
//                                    =>  [1] Gantry10ᴇ5 + NFT* <startTime>
//
//  ... 0x10270000 10ᴇ4 ... 0xE8030000 10ᴇ3 ... 0x64000000 10ᴇ2
//
//  [0] Battery + NFT 0x<end>        ->  [0] Battery   + NFT  0x6a // burn NFT, sats are unencumbered.
//
// 

contract Battery(

    // 
    // The highest series power of 10 is set in the minting NFT baton commitment.

    // The end is the lowest power to print a series for
    int end,

    // Starting block height (approximate)
    int startTime,

    // Unlocking bytecode of the gantry contracts
    bytes gantryUnlockingBytecode,

    // Unlocking bytecode of the vault contracts
    bytes vaultUnlockingBytecode,

    ) {

    function execute(){

        require(tx.time >= startTime);
        
        // We allow only 1 input, creator must provide enough BCH 
        // when they make the Battery UTXO.
        require(tx.inputs.length == 1);
        require(tx.outputs.length == 2);

        // Get the commitment 
        int step = int(tx.inputs[0].nftCommitment);

        if(step < end) {

            // Get the redeem bytecode of the gantry instance
            bytes gantryRedeemBytecode = bytes(vaultUnlockingBytecode.length) + vaultUnlockingBytecode +
                                        0x04 + bytes4(step)                      +  // stepBytes
                                        gantryUnlockingBytecode;    

            require(
                // The second output is the gantry lockingBytecode
                0xaa20 + hash256(gantryRedeemBytecode) + 0x87
                == tx.outputs[1].lockingBytecode
            );

            // Fund the gantry in full
            require(tx.outputs[1].value == (tx.inputs[0].value*9/10) - 1000);   


            // Set the gantry commitment to a block on increment in the near future.
            bytes4 gantryStart = bytes4(startTime - (startTime % step) + step);
            require(tx.outputs[1].nftCommitment == gantryStart);
            require(tx.outputs[1].tokenAmount == 0);  

            bytes gantryCategory, bytes gantryCapability = tx.outputs[1].tokenCategory.split(32);

            // Assure the gantry baton is a non-minting NFT
            require(gantryCapability == 0x0);
            
            // Assure the gantry category matches the battery category
            require(gantryCategory == tx.inputs[0].tokenCategory.split(32)[0]);


            // then pass the baton back 
            require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);

            // with exaclty one 10th the value
            require(tx.outputs[0].value == tx.inputs[0].value/10);

            require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);
            require(tx.outputs[0].tokenAmount == 0);  

            // Increment the baton by an order of magnitude
            require(tx.outputs[0].nftCommitment == bytes4(step * 10)); 




        } else {
            // Burn the minting baton, allow value to be taken
            require(tx.outputs[0].lockingBytecode == 0x6a);

            // The output gleening sats cannot have an NFT
            require(tx.outputs[1].tokenCategory == 0x);

            // The balance is free
        }
        
    }
}

        