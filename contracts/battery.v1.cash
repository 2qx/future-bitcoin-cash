pragma cashscript ^0.10.0;

// [WIP] 2024-04-23

// Battery - Spawn an array of vault deploying gantries from a single utxo.
//
// From: Future Bitcoin Cash
//
// Author: 2qx <2qx_in_the_future@small.neomailbox.ch>
//
// A Battery releases a series of Gantries at different powers of 10 that 
// go on to create Futures Vaults on those respective intervals.
//
// Given a minting NFT with the commitment containing a power of 10, 
// mint a sequence of NFTs with minting capability
// sending mutable batons NFTs to the corresponting Gantry.
//
//  execute():
//
//  inputs                           outputs
//  [0] Battery + NFT 0x40420F00 10ᴇ6 ->  [0] Battery    + NFT  0xA0860100
//                                    =>  [1] Gantry10ᴇ6 + NFT* <startTime>
//
//  [0] Battery + NFT 0xA0860100 10ᴇ5 ->  [0] Battery    + NFT  0x10270000
//                                    =>  [1] Gantry     + NFT* <startTime>
//
//  ... 0x10270000 10ᴇ4 ... 0xE8030000 10ᴇ3 ... 0x64000000 10ᴇ2
//
//  [0] Battery + NFT 0x<end>        ->  [0] Battery   + NFT  0x6a // burn NFT, sats are unencumbered.
//
// 

contract Battery(

    // 
    // The highest series power of 10 is set in the minting NFT baton commitment.

    // The end is the lowest power to print a series for
    int end,

    // Starting block height (approximate)
    int startTime,

    // Unlocking bytecode of the gantry contracts
    bytes gantryUnlockingBytecode,

    // Unlocking bytecode of the vault contracts
    bytes vaultUnlockingBytecode,

    ) {

    function execute(){

        require(tx.time >= int(startTime));
        
        // We allow only 1 input, creator must provide enough BCH 
        // when they make the Battery UTXO.
        require(tx.inputs.length == 1);
    
        // Get the commitment 
        bytes4 stepBytes = bytes4(tx.inputs[0].nftCommitment);
        int step = int(tx.inputs[0].nftCommitment);

        if(step > end) {

            // Set the gantry commitment to a block on increment in the near future.
            bytes4 gantryStart = bytes4(startTime - (startTime % step) + step);
            require(tx.outputs[1].nftCommitment == gantryStart);

            // Get the redeem bytecode of the gantry instance
            bytes gantryRedeemBytecode = bytes(vaultUnlockingBytecode.length) + vaultUnlockingBytecode +
                                        0x04 + stepBytes                                +  // stepBytes
                                        0x20 + tx.inputs[0].tokenCategory.split(32)[0]  +  // This tokenCategory
                                        gantryUnlockingBytecode;    

            require(
                // The second output is the gantry lockingBytecode
                0xaa20 + hash256(gantryRedeemBytecode) + 0x87
                == tx.outputs[1].lockingBytecode
            );

            bytes gantryCategory, bytes gantryCapability = tx.outputs[1].tokenCategory.split(32);

            // Assure the gantry baton is a non-minting NFT
            require(int(gantryCapability) == 0);
            
            // Assure the gantry category matches the battery category
            require(gantryCategory == tx.inputs[0].tokenCategory.split(32)[0]);

            // Prevent all the value from being cleared off
            require((tx.inputs[0].value - (tx.outputs[0].value + tx.outputs[1].value)) < 1000);

            // Increment the baton by an order of magnitude
            require(bytes4(step / 10) == tx.outputs[0].nftCommitment);
            // then pass it 
            require(tx.inputs[0].tokenCategory == tx.outputs[0].tokenCategory);
            require(tx.inputs[0].lockingBytecode == tx.outputs[0].lockingBytecode);

        } else {
            // Burn the minting baton, allow value to be taken
            require(tx.outputs[0].lockingBytecode == 0x6a);
            require(tx.outputs[1].tokenCategory == 0x);
            require(tx.outputs.length==2);
        }
        
    }
}

        