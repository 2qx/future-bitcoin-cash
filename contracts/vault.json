{
  "contractName": "Vault",
  "constructorInputs": [
    {
      "name": "locktime",
      "type": "int"
    },
    {
      "name": "tokenCategory",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "placeOrRedeem",
      "inputs": [
        {
          "name": "isRedeem",
          "type": "bool"
        }
      ]
    }
  ],
  "bytecode": "OP_ROT OP_IF OP_DUP OP_CHECKLOCKTIMEVERIFY OP_DROP OP_1 OP_UTXOTOKENCATEGORY OP_2 OP_PICK OP_EQUALVERIFY OP_0 OP_UTXOTOKENAMOUNT OP_0 OP_NUMEQUALVERIFY OP_0 OP_UTXOVALUE OP_0 OP_OUTPUTTOKENAMOUNT OP_GREATERTHANOREQUAL OP_VERIFY OP_ELSE OP_0 OP_UTXOTOKENCATEGORY OP_2 OP_PICK OP_EQUALVERIFY OP_1 OP_UTXOTOKENAMOUNT OP_0 OP_NUMEQUALVERIFY OP_0 OP_UTXOTOKENAMOUNT OP_0 OP_OUTPUTVALUE OP_LESSTHANOREQUAL OP_VERIFY OP_ENDIF OP_0 OP_OUTPUTBYTECODE aa20 OP_ACTIVEBYTECODE OP_SHA256 OP_CAT 87 OP_CAT OP_EQUALVERIFY OP_INPUTINDEX OP_OUTPUTBYTECODE OP_INPUTINDEX OP_UTXOBYTECODE OP_EQUALVERIFY OP_INPUTINDEX OP_UTXOTOKENAMOUNT OP_INPUTINDEX OP_UTXOVALUE OP_ADD OP_INPUTINDEX OP_OUTPUTTOKENAMOUNT OP_INPUTINDEX OP_OUTPUTVALUE OP_ADD OP_NUMEQUAL OP_NIP OP_NIP",
  "source": "pragma cashscript ^0.10.0;\n\n// [WIP] 2024-03-01\n\n// Future BCH fungible token vault\n//\n//  Flow:\n//\n//  inputs              outputs\n//  [0] contract    ->  [0] contract\n//  [1] userPkh     =>  [1] userPkh\n//  [2] coupon?     ^\n//\n\ncontract Vault(int locktime, bytes tokenCategory) {\n\n    function placeOrRedeem(bool isRedeem) {\n\n        // If Is Redeem\n        // enforce BIP65 timelocks and the direction of the swap \n        // tokens may be redeemed in any amount after the future has matured\n        if(isRedeem){\n          require(tx.time >= locktime);\n          // Check this is the correct token and not a random token\n          require(tx.inputs[1].tokenCategory == tokenCategory);\n\n          // Check the transaction took no tokens from the contract\n          require(tx.inputs[0].tokenAmount == 0);\n\n          // Check the user isn't taking more sats than tokens placed\n          require(tx.inputs[0].value >= tx.outputs[0].tokenAmount);\n        } \n        // else Placement\n        else{\n          // Check this is the correct token and not a random token\n          require(tx.inputs[0].tokenCategory == tokenCategory);\n          \n          // The user input may not contain tokens in placement\n          require(tx.inputs[1].tokenAmount == 0);\n\n          // Check the user isn't taking more tokens than value placed\n          require(tx.inputs[0].tokenAmount <= tx.outputs[0].value);\n          \n        }\n\n        // Make sure this contract is the the first output, \n        // and by extension from the next require, the first input\n        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2SH32(sha256(this.activeBytecode)));\n\n        // Enforce that this contract lives on\n        require(\n          tx.outputs[this.activeInputIndex].lockingBytecode \n          == \n          tx.inputs[this.activeInputIndex].lockingBytecode, \n          \"locking bytecode index mismatch\"\n          );\n\n        require(\n          tx.inputs[this.activeInputIndex].tokenAmount + \n          tx.inputs[this.activeInputIndex].value \n          == \n          tx.outputs[this.activeInputIndex].tokenAmount + \n          tx.outputs[this.activeInputIndex].value,\n         \"summation mismatch\"\n         );\n    }\n}\n",
  "debug": {
    "bytecode": "527a630079b17551ce5279876900d0009c6900c600d3a2696700ce5279876951d0009c6900d000cca1696800cd02aa20c1a87e01877e8769c0cdc0c78769c0d0c0c693c0d3c0cc939c7777",
    "sourceMap": "22:11:22:19;;:20:32:9;23:29:23:37;;:10::39:1;;25:28:25:29:0;:18::44;:48::61;;:18:::1;:10::63;28:28:28:29:0;:18::42;:46::47;:18:::1;:10::49;31:28:31:29:0;:18::36;:51::52;:40::65;:18:::1;:10::67;34:12:44:9:0;36:28:36:29;:18::44;:48::61;;:18:::1;:10::63;39:28:39:29:0;:18::42;:46::47;:18:::1;:10::49;42:28:42:29:0;:18::42;:57::58;:46::65;:18:::1;:10::67;34:12:44:9;48:27:48:28:0;:16::45;:49::103;:82::101;:75::102:1;:49::103:0;;;:16:::1;:8::105;52:21:52:42:0;:10::59;54:20:54:41;:10::58;52::::1;51:8:56:12;59:20:59:41:0;:10::54;60:20:60:41;:10::48;59::::1;62:21:62:42:0;:10::55;63:21:63:42;:10::49;62::::1;59;17:4:66:5;",
    "logs": [],
    "requireMessages": [
      {
        "ip": 60,
        "line": 51,
        "message": "locking bytecode index mismatch"
      },
      {
        "ip": 72,
        "line": 58,
        "message": "summation mismatch"
      }
    ]
  },
  "compiler": {
    "name": "cashc",
    "version": "0.10.0-next.3"
  },
  "updatedAt": "2024-04-04T14:22:53.821Z"
}
