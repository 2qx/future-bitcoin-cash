{"version":3,"file":"5.BcPq7RbO.js","sources":["../../../../../../src/routes/contracts/+page.ts","../../../../../../src/routes/contracts/+page.md"],"sourcesContent":["import { dev } from '$app/environment';\n\n// we don't need any JS on this page, though we'll load\n// it in dev so that we get hot module replacement\nexport const csr = dev;\n\n// since there's no dynamic data here, we can prerender\n// it so that it gets served as a static asset in production\nexport const prerender = true;\n","---\nlayout: splash\n---\n\n<svelte:head>\n\n<title>Contracts</title>\n\n</svelte:head>\n\n# Overview\n\nFuture Bitcoin Cash is an anyone-can-spend system for populating a fixed supply of tokens in vaults using an NFT baton as authority.\n\nThe contracts allow anyone to mint a fixed supply of fungible tokens and put them into the next vault, and also check that a token claiming to be FBCH is valid.\n\n<img src=\"/system_genesis.svg\" alt=\"diagram showing system operation\"/>\n\nTo check if an FBCH category, get the pre-genesis transaction matching the category ID, then:\n\n - Check that the first output of the transaction paid to one of the four gantry contracts.\n - Check that the first output spent the FBCH baton (`fbc0b00131...ccb46`).\n - The token is valid FBCH and the value of the baton commitment (LE) is the series.\n  \nMore details on checking FBCH tokens [here](/protocol)\n\n# Vault\n\nThe vault allows swapping coins for fungible tokens on a 1:1 basis until a certain block height is reached. When the `locktime` has been met, the vault allows bi-directional swapping.\n\nAlthough the vault may lock coins against any fungible token, only contractually issued tokens with the full auditable supply sent to the vault should be treated as locked futures on the open market.  \n\n```solidity\npragma cashscript ^0.10.0;\n\n// Vault - Store coins locked for tokens until maturation date. \n//\n// 2024-06-05\n//\n// From: Future Bitcoin Cash\n//\n// Author: 2qx <2qx_in_the_future@small.neomailbox.ch>\n//\n//     If redeeming tokens for coins in the vault: \n// [ ]   enforce the timelock is met.\n//\n// [ ] Assure the utxo token category matches that of the output.\n// [ ] Assure the the utxo and output lock match per in the transaction.\n// [ ] Assure an equal amounts of coins are exchanged for tokens\n//\n//\n//  inputs              outputs\n//  [0] contract    ->  [0] contract\n//  [1] userPkh     =>  [1] userPkh\n//  [2] coupon?     -^\n//\n\ncontract Vault(int locktime) {\n\n    function swap() {\n        \n        // If tokens are flowing back into this contract\n        // OP_INPUTINDEX OP_OUTPUTTOKENAMOUNT OP_INPUTINDEX OP_UTXOTOKENAMOUNT OP_GREATERTHAN OP_IF \n        if(tx.outputs[this.activeInputIndex].tokenAmount > tx.inputs[this.activeInputIndex].tokenAmount){\n        \n\n            // Enforce a BIP65 timelock \n            // Note, intended for use with block height based locks \n            // (where:  locktime < 500M).\n            // OP_0 OP_PICK OP_CHECKLOCKTIMEVERIFY OP_DROP\n            require(tx.time >= locktime);\n\n\n        } // OP_ENDIF \n         \n        // \n        // Inspired by wrapped.cash c. Nov 2023\n        // Author: Dagur Valberg Johannsson <dagurval@pvv.ntnu.no> \n        // License: MIT\n        //\n        // ensure the token in and out matches\n        // OP_INPUTINDEX OP_UTXOTOKENCATEGORY OP_INPUTINDEX OP_OUTPUTTOKENCATEGORY OP_EQUAL OP_VERIFY \n        require(\n          tx.inputs[this.activeInputIndex].tokenCategory \n          == \n          tx.outputs[this.activeInputIndex].tokenCategory\n          );\n\n\n        // Enforce that this contract lives on\n        // OP_INPUTINDEX OP_OUTPUTBYTECODE OP_INPUTINDEX OP_UTXOBYTECODE OP_EQUAL OP_VERIFY\n        require(\n          tx.outputs[this.activeInputIndex].lockingBytecode \n          == \n          tx.inputs[this.activeInputIndex].lockingBytecode\n          );\n\n\n        // ensure the sum of sats and tokens in \n        // matches the sum of sats and tokens out.\n        // OP_INPUTINDEX OP_UTXOTOKENAMOUNT OP_INPUTINDEX OP_UTXOVALUE OP_ADD\n        // OP_INPUTINDEX OP_OUTPUTTOKENAMOUNT OP_INPUTINDEX OP_OUTPUTVALUE OP_ADD \n        // OP_NUMEQUAL\n        // OP_NIP        \n        require(\n          tx.inputs[this.activeInputIndex].tokenAmount + \n          tx.inputs[this.activeInputIndex].value \n          == \n          tx.outputs[this.activeInputIndex].tokenAmount + \n          tx.outputs[this.activeInputIndex].value\n         );\n\n    }\n\n}\n```\n\n\n# Coupon\n\nA coupon holds some unspent output that can be applied when a certain amount of satoshis are being placed in a vault. The contract limits use of a coupon utxo to one per transaction.\n\nEvery vault has known correlate coupon addresses, that can be determined given the vault locking bytecode.\n\nIf (in the future) whole coins become more unattainable, it's also possible to create coupon covenants for 10M and 1M sat placements, without modifying the logic of the coupon contract, just by changing the `amount` parameter.\n\nThe coupon contract holds any normal UTXO sent to it as a applicable to a vault placement transaction. So a coupon of 1M sats is created by sending 1M sats to the coupon contract. A hundred coupons could be written by sending one hundred outputs with 1M sats each to the coupon contract. *Coupons* are just normal UTXOs that can be funded from any software that can a send output Bitcoin Cash to the contract address. The value of each coupon is simply the value of the each output.\n\n```solidity\npragma cashscript ^0.10.0;\n\n// Coupon - apply* utxo coupons by spending at least <amount> on <lock>\n//\n// 2024-06-05\n//\n// From: Future Bitcoin Cash\n//\n// Author: 2qx <2qx_in_the_future@small.neomailbox.ch>\n//\n// Allow anyone to use an unspent output (utxo) in a transaction ...\n//\n// ... given:\n//\n// [ ] the zeroth inflow value exceeds a predefined amount \n// [ ] the zeroth input is to a predefined address\n// [ ] the coupon must be applied as the last input\n//\n// * Limit one per transaction.\n//\n// Note: This contract is designed to run as part of an integrated\n// multi-contract system. It's not in itself sufficient to assure \n// an advisory doesn't claim all coupons instantly for no cost.\n//\n// Also note: This instance is designed where the `lock`, or destination, \n// is the first input and output. If the lock isn't spendable, or not the first\n// input, coupons will not be redeemable.\n//\n// ... If there is no time or monetary cost to spend every coupon, \n// it should be expected that they will all be cleaned at once.\n//\n\ncontract Coupon(\n  // Minimum spent (sats) to claim each coupon utxo.\n  int amount,\n  \n  // Contract holding the logic.\n  bytes lock\n){\n\n  function apply() {\n    \n    // assure at the minium amount is sent to the intended contract\n    // OP_0 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_SUB OP_1 OP_ROLL OP_GREATERTHANOREQUAL OP_VERIFY\n    require((tx.outputs[0].value - tx.inputs[0].value) >= amount);\n\n\n    // Check that the Coupon is interacting with an existing Vault instance \n    // OP_0 OP_UTXOBYTECODE OP_1 OP_ROLL OP_EQUAL OP_VERIFY\n    require(tx.inputs[0].lockingBytecode == lock);\n\n    // The coupon must be spent as the last input, \n    //   therefore only coupon may be spent at a time.\n    // OP_INPUTINDEX OP_1 OP_ADD OP_TXINPUTCOUNT OP_NUMEQUAL\n    require(this.activeInputIndex+1 == tx.inputs.length);\n  }\n\n}\n```\n\n# Gantry\n\nThe gantry contract sends a fixed number of tokens into utxo \"threads\" on each vault contract for a given blocktime.\n\nThe gantry automates issuing fungible tokens into the vault.\n\nGantries issue vaults at different time intervals.\n\n|   Block Interval | 10^x  |     Spacing |\n| ---------------: | :---: | ----------: |\n|     1,000 blocks |   3   |     ~1 week |\n|    10,000 blocks |   4   | ~2.5 months |\n|   100,000 blocks |   5   |  ~23 months |\n| 1,000,000 blocks |   6   |   ~19 years |\n\nSo while one gantry issues vaults every week, another gantry will issue vaults every 2.5 months. In this way, it's possible to obtain tokens for any approximate date in the future, from any of forty vaults in use at one time.\n\nAnyone may that can construct a transaction to satisfy the requirement of the gantry `execute` function may step the gantry forward and commission tokens into a new vault.\n\nThe below version has seven (7) threads, each thread has enough tokens to satisfy locking the entire coin supply.\n\n```solidity\npragma cashscript ^0.10.0;\n\n// Gantry - Create vault contracts with fungible tokens in a uniform way. \n//\n// 2024-08-08 \n//\n// From: Future Bitcoin Cash\n//\n// Author: 2qx <2qx_in_the_future@small.neomailbox.ch>\n//\n// NFT commentment stores the next series locktime in 32-bit LE\n//\n// [ ] Require the minting baton in the input\n// [ ] Get the current step increment for the chain of futures\n// [ ] Get the current vault locktime to be printed.\n//\n//   either\n// [ ] Mint an array of FT utxos, \n// [ ] send them off to a Vault\n//\n//   or\n// [ ] skip every 10th print.\n//\n// [ ] increment locktime height value stored on NFT baton\n// [ ] assure NFT baton is returned\n//\n//\n//  Gantry i/o Flow:\n//\n//  Inputs              Outputs\n//  [0] NFT mintBaton   ->  [0] NFT mintBaton\n//                      =>  [1] FTs Vault\n//                      =>  [2] FTs Vault\n//                      =>  [3] FTs Vault\n//                      =>  [4] FTs Vault\n//                      =>  [5] FTs Vault\n//                      =>  [6] FTs Vault\n//                      =>  [7] FTs Vault\n//                          [8] OP_RETURN FBCH <locktime>\n//  \n//  ... but skip every 10th token print, \n//   which will be printed by the gantry of the next order.\n//  [0] NFT mintBaton   =>  [0] NFT mintBaton\n//\n// NOTE: The production version differs from the final audit:\n// - Sats to fund the Gantry transactions are secured in the baton UTXO (line 68),\n// - Some minor optimizations were made to stay under the 201 op_code limit:\n//   - used tokenAmount as number instead of stack variable [92,98,104...]\n//   - inlined op_return tag in single line require (line 137)\n//\n\n\ncontract Gantry(\n    int step, \n    bytes vaultUnlockingBytecode\n    ) {\n\n    function execute() {\n\n        // Gantry covenant and the associated NFT baton must be spent as index 0\n        // input and passed on to index 0 output, funded with some dust BCH in order\n        // to avoid griefing by someone with access to hashrate\n        require(this.activeInputIndex == 0);\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == \n        tx.outputs[this.activeInputIndex].lockingBytecode);\n        require(tx.inputs[this.activeInputIndex].tokenCategory ==\n            tx.outputs[this.activeInputIndex].tokenCategory);\n        require(tx.outputs[this.activeInputIndex].value == tx.inputs[this.activeInputIndex].value - 8500);\n\n        int locktime = int(tx.inputs[this.activeInputIndex].nftCommitment);\n\n        // Locktime stored in mutable NFT commitment MUST be incremented by <step>\n        // and stored as bytes4 LE uint again.\n        require(tx.outputs[this.activeInputIndex].nftCommitment ==\n            bytes4(locktime + step));\n\n        // Every 10th step, skip creating Vault and just increment the commitment\n        if((locktime / step) % 10 == 0) { \n            require(tx.outputs.length == 1);\n        } else {\n            // Construct redeem bytecode for the Vault instance being created\n            bytes theVault = \n                bytes(bytes(locktime).length) + bytes(locktime) + // int locktime\n                vaultUnlockingBytecode;\n            // Construct P2SH32 locking bytecode from redeem bytecode\n            bytes vaultLockingBytecode = 0xaa20 + hash256(theVault) + 0x87;\n\n            // Verify creation of Vault genesis outputs\n            require(tx.outputs[1].lockingBytecode == vaultLockingBytecode);\n            require(tx.outputs[1].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[1].nftCommitment == 0x);\n            require(tx.outputs[1].tokenAmount == 2100000000000000);\n            require(tx.outputs[1].value == 1000);\n\n            require(tx.outputs[2].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[2].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[2].nftCommitment == 0x);\n            require(tx.outputs[2].tokenAmount == 2100000000000000);     \n            require(tx.outputs[2].value == 1000);\n\n            require(tx.outputs[3].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[3].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[3].nftCommitment == 0x);\n            require(tx.outputs[3].tokenAmount == 2100000000000000);     \n            require(tx.outputs[3].value == 1000);\n\n            require(tx.outputs[4].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[4].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[4].nftCommitment == 0x);\n            require(tx.outputs[4].tokenAmount == 2100000000000000);     \n            require(tx.outputs[4].value == 1000);\n\n            require(tx.outputs[5].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[5].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[5].nftCommitment == 0x);\n            require(tx.outputs[5].tokenAmount == 2100000000000000);     \n            require(tx.outputs[5].value == 1000);\n\n            require(tx.outputs[6].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[6].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[6].nftCommitment == 0x);\n            require(tx.outputs[6].tokenAmount == 2100000000000000);     \n            require(tx.outputs[6].value == 1000);\n\n            require(tx.outputs[7].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[7].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[7].nftCommitment == 0x);\n            require(tx.outputs[7].tokenAmount == 2100000000000000);     \n            require(tx.outputs[7].value == 1000);\n\n\n            // Tag FT metadata for indexers \n            //\n            // 6a              OP_RETURN\n            // 04 46 42 43 48  FBCH\n            // 03 90 05 10     <locktime>\n            require(tx.outputs[8].lockingBytecode == 0x6a0446424348 +\n                                  bytes(bytes(locktime).length) +  bytes(locktime));\n            require(tx.outputs[8].tokenCategory == 0x);\n            require(tx.outputs[8].value == 0);\n\n            // Ensure no other outputs can be created\n            require(tx.outputs.length == 9);  \n\n        }     \n        \n    }\n}\n```\n\n# Battery\n\nThe battery deployed a fixed number of gantries, similar to the way gantries deploy vaults. It then burned the minting baton used to create the gantries minting batons.\n\n```solidity\npragma cashscript ^0.10.0;\n\n// Battery - Spawn an array of vault deploying gantries from a single utxo.\n//\n// 2024-08-08\n// \n// Executed in block #858,444 on Aug 10, 2024\n// 02eb65ab5ce602b3025bc0c139cd22709983ae1acb58f476b86d6e31dd585e55\n// bitcoincash:pd3hc4smdeu4kpwyvjq645d0ts5n9wxgvp3x7gg3my65u2kkw766xxxl8wdgp\n//\n// From: Future Bitcoin Cash\n//\n// Author: 2qx <2qx_in_the_future@small.neomailbox.ch>\n//\n// A Battery releases a series of Gantries at small powers of 10 that \n// go on to create Futures Vaults on those respective intervals.\n//\n// Given a minting NFT with the commitment containing a power of 10, \n// mint a sequence of NFTs with minting capability\n// sending mutable batons NFTs to the corresponding Gantry.\n//\n//  execute():\n//\n//  inputs                           outputs\n//  [0] Battery + NFT 0x40420F00 10ᴇ6 ->  [0] Gantry10ᴇ6 + NFT* <startTime>\n//                                    =>  [1] Battery    + NFT  0xA0860100\n//\n//  [0] Battery + NFT 0xA0860100 10ᴇ5 ->  [0] Gantry10ᴇ5 + NFT* <startTime>\n//                                    =>  [1] Battery    + NFT  0x10270000\n//\n//  ... 0x10270000 10ᴇ4 ... 0xE8030000 10ᴇ3 ... 0x64000000 10ᴇ2\n//\n//  [0] Battery + NFT 0x<end>        ->  [0]  Gantry10ᴇ2 + NFT* <startTime>\n//                                       [1]  Burn NFT, sats are unencumbered.\n//                                       \n//  NOTE:\n//  This final production version: \n//    - Swaps the order of outputs so Gantries are first.\n//       (this allows the mutable gantry NFT later mint FTs)\n//    - Accomodates variable length baton values, line 80\n//    - Funds the gantry with sats per lines 100, 104\n// \n\ncontract Battery(\n\n    // Correct contract initialization will have minting NFT's commitment\n    // set to <step> from the NFT commitment, which will be the step set for 1st minted gantry,\n    // and will then get decremented for the next one until end step is reached.\n\n    // The end is the smallest power of 10 to create a Gantry for.\n    int endStep,\n\n    // Base time from which to calculate each Gantry's starting point, e.g.:\n    // --| baseTime\n    //   |------------------------------------| gantry 0 start\n    //   |------------| gantry 1 start\n    //   |----| gantry 2 start\n    int baseTime,\n\n    // Redeem bytecode tail of the gantry contracts\n    bytes gantryReedemBytecodeTail,\n\n    // Redeem bytecode tail of the vault contracts\n    bytes vaultReedemBytecodeTail,\n\n) {\n\n    function execute() {\n\n        // Get the current step, we will mint a Gantry for this step\n        bytes stepBytes = tx.inputs[this.activeInputIndex].nftCommitment;\n        int step = int(stepBytes);\n\n        // Set the gantry's starting time at correct offset from baseTime\n        bytes4 gantryStart = bytes4(baseTime - (baseTime % step) + step);\n        require(tx.outputs[0].nftCommitment == gantryStart);\n\n        // Construct the full redeem bytecode for the Gantry instance\n        bytes gantryRedeemBytecode =\n            bytes(vaultReedemBytecodeTail.length) + vaultReedemBytecodeTail +\n            bytes(bytes(step).length)             + bytes(step)   + \n            gantryReedemBytecodeTail;\n\n        require(\n            // The first output must have the P2SH32 of the gantry redeem bytecode\n            0xaa20 + hash256(gantryRedeemBytecode) + 0x87\n            == tx.outputs[0].lockingBytecode\n        );\n\n        // Ensure that Gantry inherits a mutable NFT so that it may update the\n        // commitment as it mints its Vaults.\n        bytes gantryCategory =\n            tx.inputs[this.activeInputIndex].tokenCategory.split(32)[0] +\n            0x01;\n        require(tx.outputs[0].tokenCategory == gantryCategory);\n\n        // Exactly 2 outputs, so token state or BCH can't leak out.\n        require(tx.outputs.length == 2);\n\n        // Fund each gantry in a single utxo for about 100 years.\n        require(tx.outputs[0].value > 42500000000/step);\n\n        // Fee allowance = 1000\n        require(tx.outputs[1].value >\n            tx.inputs[this.activeInputIndex].value - 42500000000/step -\n            1800);\n\n        if(step > endStep) {\n            // Calculate and enforce next baton's step,\n            require(tx.outputs[1].nftCommitment == bytes4(step / 10));\n            // token category & capability (pass on minting NFT),\n            require(tx.outputs[1].tokenCategory ==\n                tx.inputs[this.activeInputIndex].tokenCategory);\n            // and contract code.\n            require(tx.outputs[1].lockingBytecode ==\n                tx.inputs[this.activeInputIndex].lockingBytecode);\n        } else {\n            // Burn the minting baton while allowing any remaining BCH\n            // to be extracted to output 1.\n            require(tx.outputs[1].tokenCategory == 0x);\n\n            // Note: output 1 still mints a Gantry in this same TX,\n            // and it will be the last one to get minted.\n        }\n    }\n}\n```"],"names":["csr","dev","prerender","insert_hydration","target","nav","anchor","p0","p1","img","p2","ul","h11","p5","pre0","h12","p8","pre1","h13","p11","p12","table","p13","p14","p15","pre2","p16","pre3"],"mappings":"uQAIO,MAAMA,GAAMC,GAINC,GAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;y2HCRzBC,EAQaC,EAAAC,EAAAC,CAAA,sCAYbH,EAA0FC,EAAAG,EAAAD,CAAA,WAC1FH,EAA0EC,EAAAI,EAAAF,CAAA,WAC1EH,EAAsEC,EAAAK,EAAAH,CAAA,WACtEH,EAAAC,EAAAM,EAAAJ,CAAA,WACAH,EAIIC,EAAAO,EAAAL,CAAA,6BAEJH,EAAuBC,EAAAQ,EAAAN,CAAA,6BAEvBH,EAAGC,EAAAS,EAAAP,CAAA,WACHH,EAiFAC,EAAAU,EAAAR,CAAA,qBACAH,EAAEC,EAAAW,EAAAT,CAAA,kDAGFH,EAAEC,EAAAY,EAAAV,CAAA,+BAEFH,EAyDkDC,EAAAa,EAAAX,CAAA,uBAClDH,EAAyBC,EAAAc,EAAAZ,CAAA,+BAEzBH,EAAkDC,EAAAe,EAAAb,CAAA,YAClDH,EAAqDC,EAAAgB,EAAAd,CAAA,YACrDH,EAAAC,EAAAiB,EAAAf,CAAA,YA+BAH,EAAyEC,EAAAkB,EAAAhB,CAAA,YACzEH,EAACC,EAAAmB,EAAAjB,CAAA,YACDH,EAAaC,EAAAoB,EAAAlB,CAAA,YACbH,EAmJ2DC,EAAAqB,EAAAnB,CAAA,0CAE3DH,EAAGC,EAAAsB,EAAApB,CAAA,YACHH,EA6HAC,EAAAuB,EAAArB,CAAA"}