{"version":3,"file":"3.D2Gj3PPv.js","sources":["../../../../../../src/routes/audit/+page.ts","../../../../../../src/routes/audit/+page.md"],"sourcesContent":["import { dev } from '$app/environment';\n\n// we don't need any JS on this page, though we'll load\n// it in dev so that we get hot module replacement\nexport const csr = dev;\n\n// since there's no dynamic data here, we can prerender\n// it so that it gets served as a static asset in production\nexport const prerender = true;\n","---\nlayout: splash\n---\n\n<svelte:head>\n\n<title>Audit</title>\n\n</svelte:head>\n\n>Although Vault and Coupon contracts are identical to the audit,\n>### the [Gantry](/contracts#gantry) and [Battery](/contracts#battery) contracts were modified as \"NOTED\" in the comments of the final versions.\n\n>Also note: the scope of the audit pertained to the on-chain contracts and the intended function of the overall contract system. Software such as wallets, plugins and libraries that interact with the contracts (like this webapp or software) are beyond the scope of the audit.\n\n\n# Introduction\n\nThis is an audit report on \"Future Bitcoin Cash\" system of Bitcoin Cash (BCH) smart contracts, made at request of 2qx.\n\n>Memorandum of Understanding - Future Bitcoin Cash Audit\n\n>2024-04-26  2qx to BCA\n\n>This is a memorandum of understanding between 2qx, (\"Client\") and bitcoincashautist (a.k.a. BCA, \"the Auditor\") for a review and written audit report of \"Future Bitcoin Cash\" contracts.\n\n>The Client proposes the audit will proceed in two phases. \n\n>First, and initial assessment will be given of potential flaws or mistakes in the workflow or logic of the contract system. Second, once the Client has revised the contracts with improvements and corrections, the Auditor may prepare a written report on the security of the contracts.\n\n>The scope of the report should address near and long term security concerns, but may be limited to the on-chain operation of the permanent contracts. The report may omit any consideration of one-time use bootstrapping contracts (i.e. the Battery). The report should address post-quantum and quantum-resistant concerns of the double-sha256 script locking mechanisms on the long term viability of the system. The report should note any potential for DDoS or other network attack vectors. \n\n>The Auditor's report must be submitted in markdown format to be hosted by the Client in the final app. \n\n>The Auditor's fee will be conveyed in Future Bitcoin fungible tokens. The fee will be conveyed as 2 FBCH UTXOs from each of the premiere vaults of the five timescale tranches, a total of 10 FBCH. To prevent the Client from the unsavory misfortune of holding a BCH-pegged liability, the Auditor will custody the 10 BCH necessary for creation of his FBCH tokens between the completion of the audit and the completion of the app. Once the Auditor retrieves his 2 FBCH x 5 from the premiere vaults, those FBCH tokens shall be considered by all parties to be free and unencumbered from any obligations or earmarks, i.e. that Auditor has been fully paid and may degen his Futures at will.\n\n>This is a non-binding memorandum of understanding without contingency.\n\n\n<code style=\"line-break:anywhere\">Signed: `H1ErlyrktMt2a5tRzWHfjQkbpNtOCtH/QWcKaR3bRcCkRLmQDuJ3ufDDMe2/83bclcZmyIcHeDk7v4Uku3vhZpw=`</code>\n\n# Overview\n\nFuture Bitcoin Cash (FBCH) fungible tokens will essentially be instances of [wrapped BCH tokens](https://wrapped.cash/) with additional clause that they can't be unwrapped until the timelock expires.\n\nThe contracts system will consist of 4 contracts: Battery, Gantry, Vault, and Coupon.\n\nFrom the point-of-view of someone getting paid in FBCH, his only concern is to audit the Vault contract and its genesis transaction, because it is the Vault that holds the backing BCH and underwrites the emitted FBCH.\n\nCoupon is a simple one-time covenant that can be used with some Vault instance in order to get a discount when minting FBCH.\n\nBattery and Gantry contracts are constructor contracts, contracts whose purpose is to create new instances of other contracts or tokens, according to specification.\nThe Battery will spawn a sequence of Gantries, and each Gantry will spawn a sequence of Vaults.\n\nThis will make it easier for any holder to audit FBCH genesis, as we only need to audit the contract system once, and from then on anyone interested in soundness of his FBCH can simply check that it has a Battery TXO of the correct category as ancestor, instead of having to analyze each Vault instance.\n\n# Vault\n\nWe will start with the most important contract - one which underwrites every emitted unit of FBCH.\n\n## Vault Summary\n\nWe find the contract to be doing what it intends to be doing:\n\n>Vault - Store coins locked for tokens until maturation date.\n\nPut simply, the contract can be used as follows:\n\n- if timelock has expired then it can be used to unwrap/wrap BCH from/to token\n- if timelock has not expired then it can be used only to wrap BCH to token\n\nand we found no way to break the contract, assuming it was instantiated properly (entirety of supply given to the contract in token category genesis TX).\n\nWe have some suggestions for improvement and optimization, please see analysis below.\n\n## Vault Contract Analysis\n\n```javascript\ncontract Vault(bytes4 locktime, bytes32 tokenCategory) {\n```\n\nThere is no need to specify locktime as `bytes4`.\nNatively the locktime is treated as a script number, so `int` type would be more appropriate, and use of `int(locktime)` could be avoided in the code below and save a byte (OP_BIN2NUM) in compiled bytecode.\nAs we will see later, the Vault bytecode is intended to be constructed by the Gantry contract, and use of fixed-size constructor parameter here could make that easier.\nWe're not convinced it is the best approach, because it is easy enough to generate a push sequence from a script number, especially if the number can be guaranteed to be greater than 16.\n\n```javascript\n        bool tokensRedeemed = (\n          tx.outputs[this.activeInputIndex].tokenAmount \n          - tx.inputs[this.activeInputIndex].tokenAmount\n          ) > 0;\n```\n\nThis is a good way to check that the user is attempting to unwrap.\nUsage of `this.activeInputIndex` in this way works similar to SIGHASH_ONE.\n\n```\n        bool toVault = tx.outputs[this.activeInputIndex].lockingBytecode \n                 == new LockingBytecodeP2SH32(hash256(this.activeBytecode));\n```\n\nOn its own, this code would force a wrongly instantiated thread (P2SH20) to mutate to P2SH32 on first usage, but it would also mean that the check becomes unnecessary from then on.\nNote that, because of other code below, instantiating the contract as P2SH20 would break the unwrap path.\n\nGenerally, we recommend against enforcing P2SH32 by the contract's code.\nRecursive covenant can be enforced more simply with:\n\n```solidity\n        bool toVault = tx.outputs[this.activeInputIndex].lockingBytecode \n                 == tx.inputs[this.activeInputIndex].lockingBytecode;\n```\n\nThis way, if properly instantiated as P2SH32 it will still remain P2SH32 for the lifetime of the contract thread.\nLikewise, if wrongly instantiated as P2SH20 it will remain P2SH20.\nInstead of encumbering even properly instantiated contracts with extra checks it should be responsibility of the app to instantiate the contract properly.\n\nIn any case, the `toVault` here is redundant, because code further below makes it so that, for properly instantiated contract (P2SH32), it's not possible for `toVault` to ever be false.\n\n```solidity\n        if(toVault && tokensRedeemed){\n            require(tx.time >= int(locktime));\n            require(tx.outputs[this.activeInputIndex].tokenCategory == tokenCategory);\n        } \n```\n\nGood approach to enforce locktime only for the case of token redemption.\nHowever, the token category check is redundant and can be removed, unless the intent is to have contract address be specifically usable only with the particular token category.\nThis check wouldn't prevent dusting the contract address with BCH or other token categories - it would just make all such UTXOs unspendable.\n\nWe recognize that hard-coding the categoryID would make it easier to use Electrum API to look up history of a particular token locked with the contract, and understand the choice due to current state of CashTokens infrastructure.\n\n```solidity\n        require(\n          tx.inputs[this.activeInputIndex].tokenCategory \n          == \n          tx.outputs[this.activeInputIndex].tokenCategory\n          );\n\n        require(\n          tx.outputs[this.activeInputIndex].lockingBytecode \n          == \n          tx.inputs[this.activeInputIndex].lockingBytecode\n          );\n\n        require(\n          tx.inputs[this.activeInputIndex].tokenAmount + \n          tx.inputs[this.activeInputIndex].value \n          == \n          tx.outputs[this.activeInputIndex].tokenAmount + \n          tx.outputs[this.activeInputIndex].value\n         );\n```\n\nStraight-forward way to enforce unwrapping/wrapping BCH from/to token, as already seen in [wrapped.cash](https://bitcoincashresearch.org/t/wbch-bch-wrapped-as-cash-token/1196).\nThis code makes some of the above code redundant, as already indicated above.\n\n## Vault Contract Design Notes\n\nAs it is, the contract can be used to wrap BCH even after timelock expiry.\nWe suggest to consider adding a NFT state to the Vault contract so that it can't be used for wrapping after timelock expires.\n\nAs it is, the contract will always leave 1 UTXO, even if never used.\nWe suggest to consider adding a clean-up spending path, so the contract can be burned at end of its lifetime, if all tokens are returned after the timelock.\n\n## Notes on Vault Edge Cases\n\nThe creator can instantiate the category with any number of UTXOs and split fungible token supply across them.\n\nUnless the creator has access to hashrate (which would allow him to circumvent network relay rules), each UTXO will have to be created with a dust amount of BCH.\n\nSomeone with hashrate could then wrap some BCH by interacting with 1 of the available UTXOs, and then (if timelock has expired) use the obtained wrapped BCH to deplete all other BCH UTXOs down to 0 BCH and make the threads unusable for regular users.\nHowever, one thread is still guaranteed to remain usable, because entirety of token-backing BCH will end up with that 1 UTXO.\n\nSimilarly, after timelock expiry, anyone can spend all contract UTXOs together and move entirety of BCH (sans the dust) to just 1 UTXO, without needing to lock up any of his own BCH.\nThis would force wrapped token holders to use only that 1 thread until someone would wrap using one of the other threads.\n\nAny regular user can obtain some wrapped BCH and then use it to create more UTXOs of the contract by funding them each with at least 1 token unit and dust amount of BCH.\nThere's no incentive to ever do this, because the user would only be losing money if he would do this.\n\nIf the category is instantiated with too low fungible token supply, then it would place a limit on how much BCH can be wrapped in total, and if multiple UTXOs exist it would allow for the possibility of reduction of number of threads.\nThis is trivial to prevent: at genesis, each UTXO should enough fungible tokens to be able to wrap whole BCH supply on its own.\n\nAt the limit, wrapping is multi-threaded until timelock, and unwrapping is single-threaded.\nIf single-threaded use is acceptable, then the contract needs no change.\n\nIf multi-threaded is desirable, then this contract code needs to be expanded, and that would come with caveats because the trade-off would be increasing contract size and with that the TX fee.\n\nAdopting the above suggestion of prohibiting wraps after timelock expiry would somewhat improve the multi-threadedness because only previous token holders could deplete individual threads of BCH and only if they had previously obtained enough FBCH.\n\n## Notes on Vault P2SH Collision\n\nWith hard-coded categoryID, the creator of category & contract would have enough degrees of freedom to attempt to brute-force categoryID (on creation) in order to find two redeem scripts that hash to the same P2SH20 address.\nWith P2SH32 that would be computationally infeasible therefore P2SH32 is recommended for the original contract code.\n\nThe original contract code is such that a P2SH20 variant unusable for users anyway, and creator would have nothing to gain from having an alternative, secret, redeem script available to him.\n\nUsers of the contract can't attempt a collision search anyway, because contract code enforces exact bytecode to be passed on.\n\nIf P2SH32 enforcement code would be removed, users should be aware of the need to verify that the contract was instantiated as P2SH32, as part of their due diligence on the app.\n\nUsers are expected to perform some due diligence on the contract in any dapp they use, anyway, so having the P2SH32 check in the contract code itself doesn't relieve them of their due diligence.\n\n## Notes on Vault Quantum Security\n\nThe P2SH32 variant is quantum secure against quantum preimage search because it would still be a 2<sup>128</sup> problem, even for quantum computers.\nIt is still theoretically vulnerable to quantum collision search, as it would be a 2<sup>85</sup> problem for quantum computers.\n\nWihout some scientific breakthrough, a 2<sup>85</sup> problem would still be [impractical](https://crypto.stackexchange.com/questions/102574/could-grovers-algorithm-perform-a-search-in-n-2-for-a-match-in-a-particular-sub).\n\nIn any case, due to nature of the contract, collision search attempt is possible only before contract instantiation and therefore P2SH32 contracts created before availability of hypothetical quantum computers would remain safe to use even after availability of such computers.\n\n## Notes on Vault Proper Category Initialization\n\nThe genesis transaction MUST NOT create any token UTXOs locked with any other bytecode than the Vault contract's P2SH32 address.\n\nThe genesis transaction SHOULD NOT create any NFTs.\n\nThe genesis transaction SHOULD create enough fungible token supply so that entirety of BCH supply can be wrapped.\n\n## Vault Alternative Contract\n\nBelow we present contract code with the above suggestions implemented.\n\nBecause hardcoded categoryID is removed, this contract's bytecode pattern doesn't offer enough degrees of freedom for a P2SH20 collision search.\nThe locktime offers only 4 bits of freedom, and some values would make it unusable or unconvincing, further reducing practically usable degrees of freedom.\n\nPermutations of lines of contract code (and resulting bytecode) would possibly allow a few more bits for the search, but it would be obvious to anyone that the below presented code was changed without a plausible reason.\n\nFor this reason, the below code is expected to be safe to use even as P2SH20.\n\n```solidity\ncontract Vault(int locktime, int maxSupply) {\n\n    function TerminateOrSwap() {\n\n        if (tx.outputs[this.activeInputIndex].lockingBytecode == 0x6a) {\n\n            // If the vault is being terminated then\n            // locktime must be expired...\n            require(tx.time >= locktime);\n            // ...and the exact amount of tokens already returned to\n            // the Vault instance which is getting burned...\n            require(tx.inputs[this.activeInputIndex].tokenAmount ==\n                maxSupply);\n            // ...and the remaining dust either burned or donated\n            // to miners.\n            require(tx.outputs.length == 1);\n\n        } else {\n\n            // If tokens are flowing back into this contract\n            if(tx.outputs[this.activeInputIndex].tokenAmount >\n                tx.inputs[this.activeInputIndex].tokenAmount\n            ) {\n                // enforce a BIP65 timelock \n                require(tx.time >= locktime);\n            }\n\n            // Pass on the token category & capability\n            require(tx.inputs[this.activeInputIndex].tokenCategory ==\n                tx.outputs[this.activeInputIndex].tokenCategory);\n            // Pass on the contract\n            require(tx.outputs[this.activeInputIndex].lockingBytecode == \n                tx.inputs[this.activeInputIndex].lockingBytecode);\n            // Pass on bch+token balance\n            require(tx.inputs[this.activeInputIndex].tokenAmount +\n                tx.inputs[this.activeInputIndex].value == \n                tx.outputs[this.activeInputIndex].tokenAmount + \n                tx.outputs[this.activeInputIndex].value);\n        }\n    }\n}\n```\n\n# Coupon\n\n## Coupon Summary\n\nCoupon is a simple one-time covenant that releases its funds only if some minimum amount of BCH is paid into a particular locking bytecode.\n\nWe found an error in the contract that would break it from performing the intended purpose.\nWith the error fixed, the contract can be considered fit for purpose of incentivizing interaction with Vault contracts.\n\n## Coupon Contract Analysis\n\n```solidity\nrequire(tx.outputs[0].value >= amount);\n```\n\nThis doesn't check whether something was added to the Vault.\nIt is possible that the Vault already had enough BCH because another user previously interacted with it.\nIn this case the coupon would be free money, since user wouldn't have to add his own BCH to the Vault.\n\nThe above should be changed to `require(tx.outputs[0].value - tx.inputs[0].value >= amount);`.\n\n```solidity\nrequire(tx.outputs[0].lockingBytecode == lock);\n```\n\nThe covenant only requires a matching locking script, however it doesn't check for a particular instance of the Vault.\nThis allows for use of any Vault instance with matching parameters, or even for creation of a brand new Vault instance in the same TX that spends the coupon, or a broken (unspendable) instance.\nEven so, the spender will still be required to lock his own BCH, which will remain locked until Vault's timelock expires.\n\nWe can prohibit Vault genesis and broken instances simply by requiring the locking bytecode on the input instead of on the output:\n\n```solidity\nrequire(tx.inputs[0].lockingBytecode == lock);\n```\n\nWhen `lock` is targeting the Vault bytecode, the output locking bytecode will still be enforced by transience: the Coupon requires Vault be spent in index 0 input, and the Vault being spent in index 0 input will require that it is passed on to index 0 output.\n\nAnyone can create an instance of Vault before hand and spend the Coupon with his instance.\nIf it is desired to target a particular instance, then the Coupon should require a particular categoryID, but that would increase the size of the Coupon contract.\n\nAlternatively, the Vault could be redesigned so that each instance carries an NFT such that it can't be separated from the Vault bytecode, in which case the Coupon could target the NFT and the locking bytecode requirement could be dropped.\n\n```solidity\nrequire(this.activeInputIndex+1 == tx.inputs.length);\n```\n\nFlexible way to restrict TX to just 1 Coupon. This allows the user to add any number of other inputs between index 0 and the last index.\n\n## Coupon Alternative Contract\n\n```solidity\ncontract Coupon(\n\n  // Minimum spent to claim the coupon.\n  int amount,\n  \n  // Destination for the zeroth (constraining) output.\n  bytes lock\n\n){\n\n  function apply() {\n    \n    // assure at the minium amount is sent as the first output\n    require(tx.outputs[0].value - tx.inputs[0].value >= amount);;\n\n    // Check that the Coupon is interacting with an existing Vault instance\n    require(tx.inputs[0].lockingBytecode == lock);\n  \n    // The coupon must be spent as the last input, \n    //   therefore only coupon may be spent at a time.\n    require(this.activeInputIndex+1 == tx.inputs.length);\n\n  }\n\n}\n```\n\n# Gantry\n\nThe Gantry ensures that Vault genesis transactions are properly initializing Vault token categories.\nThe benefit of having instances of Vault created by a Gantry is that any instance of Vault can be easily audited:\n\n1. Look up the TX where TXID == vaultCategoryID, that is the Vault's \"pre-genesis\" TX.\n2. Verify that the 1st output of the pre-genesis TX has the Gantry contract code.\n\nThis is proof enough that the Vault was created according to specification, because Gantry code is known, and by auditing that it properly enforces specification we can validate Vault genesis TX without actually seeing it.\n\nThis is convenient because then we don't need to use an indexer to look up the genesis TX, and so any FBCH can be audited simply by querying any node for the pre-genesis TX.\n\n## Gantry Summary\n\nWe find the contract to be doing what it intends to be doing.\n\n>Gantry - Create vault contracts with fungible tokens in a uniform way.\n\nThe contract is intended as a single thread recursive covenant that uses a mutable NFT's commitment to keep track of the next Vault instance's `timelock` parameter.\nWe found no way to break the contract, assuming it was instantiated properly (single mutable NFT created and given to the contract in token category genesis TX).\n\nWe have some suggestions for improvement and optimization, please see analysis below.\n\n## Gantry Contract Analysis\n\n```solidity\nrequire(tx.inputs[0].lockingBytecode == tx.outputs[0].lockingBytecode);\n```\n\nUsing a hard-coded input & output index without additional guards is dangerous because on its own it would make it possible to spend 2 UTXOs with the same contract as both index 0 and index 1, possibly making them interact in unintended ways, or even allow a forged UTXO to be spent as index 0 and cheat the covenant.\n\nAs it is, the contract doesn't limit the number of inputs or explicitly enforce this contract to be executed as input 0, which makes it hard to reason about whether it can be broken or not.\n\nBecause the contract code commits to a hardcoded `categoryID` and requires it on both index 0 input and index 0 output, then if placed on an NFT of the same category the NFT can't escape from the covenant, assuming the category was instantiated properly (created exactly 1 mutable NFT output in genesis TX).\nHowever, this kind of constraint leaves the contract open to some benign side-effects: the same contract can be placed on a pure BCH or another token category, in which case those UTXOs could be freely spent as inputs added to a TX spending the proper UTXO in index 0.\n\nWhen UTXO has to pass its own state to a new output, it's recommended to use `[this.activeInputIndex]` index instead of `[0]`.\nBoth will result in same size of compiled bytecode, but the former makes the programmer's intent more obvious.\n\nIf the contract thread has to live in index 0 then we recommend explicitly requiring it:\n\n```solidity\nrequire(this.activeInputIndex == 0);\n```\n\nto be sure that it is *this* UTXO that is satisfying other requirements on index 0 input, and not some other UTXO.\n\n```solidity\nrequire(tx.inputs[0].tokenCategory.split(32)[0] == tokenCategory);\n```\n\nThere is no need to hardcode `tokenCategory`, for same reasons as with the Vault contract.\n\nIf Gantry is correctly instantiated (genesis TX created single output of the category with mutable NFT and encumbered with the Gantry contract), then the next line:\n\n```solidity\nrequire(tx.inputs[0].tokenCategory == tx.outputs[0].tokenCategory);\n```\n\nwill suffice to enforce correctly passing on the token category.\n\n```solidity\nrequire(tx.outputs[0].tokenAmount == 0);\n```\n\nIf the Gantry category was instantiated without fungible tokens, then the above line is unnecessary.\n\n```solidity\nint step = int(stepBytes);\nint locktime = int(bytes4(tx.inputs[0].nftCommitment));\nrequire(tx.outputs[0].nftCommitment == bytes4(locktime+step));\n```\n\nThis enforces the mutable NFT to increment the stored state, but it forces the script number to be stored as `bytes4` fixed width LE integer in the NFT's commitment.\nIt could work the same if script number was stored directly, to avoid casting overheads.\nHowever, benefit of storing a number as fixed width LE integer is that generic block explorers etc. are likely to parse and display the number correctly (as opposed to parsing script numbers, support for which is not widespread).\nThe NFT and contract code will be slightly bigger than the alternative but since there will only be 1 NFT of the category in existence this is a good trade-off.\n\n```solidity\n        if((locktime/step)%10==0){ \n            require(tx.outputs.length == 1);\n        } else {\n```\n\nEvery 10th spend from this contract just increments the NFT's state without doing anything else.\nThe reason for this is to avoid overlap with other instances of this contract, as we will see when we get to analyzing the Battery contract.\n\n```solidity\n            bytes theVault = \n                0x20 + tx.inputs[0].outpointTransactionHash +   // new fungible category\n                0x04 + bytes4(tx.inputs[0].nftCommitment) +     // locktime\n                vaultUnlockingBytecode;    \n            bytes vaultLockingBytecode = 0xaa20 + hash256(theVault) + 0x87;\n```\n\nThis generates the locking bytecode for the Vault instance created in this spend.\n\nWe already commented that Vault could remove the categoryID, and use native script numbers.\nIn that case, the above code could be reworked to:\n\n```solidity\n            int lockTime = int(tx.inputs[0].nftCommitment)\n            bytes theVault = \n                bytes(lockTime).length + bytes(lockTime) +     // push locktime\n                vaultUnlockingBytecode;    \n            bytes vaultLockingBytecode = 0xaa20 + hash256(theVault) + 0x87;\n```\n\nAssuming Gantry was instantiated correctly (with a 4-byte timestamp and initial commitment greater than 16), we can be sure that the generated push sequence will be correct.\n\n```solidity\n            require(tx.outputs[1].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[1].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[1].tokenAmount == 300000000000000);     \n```\n\nThe bytecode and category checks are sound.\nIt would be good to require a dust BCH amount as well, else someone with access to hashrate could temporarily block normal operation by depleting the outputs of dust.\n\nThis still allows for creation of immutable NFTs with commitment decided by the spender.\nWe can restrict it to empty commitment with `require(tx.outputs[1].nftCommitment == 0x);`.\nHowever, this will still allow creation of empty immutable NFTs.\nThose will be a benign side-effect, and as it is the contract can't prohibit them due to how CashTokens introspection opcodes were designed (more info [here](https://github.com/cashtokens/cashtokens/issues/29)).\n\n```solidity\n            bytes announcement = new LockingBytecodeNullData([\n                0x46424348,\n                bytes(tx.inputs[0].nftCommitment.split(4)[0])\n                ]);\n            require(tx.outputs[8].lockingBytecode == announcement);\n```\n\nIf instantiated properly then there is no need for `.split(4)[0]` when contract code already enforces the commitment to be `bytes4`.\nBecause we know that proper instances will have exact 4 bytes of commitment, then we can hardcode the OP_RETURN & push opcodes:\n\n```solidity\nbytes announcement = 0x6a044642434804 + tx.inputs[this.activeInputIndex].nftCommitment;\n```\n\nwhich will compile to `<0x6a044642434804> OP_ACTIVEINPUTINDEX OP_UTXOCOMMITMENT OP_CAT`.\n\n```solidity\n            // Is this check necessary if the op_return is used?\n            require(tx.outputs[8].value == 0);\n```\n\nIt is recommended, and adding `require(tx.outputs[8].tokenCategory == 0x);` would be good, too.\n\n```solidity\n            require(int(tx.outputs.length) == 9);  \n```\n\nThis ensures that tokens of the new category can't \"leak\" outside the Vault contract.\nIf number of generated outputs is to be changed then this must be updated as well.\nAlso, the `int()` cast is redundant and can be removed.\n\n## Gantry Contract Design Notes\n\nAs it is, anyone can evolve the Gantry contract to create lots of instances Vault with timelocks far into the future.\nIf this is undesirable, then use of Gantry should be timelocked, too.\n\nSimilarly, if Gantry didn't issue Vaults for a while and last one created is in the past, then later it could be minting more instances of Vault with timelocks already expired, just to evolve until the instance that's actually desired.\nIf this is undesirable, then timeskip option could be added to the contract.\n\n## Notes on Gantry Edge Cases\n\nIf the `step` parameter is negative, then contract could still be used to mint some proper instances of Vault, if the genesis output's NFT is initialized with some commitment that encodes a timestamp in the future.\nHowever, the contract will become useless as soon as the last created Vault has `locktime` in the present, and later create broken instances if arrives to below 0.\n\nIf the `step` parameter is 0, then the contract will be useless because it can create unlimited instances of Vault with same locktimes.\n\nIf the commitment is bigger than 4 bytes, then the contract will be broken.\n\nIf the commitment is less than 4 bytes, the contract will work and only the genesis output will have a commitment less than 4 bytes, because first spend will enforce padding to 4 bytes.\n\nIf the `commitment` + `step` would become greater than 4 bytes, then the contract thread will halt / become unspendable.\n\n## Notes on Gantry P2SH Collision and Quantum Security\n\nSame comments as for Vault apply.\n\n## Notes on Gantry Proper Category Initialization\n\nThe genesis transaction MUST create one NFT with mutable capability and locked with the Gantry contract's P2SH32 address.\n\nThe `step` parameter MUST be a positive, greater than 0 integer, and less than INT4_MAX value.\n\nThe `commitment` SHOULD be initialized as 0-padded LE 4-byte integer.\n\nThe `commitment` MUST be a small enough value to allow at least one spend from the contract.\n\nThe Gantry genesis transaction MUST NOT create multiple token UTXOs of the category.\n\nThe Gantry genesis transaction MUST NOT create fungible tokens.\n\n## Gantry Alternative Contract\n\n```solidity\ncontract Gantry(\n    int step, \n    bytes vaultUnlockingBytecode\n) {\n    function execute() {\n        // Gantry covenant and the associated NFT baton must be spent as index 0\n        // input and passed on to index 0 output, funded with some dust BCH in order\n        // to avoid griefing by someone with access to hashrate\n        require(this.activeInputIndex == 0);\n        require(tx.inputs[this.activeInputIndex].lockingBytecode ==\n            tx.outputs[this.activeInputIndex].lockingBytecode);\n        require(tx.inputs[this.activeInputIndex].tokenCategory ==\n            tx.outputs[this.activeInputIndex].tokenCategory);\n        require(tx.outputs[this.activeInputIndex].value > 800);\n\n        // Read a bytes4 LE commitment and convert to script number\n        int locktime = int(tx.inputs[this.activeInputIndex].nftCommitment);\n\n        // Allow time-skip in case Vault to be minted has already expired\n        if (locktime <= tx.locktime) {\n            locktime = (tx.locktime / step + 1) * step;\n        }\n\n        int nextLocktime = locktime + step;\n\n        // Prevent the spender from rolling over from height-based timelock\n        // to timestamp-based timelock.\n        require(nextLocktime < 500000000);\n\n        // Locktime stored in mutable NFT commitment MUST be incremented by <step>\n        // and stored as bytes4 LE uint again.\n        require(tx.outputs[this.activeInputIndex].nftCommitment ==\n            bytes4(nextLocktime));\n\n        // Every 10th step, skip creating Vault and just increment the commitment\n        if((locktime / step) % 10 == 0) { \n            require(tx.outputs.length == 1);\n        } else {\n            // Construct redeem bytecode for the Vault instance being created\n            bytes theVault = \n                bytes(bytes(locktime).length) + bytes(locktime) + // int locktime\n                vaultUnlockingBytecode;\n            // Construct P2SH32 locking bytecode from redeem bytecode\n            bytes vaultLockingBytecode = 0xaa20 + hash256(theVault) + 0x87;\n\n            // Verify creation of Vault genesis outputs\n\n            // [1]\n            require(tx.outputs[1].lockingBytecode == vaultLockingBytecode);\n            require(tx.outputs[1].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[1].nftCommitment == 0x);\n            require(tx.outputs[1].tokenAmount == 2100000000000000);\n            require(tx.outputs[1].value > 800);\n\n            // [2]\n            require(tx.outputs[2].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[2].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[2].nftCommitment == 0x);\n            require(tx.outputs[2].tokenAmount == 2100000000000000);     \n            require(tx.outputs[2].value > 800);\n\n            // [3]\n            require(tx.outputs[3].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[3].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[3].nftCommitment == 0x);\n            require(tx.outputs[3].tokenAmount == 2100000000000000);     \n            require(tx.outputs[3].value > 800);\n\n            // [4]\n            require(tx.outputs[4].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[4].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[4].nftCommitment == 0x);\n            require(tx.outputs[4].tokenAmount == 2100000000000000);     \n            require(tx.outputs[4].value > 800);\n\n            // [5]\n            require(tx.outputs[5].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[5].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[5].nftCommitment == 0x);\n            require(tx.outputs[5].tokenAmount == 2100000000000000);     \n            require(tx.outputs[5].value > 800);\n\n            // [6]\n            require(tx.outputs[6].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[6].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[6].nftCommitment == 0x);\n            require(tx.outputs[6].tokenAmount == 2100000000000000);     \n            require(tx.outputs[6].value > 800);\n\n            // [7]\n            require(tx.outputs[7].lockingBytecode == vaultLockingBytecode);       \n            require(tx.outputs[7].tokenCategory == tx.inputs[0].outpointTransactionHash);\n            require(tx.outputs[7].nftCommitment == 0x);\n            require(tx.outputs[7].tokenAmount == 2100000000000000);     \n            require(tx.outputs[7].value > 800);\n\n            // Tag this FT mint for indexers \n            //\n            // 6a              OP_RETURN\n            // 04 46 42 43 48  <'FBCH'>\n            // 04 90 05 10 00  <locktime>\n            bytes announcement = \n                0x6a044642434804 + \n                tx.inputs[this.activeInputIndex].nftCommitment;\n            require(tx.outputs[8].lockingBytecode == announcement);\n            require(tx.outputs[8].tokenCategory == 0x);\n            require(tx.outputs[8].value == 0);\n\n            // Ensure no other outputs can be created\n            require(tx.outputs.length == 9);\n        }           \n    }\n}\n```\n\n# Battery\n\n## Battery Summary\n\nConstructs a series of properly initialized Gantry instances, which will all have the same categoryID inherited from the Battery.\n\nWe found errors in the contract that would break it from performing the intended purpose.\n\n## Battery Contract Analysis\n\n```solidity\nrequire(tx.time >= int(startTime));\n```\n\nThere is no need for this, this will just make it so that the contract system can't be deployed ahead of first Vault's expiration.\n\n```solidity\nrequire(tx.inputs.length == 1);\n```\n\nThere is no need for this if contract correctly verifies the outputs.\n\n```solidity\n        // Get the commitment \n        bytes4 stepBytes = bytes4(tx.inputs[0].nftCommitment);\n        int step = int(tx.inputs[0].nftCommitment);\n```\n\nNo need to convert to `bytes4` if the Battery was instantiated properly.\nIt will already be 4 bytes, and we need to keep it as bytes because we will need it later when constructing the instance of Gantry.\nAlso, the `step` can be converted from `stepBytes` instead of using TX introspection again.\nSuggested:\n\n```solidity\n        // Get the commitment \n        bytes stepBytes = tx.inputs[0].nftCommitment;\n        int step = int(stepBytes);\n```\n\nHowever, in the next lines:\n\n```solidity\n        // Set the gantry commitment to a block on increment in the near future.\n        bytes4 gantryStart = bytes4(startTime - (startTime % step) + step);\n        require(tx.outputs[1].nftCommitment == gantryStart);\n```\n\nwe do need to convert to `bytes4` because here we are preparing a script num value to be written into a new output so have to enforce desired format.\n\n```solidity\n        // Get the redeem bytecode of the gantry instance\n        bytes gantryRedeemBytecode = bytes(vaultUnlockingBytecode.length) + vaultUnlockingBytecode +\n                                     0x04 + stepBytes                                +  // stepBytes\n                                     0x20 + tx.inputs[0].tokenCategory.split(32)[0]  +  // This tokenCategory\n                                     gantryUnlockingBytecode;    \n```\n\nAssumption of 0x04 as push opcode for `stepBytes` is safe if Battery was initialized properly, since the covenant will guarantee it will stay 4 bytes further on.\n\n```solidity\n        require(\n            // The second output is the gantry lockingBytecode\n            0xaa20 + hash256(gantryRedeemBytecode) + 0x87\n            == tx.outputs[1].lockingBytecode\n        );\n```\n\nPlace a P2SH32 Vault on the 1st output.\n\n```solidity\n        bytes gantryCategory, bytes gantryCapability = tx.outputs[1].tokenCategory.split(32);\n\n        // Assure the gantry baton is a non-minting NFT\n        require(int(gantryCapability) == 0);\n        \n        // Assure the gantry category matches the battery category\n        require(gantryCategory == tx.inputs[0].tokenCategory.split(32)[0]);\n```\n\nThis would force the NFT to be immutable and break the Gantry because it needs mutable capability to function.\nFixed below, and suggested a simpler way to achieve it:\n\n```solidity\n    bytes gantryCategory =\n        tx.inputs[this.activeInputIndex].tokenCategory.split(32)[0] +\n        0x01;\n    require(tx.outputs[1].tokenCategory == gantryCategory);\n```\n\nThe below:\n\n```solidity\n        // Prevent all the value from being cleared off\n        require((tx.inputs[0].value - (tx.outputs[0].value + tx.outputs[1].value)) < 1000);\n```\n\nonly makes sure that a max. of 1000 sats can be extracted as fee or another output.\nIt doesn't prevent someone with hashrate from griefing the outputs by setting one of them to below dust value, or from giving most balance to the Gantry instead of back into Battery.\nAlso, since there's no constraint on the number of outputs, NFTs of the category can escape the contract system.\n\nWe should add:\n\n```solidity\nrequire(tx.outputs.length == 2);\n```\n\nand rework the code that follows to:\n\n```solidity\n        // Enforce exact dust amount on the Gantry so that remainder must go\n        // back into Battery or pure BCH change at index 0.\n        require(tx.outputs[1].value == 800);\n\n        if(step > end) {\n            // Calculate and enforce next baton's step,\n            require(bytes4(step / 10) == tx.outputs[0].nftCommitment);\n            // token category & capability (pass on minting NFT),\n            require(tx.inputs[0].tokenCategory == tx.outputs[0].tokenCategory);\n            // and contract code.\n            require(tx.inputs[0].lockingBytecode == tx.outputs[0].lockingBytecode);\n        } else {\n            // Burn the minting baton while allowing any remaining BCH\n            // to be extracted to output 0.\n            require(tx.outputs[0].tokenCategory == 0x);\n        }\n```\n\n## Battery Alternative Contract\n\n```solidity\ncontract Battery(\n\n    // Correct contract initialization will have minting NFT's commitment\n    // set to bytes4(step), which will be the step set for 1st minted gantry,\n    // and will then get decremented for the next one until end step is reached.\n\n    // The end is the lowest step to create a Gantry for.\n    int endStep,\n\n    // Base time from which to calculate each Gantry's starting point, e.g.:\n    // --| baseTime\n    //   |------------------------------------| gantry 0 start\n    //   |------------| gantry 1 start\n    //   |----| gantry 2 start\n    int baseTime,\n\n    // Redeem bytecode tail of the gantry contracts\n    bytes gantryReedemBytecodeTail,\n\n    // Redeem bytecode tail of the vault contracts\n    bytes vaultReedemBytecodeTail,\n\n) {\n\n    function execute() {\n\n        // Get the current step, we will mint a Gantry for this step\n        bytes stepBytes = tx.inputs[this.activeInputIndex].nftCommitment;\n        int step = int(stepBytes);\n\n        // Set the gantry's starting time at correct offset from baseTime\n        bytes4 gantryStart = bytes4(baseTime - (baseTime % step) + step);\n        require(tx.outputs[1].nftCommitment == gantryStart);\n\n        // Construct the full redeem bytecode for the Gantry instance\n        bytes gantryRedeemBytecode =\n            bytes(vaultReedemBytecodeTail.length) + vaultReedemBytecodeTail +\n            0x04 + stepBytes +\n            gantryReedemBytecodeTail;\n\n        require(\n            // The second output must have the P2SH32 of the gantry redeem bytecode\n            0xaa20 + hash256(gantryRedeemBytecode) + 0x87\n            == tx.outputs[1].lockingBytecode\n        );\n\n        // Ensure that Gantry inherits a mutable NFT so that it may update the\n        // commitment as it mints its Vaults.\n        bytes gantryCategory =\n            tx.inputs[this.activeInputIndex].tokenCategory.split(32)[0] +\n            0x01;\n        require(tx.outputs[1].tokenCategory == gantryCategory);\n\n        // Exactly 2 outputs, so token state or BCH can't leak out.\n        require(tx.outputs.length == 2);\n\n        // Enforce exact dust amount on the Gantry so that remainder must go\n        // back into Battery or pure BCH change at index 0.\n        require(tx.outputs[1].value == 800);\n\n        // Fee allowance = 1000\n        require(tx.outputs[0].value >\n            tx.inputs[this.activeInputIndex].value -\n            1800);\n\n        if(step > endStep) {\n            // Calculate and enforce next baton's step,\n            require(tx.outputs[0].nftCommitment == bytes4(step / 10));\n            // token category & capability (pass on minting NFT),\n            require(tx.outputs[0].tokenCategory ==\n                tx.inputs[this.activeInputIndex].tokenCategory);\n            // and contract code.\n            require(tx.outputs[0].lockingBytecode ==\n                tx.inputs[this.activeInputIndex].lockingBytecode);\n        } else {\n            // Burn the minting baton while allowing any remaining BCH\n            // to be extracted to output 0.\n            require(tx.outputs[0].tokenCategory == 0x);\n\n            // Note: output 1 still mints a Gantry in this same TX,\n            // and it will be the last one to get minted.\n        }\n    }\n}\n```\n\n# Final Review\n\nAfter the above review cycle, 2qx has implemented most suggestions and produced a new set of contracts, all of them found here: \n\n- <p style=\"line-break:anywhere\">https://github.com/2qx/future-bitcoin-cash/tree/3fab223e6472a24fda8b8c4cebc120a9293d7102/contracts</p>\n\nThe contract system is expected to perform as intended.\n\n[**Vault**](https://github.com/2qx/future-bitcoin-cash/blob/3fab223e6472a24fda8b8c4cebc120a9293d7102/contracts/vault.v2.cash)\n\nContract has implemented most suggestions and is expected to perform as intended.\n\nThe termination path has not been implemented, meaning it will be the lightest possible contract, and the trade-off is that each thread will leave a persistent UTXO in chain state.\n\n[**Coupon**](https://github.com/2qx/future-bitcoin-cash/blob/3fab223e6472a24fda8b8c4cebc120a9293d7102/contracts/coupon.v2.cash)\n\nContract has implemented most suggestions and is expected to perform as intended.\n\nIt targets just the bytecode (and not a particular category) so it can be used with any instance of a target Vault.\n\n[**Gantry**](https://github.com/2qx/future-bitcoin-cash/blob/3fab223e6472a24fda8b8c4cebc120a9293d7102/contracts/gantry.v2.cash)\n\nContract has implemented most suggestions and is expected to perform as intended.\n\nIt doesn't implement time-skip, meaning the contract is simpler but it will have to be called in sequence even if some Vaults it spawns may never be used or have expired already.\n\n[**Battery**](https://github.com/2qx/future-bitcoin-cash/blob/3fab223e6472a24fda8b8c4cebc120a9293d7102/contracts/battery.v2.cash)\n\nContract has implemented suggested [alternative contract](#battery-alternative-contract) verbatim and is expected to perform as intended.\n"],"names":["csr","dev","prerender","insert_hydration","target","nav","anchor","blockquote0","h10","blockquote2","blockquote3","blockquote5","blockquote7","blockquote8","blockquote10","h11","p12","p14","p15","p16","h12","h20","blockquote11","ul0","p23","h21","pre0","p24","pre1","p25","pre2","p26","p27","pre3","p28","p29","pre4","p31","pre5","p32","p33","p34","h23","p35","p36","p37","p38","p39","p40","p41","p42","p43","p44","p45","p47","h25","p49","p50","p51","h26","p53","p54","p55","p56","p58","pre6","h13","p59","p60","pre7","p61","p62","pre8","p63","p64","p65","p66","p67","pre10","p68","h210","pre11","h14","p69","ol1","p70","h211","p72","blockquote12","p74","p75","h212","p76","p77","p78","p79","p80","pre13","p81","p82","pre15","p84","p85","pre17","p86","pre18","p87","pre19","p89","pre20","p90","pre21","p91","p92","pre22","p93","pre23","pre24","p95","p96","p97","p98","p99","p100","p101","p102","h215","h216","p105","p106","p108","p110","h217","pre26","h15","p111","p112","pre27","p113","p114","pre29","p115","p116","p117","p118","p119","pre34","p120","pre35","p121","pre36","p122","p123","p124","pre38","h220","h16","ul1","p128","p129","p131","p132","p134","p135","p137","p138"],"mappings":"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"}