{"version":3,"file":"index.BwlQbabu.js","sources":["../../../../../../../../node_modules/.pnpm/lossless-json@2.0.11/node_modules/lossless-json/lib/esm/utils.js","../../../../../../../../node_modules/.pnpm/lossless-json@2.0.11/node_modules/lossless-json/lib/esm/LosslessNumber.js","../../../../../../../../node_modules/.pnpm/lossless-json@2.0.11/node_modules/lossless-json/lib/esm/numberParsers.js","../../../../../../../../node_modules/.pnpm/lossless-json@2.0.11/node_modules/lossless-json/lib/esm/revive.js","../../../../../../../../node_modules/.pnpm/lossless-json@2.0.11/node_modules/lossless-json/lib/esm/parse.js","../../../../../../../../node_modules/.pnpm/@electrum-cash+network@3.3.0_patch_hash=ghfkyoulghrqjtfh6ignnwjtjy/node_modules/@electrum-cash/network/dist/index.mjs"],"sourcesContent":["/**\n * Test whether a string contains an integer number\n */\nexport function isInteger(value) {\n  return INTEGER_REGEX.test(value);\n}\nvar INTEGER_REGEX = /^-?[0-9]+$/;\n\n/**\n * Test whether a string contains a number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n */\nexport function isNumber(value) {\n  return NUMBER_REGEX.test(value);\n}\nvar NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/;\n\n/**\n * Test whether a string can be safely represented with a number\n * without information loss.\n *\n * When approx is true, floating point numbers that lose a few digits but\n * are still approximately equal in value are considered safe too.\n * Integer numbers must still be exactly equal.\n */\nexport function isSafeNumber(value, config) {\n  var num = parseFloat(value);\n  var str = String(num);\n  var v = extractSignificantDigits(value);\n  var s = extractSignificantDigits(str);\n  if (v === s) {\n    return true;\n  }\n  if ((config === null || config === void 0 ? void 0 : config.approx) === true) {\n    // A value is approximately equal when:\n    // 1. it is a floating point number, not an integer\n    // 2. it has at least 14 digits\n    // 3. the first 14 digits are equal\n    var requiredDigits = 14;\n    if (!isInteger(value) && s.length >= requiredDigits && v.startsWith(s.substring(0, requiredDigits))) {\n      return true;\n    }\n  }\n  return false;\n}\nexport var UnsafeNumberReason = /*#__PURE__*/function (UnsafeNumberReason) {\n  UnsafeNumberReason[\"underflow\"] = \"underflow\";\n  UnsafeNumberReason[\"overflow\"] = \"overflow\";\n  UnsafeNumberReason[\"truncate_integer\"] = \"truncate_integer\";\n  UnsafeNumberReason[\"truncate_float\"] = \"truncate_float\";\n  return UnsafeNumberReason;\n}({});\n\n/**\n * When the provided value is an unsafe number, describe what the reason is:\n * overflow, underflow, truncate_integer, or truncate_float.\n * Returns undefined when the value is safe.\n */\nexport function getUnsafeNumberReason(value) {\n  if (isSafeNumber(value, {\n    approx: false\n  })) {\n    return undefined;\n  }\n  if (isInteger(value)) {\n    return UnsafeNumberReason.truncate_integer;\n  }\n  var num = parseFloat(value);\n  if (!isFinite(num)) {\n    return UnsafeNumberReason.overflow;\n  }\n  if (num === 0) {\n    return UnsafeNumberReason.underflow;\n  }\n  return UnsafeNumberReason.truncate_float;\n}\n\n/**\n * Convert a string into a number when it is safe to do so.\n * Throws an error otherwise, explaining the reason.\n */\nexport function toSafeNumberOrThrow(value, config) {\n  var number = parseFloat(value);\n  var unsafeReason = getUnsafeNumberReason(value);\n  if ((config === null || config === void 0 ? void 0 : config.approx) === true ? unsafeReason && unsafeReason !== UnsafeNumberReason.truncate_float : unsafeReason) {\n    var unsafeReasonText = unsafeReason.replace(/_\\w+$/, '');\n    throw new Error('Cannot safely convert to number: ' + \"the value '\".concat(value, \"' would \").concat(unsafeReasonText, \" and become \").concat(number));\n  }\n  return number;\n}\n\n/**\n * Get the significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.003400' returns '34'\n *   '120.5e+30' returns '1205'\n **/\nexport function extractSignificantDigits(value) {\n  return value\n  // from \"-0.250e+30\" to \"-0.250\"\n  .replace(EXPONENTIAL_PART_REGEX, '')\n\n  // from \"-0.250\" to \"-0250\"\n  .replace(DOT_REGEX, '')\n\n  // from \"-0250\" to \"-025\"\n  .replace(TRAILING_ZEROS_REGEX, '')\n\n  // from \"-025\" to \"25\"\n  .replace(LEADING_MINUS_AND_ZEROS_REGEX, '');\n}\nvar EXPONENTIAL_PART_REGEX = /[eE][+-]?\\d+$/;\nvar LEADING_MINUS_AND_ZEROS_REGEX = /^-?(0*)?/;\nvar DOT_REGEX = /\\./;\nvar TRAILING_ZEROS_REGEX = /0+$/;\n//# sourceMappingURL=utils.js.map","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { extractSignificantDigits, getUnsafeNumberReason, isInteger, isNumber, UnsafeNumberReason } from './utils.js';\n\n/**\n * A lossless number. Stores its numeric value as string\n */\nexport var LosslessNumber = /*#__PURE__*/function () {\n  function LosslessNumber(value) {\n    _classCallCheck(this, LosslessNumber);\n    // numeric value as string\n    // type information\n    _defineProperty(this, \"isLosslessNumber\", true);\n    if (!isNumber(value)) {\n      throw new Error('Invalid number (value: \"' + value + '\")');\n    }\n    this.value = value;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number or bigint.\n   *\n   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits\n   * - a bigint is returned for big integer numbers\n   * - an Error is thrown for values that will overflow or underflow\n   *\n   * Note that you can implement your own strategy for conversion by just getting the value as string\n   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,\n   * and toSafeNumberOrThrow to convert it to a numeric value.\n   */\n  _createClass(LosslessNumber, [{\n    key: \"valueOf\",\n    value: function valueOf() {\n      var unsafeReason = getUnsafeNumberReason(this.value);\n\n      // safe or truncate_float\n      if (unsafeReason === undefined || unsafeReason === UnsafeNumberReason.truncate_float) {\n        return parseFloat(this.value);\n      }\n\n      // truncate_integer\n      if (isInteger(this.value)) {\n        return BigInt(this.value);\n      }\n\n      // overflow or underflow\n      throw new Error('Cannot safely convert to number: ' + \"the value '\".concat(this.value, \"' would \").concat(unsafeReason, \" and become \").concat(parseFloat(this.value)));\n    }\n\n    /**\n     * Get the value of the LosslessNumber as string.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.value;\n    }\n\n    // Note: we do NOT implement a .toJSON() method, and you should not implement\n    // or use that, it cannot safely turn the numeric value in the string into\n    // stringified JSON since it has to be parsed into a number first.\n  }]);\n  return LosslessNumber;\n}();\n\n/**\n * Test whether a value is a LosslessNumber\n */\nexport function isLosslessNumber(value) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return value && _typeof(value) === 'object' && value.isLosslessNumber === true || false;\n}\n\n/**\n * Convert a number into a LosslessNumber if this is possible in a safe way\n * If the value has too many digits, or is NaN or Infinity, an error will be thrown\n */\nexport function toLosslessNumber(value) {\n  if (extractSignificantDigits(value + '').length > 15) {\n    throw new Error('Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself ' + \"(value: \".concat(value, \")\"));\n  }\n  if (isNaN(value)) {\n    throw new Error('Invalid number: NaN');\n  }\n  if (!isFinite(value)) {\n    throw new Error('Invalid number: ' + value);\n  }\n  return new LosslessNumber(String(value));\n}\n//# sourceMappingURL=LosslessNumber.js.map","import { LosslessNumber } from './LosslessNumber.js';\nimport { isInteger } from './utils.js';\nexport function parseLosslessNumber(value) {\n  return new LosslessNumber(value);\n}\nexport function parseNumberAndBigInt(value) {\n  return isInteger(value) ? BigInt(value) : parseFloat(value);\n}\n//# sourceMappingURL=numberParsers.js.map","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nimport { isLosslessNumber } from './LosslessNumber.js';\n/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param json   A JSON Object, Array, or value\n * @param reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n */\nexport function revive(json, reviver) {\n  return reviveValue({\n    '': json\n  }, '', json, reviver);\n}\n\n/**\n * Revive a value\n */\nfunction reviveValue(context, key, value, reviver) {\n  if (Array.isArray(value)) {\n    return reviver.call(context, key, reviveArray(value, reviver));\n  } else if (value && _typeof(value) === 'object' && !isLosslessNumber(value)) {\n    // note the special case for LosslessNumber,\n    // we don't want to iterate over the internals of a LosslessNumber\n    return reviver.call(context, key, reviveObject(value, reviver));\n  } else {\n    return reviver.call(context, key, value);\n  }\n}\n\n/**\n * Revive the properties of an object\n */\nfunction reviveObject(object, reviver) {\n  Object.keys(object).forEach(function (key) {\n    var value = reviveValue(object, key, object[key], reviver);\n    if (value !== undefined) {\n      object[key] = value;\n    } else {\n      delete object[key];\n    }\n  });\n  return object;\n}\n\n/**\n * Revive the properties of an Array\n */\nfunction reviveArray(array, reviver) {\n  for (var i = 0; i < array.length; i++) {\n    array[i] = reviveValue(array, i + '', array[i], reviver);\n  }\n  return array;\n}\n//# sourceMappingURL=revive.js.map","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { parseLosslessNumber } from './numberParsers.js';\nimport { revive } from './revive.js';\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * The parser is based on the parser of Tan Li Hou shared in\n * https://lihautan.com/json-parser-with-javascript/\n *\n * @param text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @param [parseNumber=parseLosslessNumber]\n * Pass a custom number parser. Input is a string, and the output can be unknown\n * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nexport function parse(text, reviver) {\n  var parseNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : parseLosslessNumber;\n  var i = 0;\n  var value = parseValue();\n  expectValue(value);\n  expectEndOfInput();\n  return reviver ? revive(value, reviver) : value;\n  function parseObject() {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      i++;\n      skipWhitespace();\n      var object = {};\n      var initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        if (!initial) {\n          eatComma();\n          skipWhitespace();\n        } else {\n          initial = false;\n        }\n        var start = i;\n        var key = parseString();\n        if (key === undefined) {\n          throwObjectKeyExpected();\n        }\n        skipWhitespace();\n        eatColon();\n        var _value = parseValue();\n        if (_value === undefined) {\n          throwObjectValueExpected();\n        }\n\n        // TODO: test deep equal instead of strict equal\n        if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(_value, object[key])) {\n          // Note that we could also test `if(key in object) {...}`\n          // or `if (object[key] !== 'undefined') {...}`, but that is slower.\n          throwDuplicateKey(key, start + 1);\n        }\n        object[key] = _value;\n      }\n      if (text.charCodeAt(i) !== codeClosingBrace) {\n        throwObjectKeyOrEndExpected();\n      }\n      i++;\n      return object;\n    }\n  }\n  function parseArray() {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      i++;\n      skipWhitespace();\n      var array = [];\n      var initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          eatComma();\n        } else {\n          initial = false;\n        }\n        var _value2 = parseValue();\n        expectArrayItem(_value2);\n        array.push(_value2);\n      }\n      if (text.charCodeAt(i) !== codeClosingBracket) {\n        throwArrayItemOrEndExpected();\n      }\n      i++;\n      return array;\n    }\n  }\n  function parseValue() {\n    var _ref, _ref2, _ref3, _ref4, _ref5, _parseString;\n    skipWhitespace();\n    var value = (_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_parseString = parseString()) !== null && _parseString !== void 0 ? _parseString : parseNumeric()) !== null && _ref5 !== void 0 ? _ref5 : parseObject()) !== null && _ref4 !== void 0 ? _ref4 : parseArray()) !== null && _ref3 !== void 0 ? _ref3 : parseKeyword('true', true)) !== null && _ref2 !== void 0 ? _ref2 : parseKeyword('false', false)) !== null && _ref !== void 0 ? _ref : parseKeyword('null', null);\n    skipWhitespace();\n    return value;\n  }\n  function parseKeyword(name, value) {\n    if (text.slice(i, i + name.length) === name) {\n      i += name.length;\n      return value;\n    }\n  }\n  function skipWhitespace() {\n    while (isWhitespace(text.charCodeAt(i))) {\n      i++;\n    }\n  }\n  function parseString() {\n    if (text.charCodeAt(i) === codeDoubleQuote) {\n      i++;\n      var result = '';\n      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {\n        if (text.charCodeAt(i) === codeBackslash) {\n          var char = text[i + 1];\n          var escapeChar = escapeCharacters[char];\n          if (escapeChar !== undefined) {\n            result += escapeChar;\n            i++;\n          } else if (char === 'u') {\n            if (isHex(text.charCodeAt(i + 2)) && isHex(text.charCodeAt(i + 3)) && isHex(text.charCodeAt(i + 4)) && isHex(text.charCodeAt(i + 5))) {\n              result += String.fromCharCode(parseInt(text.slice(i + 2, i + 6), 16));\n              i += 5;\n            } else {\n              throwInvalidUnicodeCharacter(i);\n            }\n          } else {\n            throwInvalidEscapeCharacter(i);\n          }\n        } else {\n          if (isValidStringCharacter(text.charCodeAt(i))) {\n            result += text[i];\n          } else {\n            throwInvalidCharacter(text[i]);\n          }\n        }\n        i++;\n      }\n      expectEndOfString();\n      i++;\n      return result;\n    }\n  }\n  function parseNumeric() {\n    var start = i;\n    if (text.charCodeAt(i) === codeMinus) {\n      i++;\n      expectDigit(start);\n    }\n    if (text.charCodeAt(i) === codeZero) {\n      i++;\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\n      i++;\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeDot) {\n      i++;\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++;\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++;\n      }\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (i > start) {\n      return parseNumber(text.slice(start, i));\n    }\n  }\n  function eatComma() {\n    if (text.charCodeAt(i) !== codeComma) {\n      throw new SyntaxError(\"Comma ',' expected after value \".concat(gotAt()));\n    }\n    i++;\n  }\n  function eatColon() {\n    if (text.charCodeAt(i) !== codeColon) {\n      throw new SyntaxError(\"Colon ':' expected after property name \".concat(gotAt()));\n    }\n    i++;\n  }\n  function expectValue(value) {\n    if (value === undefined) {\n      throw new SyntaxError(\"JSON value expected \".concat(gotAt()));\n    }\n  }\n  function expectArrayItem(value) {\n    if (value === undefined) {\n      throw new SyntaxError(\"Array item expected \".concat(gotAt()));\n    }\n  }\n  function expectEndOfInput() {\n    if (i < text.length) {\n      throw new SyntaxError(\"Expected end of input \".concat(gotAt()));\n    }\n  }\n  function expectDigit(start) {\n    if (!isDigit(text.charCodeAt(i))) {\n      var numSoFar = text.slice(start, i);\n      throw new SyntaxError(\"Invalid number '\".concat(numSoFar, \"', expecting a digit \").concat(gotAt()));\n    }\n  }\n  function expectEndOfString() {\n    if (text.charCodeAt(i) !== codeDoubleQuote) {\n      throw new SyntaxError(\"End of string '\\\"' expected \".concat(gotAt()));\n    }\n  }\n  function throwObjectKeyExpected() {\n    throw new SyntaxError(\"Quoted object key expected \".concat(gotAt()));\n  }\n  function throwDuplicateKey(key, pos) {\n    throw new SyntaxError(\"Duplicate key '\".concat(key, \"' encountered at position \").concat(pos));\n  }\n  function throwObjectKeyOrEndExpected() {\n    throw new SyntaxError(\"Quoted object key or end of object '}' expected \".concat(gotAt()));\n  }\n  function throwArrayItemOrEndExpected() {\n    throw new SyntaxError(\"Array item or end of array ']' expected \".concat(gotAt()));\n  }\n  function throwInvalidCharacter(char) {\n    throw new SyntaxError(\"Invalid character '\".concat(char, \"' \").concat(pos()));\n  }\n  function throwInvalidEscapeCharacter(start) {\n    var chars = text.slice(start, start + 2);\n    throw new SyntaxError(\"Invalid escape character '\".concat(chars, \"' \").concat(pos()));\n  }\n  function throwObjectValueExpected() {\n    throw new SyntaxError(\"Object value expected after ':' \".concat(pos()));\n  }\n  function throwInvalidUnicodeCharacter(start) {\n    var end = start + 2;\n    while (/\\w/.test(text[end])) {\n      end++;\n    }\n    var chars = text.slice(start, end);\n    throw new SyntaxError(\"Invalid unicode character '\".concat(chars, \"' \").concat(pos()));\n  }\n\n  // zero based character position\n  function pos() {\n    return \"at position \".concat(i);\n  }\n  function got() {\n    return i < text.length ? \"but got '\".concat(text[i], \"'\") : 'but reached end of input';\n  }\n  function gotAt() {\n    return got() + ' ' + pos();\n  }\n}\nfunction isWhitespace(code) {\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;\n}\nfunction isHex(code) {\n  return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;\n}\nfunction isDigit(code) {\n  return code >= codeZero && code <= codeNine;\n}\nfunction isNonZeroDigit(code) {\n  return code >= codeOne && code <= codeNine;\n}\nexport function isValidStringCharacter(code) {\n  return code >= 0x20 && code <= 0x10ffff;\n}\nexport function isDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every(function (item, index) {\n      return isDeepEqual(item, b[index]);\n    });\n  }\n  if (isObject(a) && isObject(b)) {\n    var keys = _toConsumableArray(new Set([].concat(_toConsumableArray(Object.keys(a)), _toConsumableArray(Object.keys(b)))));\n    return keys.every(function (key) {\n      return isDeepEqual(a[key], b[key]);\n    });\n  }\n  return false;\n}\nfunction isObject(value) {\n  return _typeof(value) === 'object' && value !== null;\n}\n\n// map with all escape characters\nvar escapeCharacters = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n};\n\nvar codeBackslash = 0x5c; // \"\\\"\nvar codeOpeningBrace = 0x7b; // \"{\"\nvar codeClosingBrace = 0x7d; // \"}\"\nvar codeOpeningBracket = 0x5b; // \"[\"\nvar codeClosingBracket = 0x5d; // \"]\"\nvar codeSpace = 0x20; // \" \"\nvar codeNewline = 0xa; // \"\\n\"\nvar codeTab = 0x9; // \"\\t\"\nvar codeReturn = 0xd; // \"\\r\"\nvar codeDoubleQuote = 0x0022; // \"\nvar codePlus = 0x2b; // \"+\"\nvar codeMinus = 0x2d; // \"-\"\nvar codeZero = 0x30;\nvar codeOne = 0x31;\nvar codeNine = 0x39;\nvar codeComma = 0x2c; // \",\"\nvar codeDot = 0x2e; // \".\" (dot, period)\nvar codeColon = 0x3a; // \":\"\nexport var codeUppercaseA = 0x41; // \"A\"\nexport var codeLowercaseA = 0x61; // \"a\"\nexport var codeUppercaseE = 0x45; // \"E\"\nexport var codeLowercaseE = 0x65; // \"e\"\nexport var codeUppercaseF = 0x46; // \"F\"\nexport var codeLowercaseF = 0x66; // \"f\"\n//# sourceMappingURL=parse.js.map","import {EventEmitter as $4QiMX$EventEmitter} from \"events\";\nimport {Mutex as $4QiMX$Mutex} from \"async-mutex\";\nimport $4QiMX$debug from \"debug\";\nimport {parse as $4QiMX$parse, parseNumberAndBigInt as $4QiMX$parseNumberAndBigInt, stringify as $4QiMX$stringify} from \"lossless-json\";\n//import {connect as $4QiMX$connect, TLSSocket as $4QiMX$TLSSocket} from \"tls\";\n//import {isIP as $4QiMX$isIP, connect as $4QiMX$connect1} from \"net\";\nimport {WebSocket as $4QiMX$WebSocket} from \"@monsterbitar/isomorphic-ws\";\n\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n// Create the debug logs.\nconst $ef5ba40c8abe5a13$var$debug = {\n    client: (0, $4QiMX$debug)(\"electrum-cash:client \"),\n    cluster: (0, $4QiMX$debug)(\"electrum-cash:cluster\"),\n    errors: (0, $4QiMX$debug)(\"electrum-cash:error  \"),\n    warning: (0, $4QiMX$debug)(\"electrum-cash:warning\"),\n    network: (0, $4QiMX$debug)(\"electrum-cash:network\"),\n    ping: (0, $4QiMX$debug)(\"electrum-cash:pulses \")\n};\n// Set log colors.\n$ef5ba40c8abe5a13$var$debug.client.color = \"2\";\n$ef5ba40c8abe5a13$var$debug.cluster.color = \"3\";\n$ef5ba40c8abe5a13$var$debug.errors.color = \"9\";\n$ef5ba40c8abe5a13$var$debug.warning.color = \"13\";\n$ef5ba40c8abe5a13$var$debug.network.color = \"4\";\n$ef5ba40c8abe5a13$var$debug.ping.color = \"8\";\nvar // Export the logs.\n$ef5ba40c8abe5a13$export$2e2bcd8739ae039 = $ef5ba40c8abe5a13$var$debug;\n\n\n\n/**\n * Grouping of utilities that simplifies implementation of the Electrum protocol.\n *\n * @ignore\n */ class $c78f59d21170b7a6$var$ElectrumProtocol {\n    /**\n\t * Helper function that builds an Electrum request object.\n\t *\n\t * @param {string} method       method to call.\n\t * @param {array}  parameters   method parameters for the call.\n\t * @param {string} requestId    unique string or number referencing this request.\n\t *\n\t * @returns a properly formatted Electrum request string.\n\t */ static buildRequestObject(method, parameters, requestId) {\n        // Return the formatted request object.\n        // NOTE: Electrum either uses JsonRPC strictly or loosely.\n        //       If we specify protocol identifier without being 100% compliant, we risk being disconnected/blacklisted.\n        //       For this reason, we omit the protocol identifier to avoid issues.\n        return JSON.stringify({\n            method: method,\n            params: parameters,\n            id: requestId\n        });\n    }\n    /**\n\t * Constant used to verify if a provided string is a valid version number.\n\t *\n\t * @returns a regular expression that matches valid version numbers.\n\t */ static get versionRegexp() {\n        return /^\\d+(\\.\\d+)+$/;\n    }\n    /**\n\t * Constant used to separate statements/messages in a stream of data.\n\t *\n\t * @returns the delimiter used by Electrum to separate statements.\n\t */ static get statementDelimiter() {\n        return \"\\n\";\n    }\n}\nvar // export the protocol.\n$c78f59d21170b7a6$export$2e2bcd8739ae039 = $c78f59d21170b7a6$var$ElectrumProtocol;\n\n\nvar $a192ea5a4eec42d4$exports = {};\n\n$parcel$export($a192ea5a4eec42d4$exports, \"isVersionRejected\", () => $a192ea5a4eec42d4$export$e1f38ab2b4ebdde6);\n$parcel$export($a192ea5a4eec42d4$exports, \"isVersionNegotiated\", () => $a192ea5a4eec42d4$export$9598f0c76aa41d73);\nconst $a192ea5a4eec42d4$export$e1f38ab2b4ebdde6 = function(object) {\n    return \"error\" in object;\n};\nconst $a192ea5a4eec42d4$export$9598f0c76aa41d73 = function(object) {\n    return \"software\" in object && \"protocol\" in object;\n};\n\n\nvar $5abc8fb342687c03$exports = {};\n\n$parcel$export($5abc8fb342687c03$exports, \"ElectrumTransport\", () => $5abc8fb342687c03$export$d048df559e6d3842);\n$parcel$export($5abc8fb342687c03$exports, \"DefaultParameters\", () => $5abc8fb342687c03$export$f019be48b3aacb1a);\nvar $a58372b18a18806e$exports = {};\n\n$parcel$export($a58372b18a18806e$exports, \"ClusterOrder\", () => $a58372b18a18806e$export$161fe3707f756bf9);\n$parcel$export($a58372b18a18806e$exports, \"ClusterDistribution\", () => $a58372b18a18806e$export$436a960acc41e848);\n$parcel$export($a58372b18a18806e$exports, \"ClusterStatus\", () => $a58372b18a18806e$export$c66b56bc0ff967ca);\n$parcel$export($a58372b18a18806e$exports, \"ClientState\", () => $a58372b18a18806e$export$c4f81c6d30ca200f);\n$parcel$export($a58372b18a18806e$exports, \"ConnectionStatus\", () => $a58372b18a18806e$export$7516420eb880ab68);\n// Disable indent rule for this file because it is broken (https://github.com/typescript-eslint/typescript-eslint/issues/1824)\n/* eslint-disable @typescript-eslint/indent */ /**\n * Enum that denotes the ordering to use in an ElectrumCluster.\n * @enum {number}\n * @property {0} RANDOM     Send requests to randomly selected servers in the cluster.\n * @property {1} PRIORITY   Send requests to servers in the cluster in the order they were added.\n */ var $a58372b18a18806e$export$161fe3707f756bf9;\n(function(ClusterOrder) {\n    ClusterOrder[ClusterOrder[\"RANDOM\"] = 0] = \"RANDOM\";\n    ClusterOrder[ClusterOrder[\"PRIORITY\"] = 1] = \"PRIORITY\";\n})($a58372b18a18806e$export$161fe3707f756bf9 || ($a58372b18a18806e$export$161fe3707f756bf9 = {}));\nvar $a58372b18a18806e$export$436a960acc41e848;\n(function(ClusterDistribution) {\n    ClusterDistribution[ClusterDistribution[\"ALL\"] = 0] = \"ALL\";\n})($a58372b18a18806e$export$436a960acc41e848 || ($a58372b18a18806e$export$436a960acc41e848 = {}));\nvar $a58372b18a18806e$export$c66b56bc0ff967ca;\n(function(ClusterStatus) {\n    ClusterStatus[ClusterStatus[\"DISABLED\"] = 0] = \"DISABLED\";\n    ClusterStatus[ClusterStatus[\"DEGRADED\"] = 1] = \"DEGRADED\";\n    ClusterStatus[ClusterStatus[\"READY\"] = 2] = \"READY\";\n})($a58372b18a18806e$export$c66b56bc0ff967ca || ($a58372b18a18806e$export$c66b56bc0ff967ca = {}));\nvar $a58372b18a18806e$export$c4f81c6d30ca200f;\n(function(ClientState) {\n    ClientState[ClientState[\"UNAVAILABLE\"] = 0] = \"UNAVAILABLE\";\n    ClientState[ClientState[\"AVAILABLE\"] = 1] = \"AVAILABLE\";\n})($a58372b18a18806e$export$c4f81c6d30ca200f || ($a58372b18a18806e$export$c4f81c6d30ca200f = {}));\nvar $a58372b18a18806e$export$7516420eb880ab68;\n(function(ConnectionStatus) {\n    ConnectionStatus[ConnectionStatus[\"DISCONNECTED\"] = 0] = \"DISCONNECTED\";\n    ConnectionStatus[ConnectionStatus[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    ConnectionStatus[ConnectionStatus[\"DISCONNECTING\"] = 2] = \"DISCONNECTING\";\n    ConnectionStatus[ConnectionStatus[\"CONNECTING\"] = 3] = \"CONNECTING\";\n    ConnectionStatus[ConnectionStatus[\"RECONNECTING\"] = 4] = \"RECONNECTING\";\n})($a58372b18a18806e$export$7516420eb880ab68 || ($a58372b18a18806e$export$7516420eb880ab68 = {}));\n\n\nconst $5abc8fb342687c03$export$d048df559e6d3842 = {\n    TCP: {\n        Port: 50001,\n        Scheme: \"tcp\"\n    },\n    TCP_TLS: {\n        Port: 50002,\n        Scheme: \"tcp_tls\"\n    },\n    WS: {\n        Port: 50003,\n        Scheme: \"ws\"\n    },\n    WSS: {\n        Port: 50004,\n        Scheme: \"wss\"\n    }\n};\nconst $5abc8fb342687c03$export$f019be48b3aacb1a = {\n    // Port number for TCP TLS connections\n    PORT: $5abc8fb342687c03$export$d048df559e6d3842.TCP_TLS.Port,\n    // Transport to connect to the Electrum server\n    TRANSPORT_SCHEME: $5abc8fb342687c03$export$d048df559e6d3842.TCP_TLS.Scheme,\n    // How long to wait before attempting to reconnect, in milliseconds.\n    RECONNECT: 5000,\n    // How long to wait for network operations before following up, in milliseconds.\n    TIMEOUT: 30000,\n    // Time between ping messages, in milliseconds. Pinging keeps the connection alive.\n    // The reason for pinging this frequently is to detect connection problems early.\n    PING_INTERVAL: 1000,\n    // How many servers are required before we trust information provided.\n    CLUSTER_CONFIDENCE: 1,\n    // How many servers we send requests to.\n    CLUSTER_DISTRIBUTION: (0, $a58372b18a18806e$export$436a960acc41e848).ALL,\n    // What order we select servers to send requests to.\n    CLUSTER_ORDER: (0, $a58372b18a18806e$export$161fe3707f756bf9).RANDOM,\n    // If we use BigInt for numbers in json when parsing and returning json response from the server.\n    USE_BIG_INT: false\n};\n\n\n\n\n\n\n\n\n\n/**\n * Isomorphic Socket interface supporting TCP sockets and WebSockets (Node and browser).\n * The interface is a subset of the TLSSocket interface with some slight modifications.\n * It can be expanded when more socket functionality is needed in the rest of the\n * electrum-cash code. Changes from the TLSSocket interface (besides it being a subset):\n * - Event 'close' -> 'disconnect'\n * - New function socket.disconnect()\n *\n * @ignore\n */ class $ea64e414b68fe23b$var$ElectrumSocket extends (0, $4QiMX$EventEmitter) {\n    /**\n\t * Connect to host:port using the specified transport\n\t *\n\t * @param {string} host              Fully qualified domain name or IP address of the host\n\t * @param {number} port              Network port for the host to connect to\n\t * @param {TransportScheme} scheme   Transport scheme to use\n\t * @param {number} timeout           If no connection is established after `timeout` ms, the connection is terminated\n\t *\n\t * @throws {Error} if an incorrect transport scheme is specified\n\t */ connect(host, port, scheme, timeout) {\n        // Check that no existing socket exists before initiating a new connection.\n        if (this.tcpSocket || this.webSocket) throw new Error(\"Cannot initiate a new socket connection when an existing connection exists\");\n        // Set a timer to force disconnect after `timeout` seconds\n        this.timers.disconnect = setTimeout(()=>this.disconnectOnTimeout(host, port, timeout), timeout);\n        // Remove the timer if a connection is successfully established\n        this.once(\"connect\", this.clearDisconnectTimerOnTimeout);\n        // Define how to refer to the connection scheme in debug output.\n        const socketTypes = {\n            [(0, $5abc8fb342687c03$export$d048df559e6d3842).TCP.Scheme]: \"a TCP Socket\",\n            [(0, $5abc8fb342687c03$export$d048df559e6d3842).TCP_TLS.Scheme]: \"an encrypted TCP socket\",\n            [(0, $5abc8fb342687c03$export$d048df559e6d3842).WS.Scheme]: \"a WebSocket\",\n            [(0, $5abc8fb342687c03$export$d048df559e6d3842).WSS.Scheme]: \"an encrypted WebSocket\"\n        };\n        // Log that we are trying to establish a connection.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Initiating ${socketTypes[scheme]} connection to '${host}:${port}'.`);\n        if (scheme === (0, $5abc8fb342687c03$export$d048df559e6d3842).TCP.Scheme || scheme === (0, $5abc8fb342687c03$export$d048df559e6d3842).TCP_TLS.Scheme) {\n            if (scheme === (0, $5abc8fb342687c03$export$d048df559e6d3842).TCP_TLS.Scheme) {\n                // Initialize connection options.\n                const connectionOptions = {\n                    rejectUnauthorized: false\n                };\n                // If the hostname is not an IP address..\n                if (!$4QiMX$isIP(host)) // Set the servername option which enables support for SNI.\n                // NOTE: SNI enables a server that hosts multiple domains to provide the appropriate TLS certificate.\n                connectionOptions.serverName = host;\n                // Initialize this.tcpSocket (allowing self-signed certificates).\n                this.tcpSocket = $4QiMX$connect(port, host, connectionOptions);\n                // Add a 'secureConnect' listener that checks the authorization status of\n                // the socket, and logs a warning when it uses a self signed certificate.\n                this.tcpSocket.once(\"secureConnect\", ()=>{\n                    // Cannot happen, since this event callback *only* exists on TLSSocket\n                    if (!(this.tcpSocket instanceof $4QiMX$TLSSocket)) return;\n                    // Force cast authorizationError from Error to string (through unknown)\n                    // because it is incorrectly typed as an Error\n                    const authorizationError = this.tcpSocket.authorizationError;\n                    if (authorizationError === \"DEPTH_ZERO_SELF_SIGNED_CERT\") (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).warning(`Connection to ${host}:${port} uses a self-signed certificate`);\n                });\n                // Trigger successful connection events.\n                this.tcpSocket.on(\"secureConnect\", this.onConnect.bind(this, socketTypes[scheme], host, port));\n            } else {\n                // Initialize this.tcpSocket.\n                this.tcpSocket = $4QiMX$connect1({\n                    host: host,\n                    port: port\n                });\n                // Trigger successful connection events.\n                this.tcpSocket.on(\"connect\", this.onConnect.bind(this, socketTypes[scheme], host, port));\n            }\n            // Configure encoding.\n            this.tcpSocket.setEncoding(\"utf8\");\n            // Enable persistent connections with an initial delay of 0.\n            this.tcpSocket.setKeepAlive(true, 0);\n            // Disable buffering of outgoing data.\n            this.tcpSocket.setNoDelay(true);\n            // Forward the encountered errors.\n            this.tcpSocket.on(\"error\", this.eventForwarders.tcpError);\n        } else if (scheme === (0, $5abc8fb342687c03$export$d048df559e6d3842).WS.Scheme || scheme === (0, $5abc8fb342687c03$export$d048df559e6d3842).WSS.Scheme) {\n            if (scheme === (0, $5abc8fb342687c03$export$d048df559e6d3842).WSS.Scheme) // Initialize this.webSocket (rejecting self-signed certificates).\n            // We reject self-signed certificates to match functionality of browsers.\n            this.webSocket = new (0, $4QiMX$WebSocket)(`wss://${host}:${port}`);\n            else // Initialize this.webSocket.\n            this.webSocket = new (0, $4QiMX$WebSocket)(`ws://${host}:${port}`);\n            // Trigger successful connection events.\n            this.webSocket.addEventListener(\"open\", this.onConnect.bind(this, socketTypes[scheme], host, port));\n            // Forward the encountered errors.\n            this.webSocket.addEventListener(\"error\", this.eventForwarders.wsError);\n        } else // Throw an error if an incorrect transport is specified\n        throw new Error(\"Incorrect transport specified\");\n    }\n    /**\n\t * Sets up forwarding of events related to the connection.\n\t *\n\t * @param {string} connectionType   Name of the connection/transport type, used for logging.\n\t * @param {string} host             Fully qualified domain name or IP address of the host\n\t * @param {number} port             Network port for the host to connect to\n\t */ onConnect(connectionType, host, port) {\n        // If the onConnect function has already run, do not execute it again.\n        if (this.onConnectHasRun) return;\n        // Log that the connection has been established.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Established ${connectionType} connection with '${host}:${port}'.`);\n        if (typeof this.tcpSocket !== \"undefined\") {\n            // Forward the socket events\n            this.tcpSocket.addListener(\"close\", this.eventForwarders.disconnect);\n            this.tcpSocket.addListener(\"data\", this.eventForwarders.tcpData);\n        } else if (typeof this.webSocket !== \"undefined\") {\n            // Forward the socket events\n            this.webSocket.addEventListener(\"close\", this.eventForwarders.disconnect);\n            this.webSocket.addEventListener(\"message\", this.eventForwarders.wsData);\n        }\n        // Indicate that the onConnect function has run.\n        this.onConnectHasRun = true;\n        // Emit the connect event.\n        this.emit(\"connect\");\n    }\n    /**\n\t * Clears the disconnect timer if it is still active.\n\t */ clearDisconnectTimerOnTimeout() {\n        // Clear the retry timer if it is still active.\n        if (this.timers.disconnect) clearTimeout(this.timers.disconnect);\n    }\n    /**\n\t * Forcibly terminate the connection.\n\t *\n\t * @throws {Error} if no connection was found\n\t */ disconnect() {\n        // Clear the disconnect timer so that the socket does not try to disconnect again later.\n        this.clearDisconnectTimerOnTimeout();\n        // Handle disconnect based differently depending on socket type.\n        if (this.tcpSocket) {\n            // Remove all event forwarders.\n            this.tcpSocket.removeListener(\"close\", this.eventForwarders.disconnect);\n            this.tcpSocket.removeListener(\"data\", this.eventForwarders.tcpData);\n            this.tcpSocket.removeListener(\"error\", this.eventForwarders.tcpError);\n            // Terminate the connection.\n            this.tcpSocket.destroy();\n            // Remove the stored socket.\n            this.tcpSocket = undefined;\n        } else if (this.webSocket) try {\n            // Remove all event forwarders.\n            this.webSocket.removeEventListener(\"close\", this.eventForwarders.disconnect);\n            this.webSocket.removeEventListener(\"message\", this.eventForwarders.wsData);\n            this.webSocket.removeEventListener(\"error\", this.eventForwarders.wsError);\n            // Gracefully terminate the connection.\n            this.webSocket.close();\n        } catch (ignored) {\n        // close() will throw an error if the connection has not been established yet.\n        // We ignore this error, since no similar error gets thrown in the TLS Socket.\n        } finally{\n            // Remove the stored socket regardless of any thrown errors.\n            this.webSocket = undefined;\n        }\n        // Indicate that the onConnect function has not run and it has to be run again.\n        this.onConnectHasRun = false;\n        // Emit a disconnect event\n        this.emit(\"disconnect\");\n    }\n    /**\n\t * Write data to the socket\n\t *\n\t * @param {Uint8Array | string} data   Data to be written to the socket\n\t * @param {function} callback          Callback function to be called when the write has completed\n\t *\n\t * @throws {Error} if no connection was found\n\t * @returns true if the message was fully flushed to the socket, false if part of the message\n\t * is queued in the user memory\n\t */ write(data, callback) {\n        if (this.tcpSocket) // Write data to the TLS Socket and return the status indicating whether the\n        // full message was flushed to the socket\n        return this.tcpSocket.write(data, callback);\n        if (this.webSocket) {\n            // Write data to the WebSocket\n            this.webSocket.send(data, callback);\n            // WebSockets always fit everything in a single request, so we return true\n            return true;\n        }\n        // Throw an error if no active connection is found\n        throw new Error(\"Cannot write to socket when there is no active connection\");\n    }\n    /**\n\t * Force a disconnection if no connection is established after `timeout` milliseconds.\n\t *\n\t * @param {string} host      Host of the connection that timed out\n\t * @param {number} port      Port of the connection that timed out\n\t * @param {number} timeout   Elapsed milliseconds\n\t */ disconnectOnTimeout(host, port, timeout) {\n        // Remove the connect listener.\n        this.removeListener(\"connect\", this.clearDisconnectTimerOnTimeout);\n        // Create a new timeout error.\n        const timeoutError = {\n            code: \"ETIMEDOUT\",\n            message: `Connection to '${host}:${port}' timed out after ${timeout} milliseconds`\n        };\n        // Emit an error event so that connect is rejected upstream.\n        this.emit(\"error\", timeoutError);\n        // Forcibly disconnect to clean up the connection on timeout\n        this.disconnect();\n    }\n    constructor(...args){\n        super(...args);\n        // Declare timers for keep-alive pings and reconnection\n        this.timers = {};\n        // Initialize boolean that indicates whether the onConnect function has run (initialize to false).\n        this.onConnectHasRun = false;\n        // Initialize event forwarding functions.\n        this.eventForwarders = {\n            disconnect: ()=>this.emit(\"disconnect\"),\n            tcpData: (data)=>this.emit(\"data\", data),\n            wsData: (event)=>this.emit(\"data\", `${event.data}\\n`),\n            tcpError: (err)=>this.emit(\"error\", err),\n            wsError: (event)=>this.emit(\"error\", event.error)\n        };\n    }\n}\nvar // export the socket.\n$ea64e414b68fe23b$export$2e2bcd8739ae039 = $ea64e414b68fe23b$var$ElectrumSocket;\n\n\n\n\n/**\n * Wrapper around TLS/WSS sockets that gracefully separates a network stream into Electrum protocol messages.\n *\n * @ignore\n */ class $1326c18f93f95fee$var$ElectrumConnection extends (0, $4QiMX$EventEmitter) {\n    /**\n\t * Sets up network configuration for an Electrum client connection.\n\t *\n\t * @param {string} application            your application name, used to identify to the electrum host.\n\t * @param {string} version                protocol version to use with the host.\n\t * @param {string} host                   fully qualified domain name or IP number of the host.\n\t * @param {number} port                   the network port of the host.\n\t * @param {TransportScheme} scheme        the transport scheme to use for connection\n\t * @param {number} timeout                how long network delays we will wait for before taking action, in milliseconds.\n\t * @param {number} pingInterval           the time between sending pings to the electrum host, in milliseconds.\n\t * @param {number} reconnectInterval      the time between reconnection attempts to the electrum host, in milliseconds.\n\t * @param {boolean} useBigInt\t  \t\t  whether to use bigint for numbers in json response.\n\t *\n\t * @throws {Error} if `version` is not a valid version string.\n\t */ constructor(application, version, host, port = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).PORT, scheme = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).TRANSPORT_SCHEME, timeout = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).TIMEOUT, pingInterval = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).PING_INTERVAL, reconnectInterval = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).RECONNECT, useBigInt = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).USE_BIG_INT){\n        // Initialize the event emitter.\n        super();\n        this.application = application;\n        this.version = version;\n        this.host = host;\n        this.port = port;\n        this.scheme = scheme;\n        this.timeout = timeout;\n        this.pingInterval = pingInterval;\n        this.reconnectInterval = reconnectInterval;\n        this.useBigInt = useBigInt;\n        this.// Declare timers for keep-alive pings and reconnection\n        timers = {};\n        this.// Initialize an empty array of connection verification timers.\n        // eslint-disable-next-line no-undef\n        verifications = [];\n        this.// Initialize the connected flag to false to indicate that there is no connection\n        status = (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTED;\n        this.// Initialize messageBuffer to an empty string\n        messageBuffer = \"\";\n        // Check if the provided version is a valid version number.\n        if (!(0, $c78f59d21170b7a6$export$2e2bcd8739ae039).versionRegexp.test(version)) // Throw an error since the version number was not valid.\n        throw new Error(`Provided version string (${version}) is not a valid protocol version number.`);\n        // Create an initial network socket.\n        this.createSocket();\n        // Handle visibility changes when run in a browser environment.\n        if (typeof document !== \"undefined\") document.addEventListener(\"visibilitychange\", this.handleVisibilityChange.bind(this));\n    }\n    /**\n\t * Returns a string for the host identifier for usage in debug messages.\n\t */ get hostIdentifier() {\n        return `${this.host}:${this.port}`;\n    }\n    /**\n\t * Create and configures a fresh socket and attaches all relevant listeners.\n\t */ createSocket() {\n        // Initialize a new ElectrumSocket\n        this.socket = new (0, $ea64e414b68fe23b$export$2e2bcd8739ae039)();\n        // Set up handlers for connection and disconnection.\n        this.socket.on(\"connect\", this.onSocketConnect.bind(this));\n        this.socket.on(\"disconnect\", this.onSocketDisconnect.bind(this));\n        // Set up handler for incoming data.\n        this.socket.on(\"data\", this.parseMessageChunk.bind(this));\n    }\n    /**\n\t * Shuts down and destroys the current socket.\n\t */ destroySocket() {\n        // Close the socket connection and destroy the socket.\n        this.socket.disconnect();\n    }\n    /**\n\t * Assembles incoming data into statements and hands them off to the message parser.\n\t *\n\t * @param {string} data   data to append to the current message buffer, as a string.\n\t *\n\t * @throws {SyntaxError} if the passed statement parts are not valid JSON.\n\t */ parseMessageChunk(data) {\n        // Update the timestamp for when we last received data.\n        this.lastReceivedTimestamp = Date.now();\n        // Clear and remove all verification timers.\n        this.verifications.forEach((timer)=>clearTimeout(timer));\n        this.verifications.length = 0;\n        // Add the message to the current message buffer.\n        this.messageBuffer += data;\n        // Check if the new message buffer contains the statement delimiter.\n        while(this.messageBuffer.includes((0, $c78f59d21170b7a6$export$2e2bcd8739ae039).statementDelimiter)){\n            // Split message buffer into statements.\n            const statementParts = this.messageBuffer.split((0, $c78f59d21170b7a6$export$2e2bcd8739ae039).statementDelimiter);\n            // For as long as we still have statements to parse..\n            while(statementParts.length > 1){\n                // Move the first statement to its own variable.\n                const currentStatementList = String(statementParts.shift());\n                // Parse the statement into an object or list of objects.\n                let statementList = (0, $4QiMX$parse)(currentStatementList, null, this.useBigInt ? (0, $4QiMX$parseNumberAndBigInt) : parseFloat);\n                // Wrap the statement in an array if it is not already a batched statement list.\n                if (!Array.isArray(statementList)) statementList = [\n                    statementList\n                ];\n                // For as long as there is statements in the result set..\n                while(statementList.length > 0){\n                    // Move the first statement from the batch to its own variable.\n                    const currentStatement = statementList.shift();\n                    // If the current statement is a version negotiation response..\n                    if (currentStatement.id === \"versionNegotiation\") {\n                        if (currentStatement.error) // Then emit a failed version negotiation response signal.\n                        this.emit(\"version\", {\n                            error: currentStatement.error\n                        });\n                        else // Emit a successful version negotiation response signal.\n                        this.emit(\"version\", {\n                            software: currentStatement.result[0],\n                            protocol: currentStatement.result[1]\n                        });\n                        continue;\n                    }\n                    // If the current statement is a keep-alive response..\n                    if (currentStatement.id === \"keepAlive\") continue;\n                    // Emit the statements for handling higher up in the stack.\n                    this.emit(\"statement\", currentStatement);\n                }\n            }\n            // Store the remaining statement as the current message buffer.\n            this.messageBuffer = statementParts.shift() || \"\";\n        }\n    }\n    /**\n\t * Sends a keep-alive message to the host.\n\t *\n\t * @returns true if the ping message was fully flushed to the socket, false if\n\t * part of the message is queued in the user memory\n\t */ ping() {\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).ping(`Sending keep-alive ping to '${this.hostIdentifier}'`);\n        // Craft a keep-alive message.\n        const message = (0, $c78f59d21170b7a6$export$2e2bcd8739ae039).buildRequestObject(\"server.ping\", [], \"keepAlive\");\n        // Send the keep-alive message.\n        const status = this.send(message);\n        // Return the ping status.\n        return status;\n    }\n    /**\n\t * Initiates the network connection negotiates a protocol version. Also emits the 'connect' signal if successful.\n\t *\n\t * @throws {Error} if the socket connection fails.\n\t * @returns a promise resolving when the connection is established\n\t */ async connect() {\n        // If we are already connected return true.\n        if (this.status === (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED) return;\n        // Indicate that the connection is connecting\n        this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTING;\n        // Define a function to wrap connection as a promise.\n        const connectionResolver = (resolve, reject)=>{\n            const rejector = (error)=>{\n                // Set the status back to disconnected\n                this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTED;\n                // Reject with the error as reason\n                reject(error);\n            };\n            // Replace previous error handlers to reject the promise on failure.\n            this.socket.removeAllListeners(\"error\");\n            this.socket.once(\"error\", rejector);\n            // Define a function to wrap version negotiation as a callback.\n            const versionNegotiator = ()=>{\n                // Write a log message to show that we have started version negotiation.\n                (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Requesting protocol version ${this.version} with '${this.hostIdentifier}'.`);\n                // remove the one-time error handler since no error was detected.\n                this.socket.removeListener(\"error\", rejector);\n                // Build a version negotiation message.\n                const versionMessage = (0, $c78f59d21170b7a6$export$2e2bcd8739ae039).buildRequestObject(\"server.version\", [\n                    this.application,\n                    this.version\n                ], \"versionNegotiation\");\n                // Define a function to wrap version validation as a function.\n                const versionValidator = (version)=>{\n                    // Check if version negotiation failed.\n                    if ((0, $a192ea5a4eec42d4$export$e1f38ab2b4ebdde6)(version)) {\n                        // Disconnect from the host.\n                        this.disconnect(true);\n                        // Declare an error message.\n                        const errorMessage = \"unsupported protocol version.\";\n                        // Log the error.\n                        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(`Failed to connect with ${this.hostIdentifier} due to ${errorMessage}`);\n                        // Reject the connection with false since version negotiation failed.\n                        reject(errorMessage);\n                    } else if (version.protocol !== this.version && `${version.protocol}.0` !== this.version && `${version.protocol}.0.0` !== this.version) {\n                        // Disconnect from the host.\n                        this.disconnect(true);\n                        // Declare an error message.\n                        const errorMessage = `incompatible protocol version negotiated (${version.protocol} !== ${this.version}).`;\n                        // Log the error.\n                        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(`Failed to connect with ${this.hostIdentifier} due to ${errorMessage}`);\n                        // Reject the connection with false since version negotiation failed.\n                        reject(errorMessage);\n                    } else {\n                        // Write a log message.\n                        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Negotiated protocol version ${version.protocol} with '${this.hostIdentifier}', powered by ${version.software}.`);\n                        // Set connection status to connected\n                        this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED;\n                        // Emit a connect event now that the connection is usable.\n                        this.emit(\"connect\");\n                        // Resolve the connection promise since we successfully connected and negotiated protocol version.\n                        resolve();\n                    }\n                };\n                // Listen for version negotiation once.\n                this.once(\"version\", versionValidator);\n                // Send the version negotiation message.\n                this.send(versionMessage);\n            };\n            // Prepare the version negotiation.\n            this.socket.once(\"connect\", versionNegotiator);\n            // Set up handler for network errors.\n            this.socket.on(\"error\", this.onSocketError.bind(this));\n            // Connect to the server.\n            this.socket.connect(this.host, this.port, this.scheme, this.timeout);\n        };\n        // Wait until connection is established and version negotiation succeeds.\n        await new Promise(connectionResolver);\n    }\n    /**\n\t * Restores the network connection.\n\t */ async reconnect() {\n        // If a reconnect timer is set, remove it\n        await this.clearReconnectTimer();\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Trying to reconnect to '${this.hostIdentifier}'..`);\n        // Set the status to reconnecting for more accurate log messages.\n        this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).RECONNECTING;\n        // Destroy and recreate the socket to get a clean slate.\n        this.destroySocket();\n        this.createSocket();\n        try {\n            // Try to connect again.\n            await this.connect();\n        } catch (error) {\n        // Do nothing as the error should be handled via the disconnect and error signals.\n        }\n    }\n    /**\n\t * Removes the current reconnect timer.\n\t */ clearReconnectTimer() {\n        // If a reconnect timer is set, remove it\n        if (this.timers.reconnect) clearTimeout(this.timers.reconnect);\n        // Reset the timer reference.\n        this.timers.reconnect = undefined;\n    }\n    /**\n\t * Removes the current keep-alive timer.\n\t */ clearKeepAliveTimer() {\n        // If a keep-alive timer is set, remove it\n        if (this.timers.keepAlive) clearTimeout(this.timers.keepAlive);\n        // Reset the timer reference.\n        this.timers.keepAlive = undefined;\n    }\n    /**\n\t * Initializes the keep alive timer loop.\n\t */ setupKeepAliveTimer() {\n        // If the keep-alive timer loop is not currently set up..\n        if (!this.timers.keepAlive) // Set a new keep-alive timer.\n        this.timers.keepAlive = setTimeout(this.ping.bind(this), this.pingInterval);\n    }\n    /**\n\t * Tears down the current connection and removes all event listeners on disconnect.\n\t *\n\t * @param {boolean} force         disconnect even if the connection has not been fully established yet.\n\t * @param {boolean} intentional   update connection state if disconnect is intentional.\n\t *\n\t * @returns true if successfully disconnected, or false if there was no connection.\n\t */ async disconnect(force = false, intentional = true) {\n        // Return early when there is nothing to disconnect from\n        if (this.status === (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTED && !force) // Return false to indicate that there was nothing to disconnect from.\n        return false;\n        // Update connection state if the disconnection is intentional.\n        // NOTE: The state is meant to represent what the client is requesting, but\n        //       is used internally to handle visibility changes in browsers to ensure functional reconnection.\n        if (intentional) // Set connection status to null to indicate tear-down is currently happening.\n        this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTING;\n        // If a keep-alive timer is set, remove it.\n        await this.clearKeepAliveTimer();\n        // If a reconnect timer is set, remove it\n        await this.clearReconnectTimer();\n        const disconnectResolver = (resolve)=>{\n            // Resolve to true after the connection emits a disconnect\n            this.once(\"disconnect\", ()=>resolve(true));\n            // Close the connection and destroy the socket.\n            this.destroySocket();\n        };\n        // Return true to indicate that we disconnected.\n        return new Promise(disconnectResolver);\n    }\n    /**\n\t * Updates connection state based on application visibility.\n\t *\n\t * Some browsers will disconnect network connections when the browser is out of focus,\n\t * which would normally cause our reconnect-on-timeout routines to trigger, but that\n\t * results in a poor user experience since the events are not handled consistently\n\t * and sometimes it can take some time after restoring focus to the browser.\n\t *\n\t * By manually disconnecting when this happens we prevent the default reconnection routines\n\t * and make the behavior consistent across browsers.\n\t */ async handleVisibilityChange() {\n        // Disconnect when application is removed from focus.\n        if (document.visibilityState === \"hidden\") {\n            const forceDisconnect = true;\n            const isIntended = false;\n            this.disconnect(forceDisconnect, isIntended);\n        }\n        // Reconnect when application is returned to focus.\n        if (document.visibilityState === \"visible\") this.reconnect();\n    }\n    /**\n\t * Sends an arbitrary message to the server.\n\t *\n\t * @param {string} message   json encoded request object to send to the server, as a string.\n\t *\n\t * @returns true if the message was fully flushed to the socket, false if part of the message\n\t * is queued in the user memory\n\t */ send(message) {\n        // Remove the current keep-alive timer if it exists.\n        this.clearKeepAliveTimer();\n        // Get the current timestamp in milliseconds.\n        const currentTime = Date.now();\n        // Follow up and verify that the message got sent..\n        const verificationTimer = setTimeout(this.verifySend.bind(this, currentTime), this.timeout);\n        // Store the verification timer locally so that it can be cleared when data has been received.\n        this.verifications.push(verificationTimer);\n        // Set a new keep-alive timer.\n        this.setupKeepAliveTimer();\n        // Write the message to the network socket.\n        return this.socket.write(message + (0, $c78f59d21170b7a6$export$2e2bcd8739ae039).statementDelimiter);\n    }\n    // --- Event managers. --- //\n    /**\n\t * Marks the connection as timed out and schedules reconnection if we have not\n\t * received data within the expected time frame.\n\t */ verifySend(sentTimestamp) {\n        // If we haven't received any data since we last sent data out..\n        if (Number(this.lastReceivedTimestamp) < sentTimestamp) {\n            // If this connection is already disconnected, we do not change anything\n            if (this.status === (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTED || this.status === (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTING) {\n                (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(`Tried to verify already disconnected connection to '${this.hostIdentifier}'`);\n                return;\n            }\n            // Remove the current keep-alive timer if it exists.\n            this.clearKeepAliveTimer();\n            // Write a notification to the logs.\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Connection to '${this.hostIdentifier}' timed out.`);\n            // Close the connection to avoid re-use.\n            // NOTE: This initiates reconnection routines if the connection has not\n            //       been marked as intentionally disconnected.\n            this.socket.disconnect();\n        }\n    }\n    /**\n\t * Updates the connection status when a connection is confirmed.\n\t */ onSocketConnect() {\n        // If a reconnect timer is set, remove it.\n        this.clearReconnectTimer();\n        // Set up the initial timestamp for when we last received data from the server.\n        this.lastReceivedTimestamp = Date.now();\n        // Set up the initial keep-alive timer.\n        this.setupKeepAliveTimer();\n        // Clear all temporary error listeners.\n        this.socket.removeAllListeners(\"error\");\n        // Set up handler for network errors.\n        this.socket.on(\"error\", this.onSocketError.bind(this));\n    }\n    /**\n\t * Updates the connection status when a connection is ended.\n\t */ onSocketDisconnect() {\n        // Send a disconnect signal higher up the stack.\n        this.emit(\"disconnect\");\n        // Remove the current keep-alive timer if it exists.\n        this.clearKeepAliveTimer();\n        // If this is a connection we're trying to tear down..\n        if (this.status === (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTING) {\n            // If a reconnect timer is set, remove it.\n            this.clearReconnectTimer();\n            // Remove all event listeners\n            this.removeAllListeners();\n            // Mark the connection as disconnected.\n            this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTED;\n            // Write a log message.\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Disconnected from '${this.hostIdentifier}'.`);\n        } else {\n            // If this is for an established connection..\n            if (this.status === (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED) // Write a notification to the logs.\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(`Connection with '${this.hostIdentifier}' was closed, trying to reconnect in ${this.reconnectInterval / 1000} seconds.`);\n            // Mark the connection as disconnected for now..\n            this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTED;\n            // If we don't have a pending reconnection timer..\n            if (!this.timers.reconnect) // Attempt to reconnect after one keep-alive duration.\n            this.timers.reconnect = setTimeout(this.reconnect.bind(this), this.reconnectInterval);\n        }\n    }\n    /**\n\t * Notify administrator of any unexpected errors.\n\t */ onSocketError(error) {\n        // Report a generic error if no error information is present.\n        // NOTE: When using WSS, the error event explicitly\n        //       only allows to send a \"simple\" event without data.\n        //       https://stackoverflow.com/a/18804298\n        if (typeof error === \"undefined\") // Do nothing, and instead rely on the socket disconnect event for further information.\n        return;\n        // If the DNS lookup failed.\n        if (error.code === \"EAI_AGAIN\") {\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(`Failed to look up DNS records for '${this.host}'.`);\n            return;\n        }\n        // If the connection timed out..\n        if (error.code === \"ETIMEDOUT\") {\n            // Log the provided timeout message.\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(error.message);\n            return;\n        }\n        // Log unknown error\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(`Unknown network error ('${this.hostIdentifier}'): `, error);\n    }\n}\nvar // Export the connection.\n$1326c18f93f95fee$export$2e2bcd8739ae039 = $1326c18f93f95fee$var$ElectrumConnection;\n\n\n\n\n\n\n// Acceptable parameter types for RPC messages\nconst $7c0fb93e8eea922a$export$d73a2e87a509880 = function(message) {\n    return \"id\" in message && \"error\" in message;\n};\nconst $7c0fb93e8eea922a$export$81276773828ff315 = function(message) {\n    return \"id\" in message && \"result\" in message;\n};\nconst $7c0fb93e8eea922a$export$280de919a0cf6928 = function(message) {\n    return !(\"id\" in message) && \"method\" in message;\n};\nconst $7c0fb93e8eea922a$export$94e3360fcddccc76 = function(message) {\n    return \"id\" in message && \"method\" in message;\n};\n\n\n\n/**\n * Triggers when the underlying connection is established.\n *\n * @event ElectrumClient#connected\n */ /**\n * Triggers when the underlying connection is lost.\n *\n * @event ElectrumClient#disconnected\n */ /**\n * Triggers when the remote server sends data that is not a request response.\n *\n * @event ElectrumClient#notification\n */ /**\n * High-level Electrum client that lets applications send requests and subscribe to notification events from a server.\n */ class $620a18299ef8d6fd$var$ElectrumClient extends (0, $4QiMX$EventEmitter) {\n    /**\n\t * Initializes an Electrum client.\n\t *\n\t * @param {string} application            your application name, used to identify to the electrum host.\n\t * @param {string} version                protocol version to use with the host.\n\t * @param {string} host                   fully qualified domain name or IP number of the host.\n\t * @param {number} port                   the TCP network port of the host.\n\t * @param {TransportScheme} scheme        the transport scheme to use for connection\n\t * @param {number} timeout                how long network delays we will wait for before taking action, in milliseconds.\n\t * @param {number} pingInterval           the time between sending pings to the electrum host, in milliseconds.\n\t * @param {number} reconnectInterval      the time between reconnection attempts to the electrum host, in milliseconds.\n\t * @param {boolean} useBigInt\t\t\t  whether to use bigint for numbers in json response.\n\t *\n\t * @throws {Error} if `version` is not a valid version string.\n\t */ constructor(application, version, host, port = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).PORT, scheme = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).TRANSPORT_SCHEME, timeout = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).TIMEOUT, pingInterval = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).PING_INTERVAL, reconnectInterval = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).RECONNECT, useBigInt = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).USE_BIG_INT){\n        // Initialize the event emitter.\n        super();\n        // Initialize an empty list of subscription metadata.\n        this.subscriptionMethods = {};\n        // Start counting the request IDs from 0\n        this.requestId = 0;\n        // Initialize an empty dictionary for keeping track of request resolvers\n        this.requestResolvers = {};\n        // Mutex lock used to prevent simultaneous connect() and disconnect() calls.\n        this.connectionLock = new (0, $4QiMX$Mutex)();\n        // Set up a connection to an electrum server.\n        this.connection = new (0, $1326c18f93f95fee$export$2e2bcd8739ae039)(application, version, host, port, scheme, timeout, pingInterval, reconnectInterval, useBigInt);\n    }\n    /**\n\t * Connects to the remote server.\n\t *\n\t * @throws {Error} if the socket connection fails.\n\t * @returns a promise resolving when the connection is established.\n\t */ async connect() {\n        // Create a lock so that multiple connects/disconnects cannot race each other.\n        const unlock = await this.connectionLock.acquire();\n        try {\n            // If we are already connected, do not attempt to connect again.\n            if (this.connection.status === (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED) return;\n            // Listen for parsed statements.\n            this.connection.on(\"statement\", this.response.bind(this));\n            // Hook up resubscription on connection.\n            this.connection.on(\"connect\", this.resubscribeOnConnect.bind(this));\n            // Relay connect and disconnect events.\n            this.connection.on(\"connect\", this.emit.bind(this, \"connected\"));\n            this.connection.on(\"disconnect\", this.onConnectionDisconnect.bind(this));\n            // Relay error events.\n            this.connection.on(\"error\", this.emit.bind(this, \"error\"));\n            // Connect with the server.\n            await this.connection.connect();\n        } finally{\n            unlock();\n        }\n    }\n    /**\n\t * Disconnects from the remote server and removes all event listeners/subscriptions and open requests.\n\t *\n\t * @param {boolean} force                 disconnect even if the connection has not been fully established yet.\n\t * @param {boolean} retainSubscriptions   retain subscription data so they will be restored on reconnection.\n\t *\n\t * @returns true if successfully disconnected, or false if there was no connection.\n\t */ async disconnect(force = false, retainSubscriptions = false) {\n        // Create a lock so that multiple connects/disconnects cannot race each other.\n        const unlock = await this.connectionLock.acquire();\n        try {\n            if (!retainSubscriptions) {\n                // Cancel all event listeners.\n                this.removeAllListeners();\n                // Remove all subscription data\n                this.subscriptionMethods = {};\n            }\n            // For each pending request..\n            for(const index in this.requestResolvers){\n                // Reject the request.\n                const requestResolver = this.requestResolvers[index];\n                requestResolver(new Error(\"Manual disconnection\"));\n                // Remove the request.\n                delete this.requestResolvers[index];\n            }\n            // Disconnect from the remove server.\n            return await this.connection.disconnect(force);\n        } finally{\n            unlock();\n        }\n    }\n    /**\n\t * Calls a method on the remote server with the supplied parameters.\n\t *\n\t * @param {string} method          name of the method to call.\n\t * @param {...string} parameters   one or more parameters for the method.\n\t *\n\t * @throws {Error} if the client is disconnected.\n\t * @returns a promise that resolves with the result of the method or an Error.\n\t */ async request(method, ...parameters) {\n        // If we are not connected to a server..\n        if (this.connection.status !== (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED) // Reject the request with a disconnected error message.\n        throw new Error(`Unable to send request to a disconnected server '${this.connection.host}'.`);\n        // Increase the request ID by one.\n        this.requestId += 1;\n        // Store a copy of the request id.\n        const id = this.requestId;\n        // Format the arguments as an electrum request object.\n        const message = (0, $c78f59d21170b7a6$export$2e2bcd8739ae039).buildRequestObject(method, parameters, id);\n        // Define a function to wrap the request in a promise.\n        const requestResolver = (resolve)=>{\n            // Add a request resolver for this promise to the list of requests.\n            this.requestResolvers[id] = (error, data)=>{\n                // If the resolution failed..\n                if (error) // Resolve the promise with the error for the application to handle.\n                resolve(error);\n                else // Resolve the promise with the request results.\n                resolve(data);\n            };\n            // Send the request message to the remote server.\n            this.connection.send(message);\n        };\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Sending request '${method}' to '${this.connection.host}'`);\n        // return a promise to deliver results later.\n        return new Promise(requestResolver);\n    }\n    /**\n\t * Subscribes to the method and payload at the server.\n\t *\n\t * @note the response for the subscription request is issued as a notification event.\n\t *\n\t * @param {string}    method       one of the subscribable methods the server supports.\n\t * @param {...string} parameters   one or more parameters for the method.\n\t *\n\t * @throws {Error} if the client is disconnected.\n\t * @returns a promise resolving when the subscription is established.\n\t */ async subscribe(method, ...parameters) {\n        // Initialize an empty list of subscription payloads, if needed.\n        if (!this.subscriptionMethods[method]) this.subscriptionMethods[method] = new Set();\n        // Store the subscription parameters to track what data we have subscribed to.\n        this.subscriptionMethods[method].add(JSON.stringify(parameters));\n        // Send initial subscription request.\n        const requestData = await this.request(method, ...parameters);\n        // Construct a notification structure to package the initial result as a notification.\n        const notification = {\n            jsonrpc: \"2.0\",\n            method: method,\n            params: [\n                ...parameters,\n                requestData\n            ]\n        };\n        // Manually emit an event for the initial response.\n        this.emit(\"notification\", notification);\n    }\n    /**\n\t * Unsubscribes to the method at the server and removes any callback functions\n\t * when there are no more subscriptions for the method.\n\t *\n\t * @param {string}    method       a previously subscribed to method.\n\t * @param {...string} parameters   one or more parameters for the method.\n\t *\n\t * @throws {Error} if no subscriptions exist for the combination of the provided `method` and `parameters.\n\t * @throws {Error} if the client is disconnected.\n\t * @returns a promise resolving when the subscription is removed.\n\t */ async unsubscribe(method, ...parameters) {\n        // Throw an error if the client is disconnected.\n        if (this.connection.status !== (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED) throw new Error(`Unable to send unsubscribe request to a disconnected server '${this.connection.host}'.`);\n        // If this method has no subscriptions..\n        if (!this.subscriptionMethods[method]) // Reject this promise with an explanation.\n        throw new Error(`Cannot unsubscribe from '${method}' since the method has no subscriptions.`);\n        // Pack up the parameters as a long string.\n        const subscriptionParameters = JSON.stringify(parameters);\n        // If the method payload could not be located..\n        if (!this.subscriptionMethods[method].has(subscriptionParameters)) // Reject this promise with an explanation.\n        throw new Error(`Cannot unsubscribe from '${method}' since it has no subscription with the given parameters.`);\n        // Remove this specific subscription payload from internal tracking.\n        this.subscriptionMethods[method].delete(subscriptionParameters);\n        // Send unsubscription request to the server\n        // NOTE: As a convenience we allow users to define the method as the subscribe or unsubscribe version.\n        await this.request(method.replace(\".subscribe\", \".unsubscribe\"), ...parameters);\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).client(`Unsubscribed from '${String(method)}' for the '${subscriptionParameters}' parameters.`);\n    }\n    /**\n\t * Restores existing subscriptions without updating status or triggering manual callbacks.\n\t *\n\t * @throws {Error} if subscription data cannot be found for all stored event names.\n\t * @throws {Error} if the client is disconnected.\n\t * @returns a promise resolving to true when the subscriptions are restored.\n\t *\n\t * @ignore\n\t */ async resubscribeOnConnect() {\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).client(`Connected to '${this.connection.hostIdentifier}'.`);\n        // Initialize an empty list of resubscription promises.\n        const resubscriptionPromises = [];\n        // For each method we have a subscription for..\n        for(const method in this.subscriptionMethods){\n            // .. and for each parameter we have previously been subscribed to..\n            for (const parameterJSON of this.subscriptionMethods[method].values()){\n                // restore the parameters from JSON.\n                const parameters = JSON.parse(parameterJSON);\n                // Send a subscription request.\n                resubscriptionPromises.push(this.subscribe(method, ...parameters));\n            }\n            // Wait for all re-subscriptions to complete.\n            await Promise.all(resubscriptionPromises);\n        }\n        // Write a log message if there was any subscriptions to restore.\n        if (resubscriptionPromises.length > 0) (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).client(`Restored ${resubscriptionPromises.length} previous subscriptions for '${this.connection.hostIdentifier}'`);\n    }\n    /**\n\t * Parser messages from the remote server to resolve request promises and emit subscription events.\n\t *\n\t * @param {RPCNotification | RPCResponse} message   the response message\n\t *\n\t * @throws {Error} if the message ID does not match an existing request.\n\t * @ignore\n\t */ response(message) {\n        // If the received message is a notification, we forward it to all event listeners\n        if ((0, $7c0fb93e8eea922a$export$280de919a0cf6928)(message)) {\n            // Write a log message.\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).client(`Received notification for '${message.method}' from '${this.connection.host}'`);\n            // Forward the message content to all event listeners.\n            this.emit(\"notification\", message);\n            // Return since it does not have an associated request resolver\n            return;\n        }\n        // If the response ID is null we cannot use it to index our request resolvers\n        if (message.id === null) // Throw an internal error, this should not happen.\n        throw new Error(\"Internal error: Received an RPC response with ID null.\");\n        // Look up which request promise we should resolve this.\n        const requestResolver = this.requestResolvers[message.id];\n        // If we do not have a request resolver for this response message..\n        if (!requestResolver) // Throw an internal error, this should not happen.\n        throw new Error(\"Internal error: Callback for response not available.\");\n        // Remove the promise from the request list.\n        delete this.requestResolvers[message.id];\n        // If the message contains an error..\n        if ((0, $7c0fb93e8eea922a$export$d73a2e87a509880)(message)) // Forward the message error to the request resolver and omit the `result` parameter.\n        requestResolver(new Error(message.error.message));\n        else // Forward the message content to the request resolver and omit the `error` parameter\n        // (by setting it to undefined).\n        requestResolver(undefined, message.result);\n    }\n    /**\n\t * Callback function that is called when connection to the Electrum server is lost.\n\t * Aborts all active requests with an error message indicating that connection was lost.\n\t *\n\t * @ignore\n\t */ onConnectionDisconnect() {\n        // Emit a disconnection signal to any listeners.\n        this.emit(\"disconnected\");\n        // Loop over active requests\n        for(const resolverId in this.requestResolvers){\n            // Extract request resolver for readability\n            const requestResolver = this.requestResolvers[resolverId];\n            // Resolve the active request with an error indicating that the connection was lost.\n            requestResolver(new Error(\"Connection lost\"));\n            // Remove the promise from the request list.\n            delete this.requestResolvers[resolverId];\n        }\n    }\n}\nvar // Export the client.\n$620a18299ef8d6fd$export$2e2bcd8739ae039 = $620a18299ef8d6fd$var$ElectrumClient;\n\n\n\n\n\n\n\n\n\n/**\n * Triggers when the cluster connects to enough servers to satisfy both the cluster confidence and distribution policies.\n *\n * @event ElectrumCluster#ready\n * @deprecated\n */ /**\n * Triggers when the cluster loses a connection and can no longer satisfy the cluster distribution policy.\n *\n * @event ElectrumCluster#degraded\n * @deprecated\n */ /**\n * Triggers when the cluster loses a connection and can no longer satisfy the cluster confidence policy.\n *\n * @event ElectrumCluster#disabled\n * @deprecated\n */ /**\n * Triggers when the cluster verifies the integrity of remote server sent data that is not a request responses.\n *\n * @event ElectrumCluster#notification\n * @deprecated\n */ /**\n * High-level electrum client that provides transparent load balancing, confidence checking and/or low-latency polling.\n * @deprecated\n */ class $9b2ed2eb52532075$var$ElectrumCluster extends (0, $4QiMX$EventEmitter) {\n    /**\n\t * @param {string} application    your application name, used to identify to the electrum hosts.\n\t * @param {string} version        protocol version to use with the hosts.\n\t * @param {number} confidence     wait for this number of hosts to provide identical results.\n\t * @param {number} distribution   request information from this number of hosts.\n\t * @param {ClusterOrder} order    select hosts to communicate with in this order.\n\t * @param {number} timeout        how long network delays we will wait for before taking action, in milliseconds.\n\t * @param {number} pingInterval      the time between sending pings to the electrum host, in milliseconds.\n\t * @param {number} reconnectInterval the time between reconnection attempts to the electrum host, in milliseconds.\n\t * @param {boolean} useBigInt\t  whether to use bigint for numbers in json response.\n\t */ constructor(application, version, confidence = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).CLUSTER_CONFIDENCE, distribution = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).CLUSTER_DISTRIBUTION, order = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).CLUSTER_ORDER, timeout = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).TIMEOUT, pingInterval = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).PING_INTERVAL, reconnectInterval = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).RECONNECT, useBigInt = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).USE_BIG_INT){\n        // Initialize the event emitter.\n        super();\n        this.application = application;\n        this.version = version;\n        this.confidence = confidence;\n        this.distribution = distribution;\n        this.order = order;\n        this.timeout = timeout;\n        this.pingInterval = pingInterval;\n        this.reconnectInterval = reconnectInterval;\n        this.useBigInt = useBigInt;\n        this.// Initialize an empty dictionary of clients in the cluster\n        clients = {};\n        this.// Start at 0 connected clients\n        connections = 0;\n        this.// Set up an empty set of notification data.\n        notifications = {};\n        this.// Start the cluster in DISABLED state\n        status = (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DISABLED;\n        this.// Start counting request IDs at 0\n        requestCounter = 0;\n        this.// Initialize an empty dictionary for keeping track of request resolvers\n        requestPromises = {};\n        this.// Lock to prevent concurrency race conditions when sending requests.\n        requestLock = new (0, $4QiMX$Mutex)();\n        this.// Lock to prevent concurrency race conditions when receiving responses.\n        responseLock = new (0, $4QiMX$Mutex)();\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Initialized empty cluster (${confidence} of ${distribution || \"ALL\"})`);\n        // Print out a warning if we cannot guarantee consensus for subscription notifications.\n        // Case 1: we don't know how many servers will be used, so warning just to be safe\n        // Case 2: we know the number of servers needed to trust a response is less than 50%.\n        if (distribution === (0, $a58372b18a18806e$export$436a960acc41e848).ALL || confidence / distribution <= 0.50) (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).warning(`Subscriptions might return multiple valid responses when confidence (${confidence}) is less than 51% of distribution.`);\n    }\n    /**\n\t * Adds a server to the cluster.\n\t * @deprecated\n\t *\n\t * @param {string} host              fully qualified domain name or IP number of the host.\n\t * @param {number} port              the TCP network port of the host.\n\t * @param {TransportScheme} scheme   the transport scheme to use for connection\n\t * @param {boolean} autoConnect      flag indicating whether the server should automatically connect (default true)\n\t *\n\t * @throws {Error} if the cluster's version is not a valid version string.\n\t * @returns a promise that resolves when the connection has been initiated.\n\t */ async addServer(host, port = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).PORT, scheme = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).TRANSPORT_SCHEME, autoConnect = true) {\n        // Set up a new electrum client.\n        const client = new (0, $620a18299ef8d6fd$export$2e2bcd8739ae039)(this.application, this.version, host, port, scheme, this.timeout, this.pingInterval, this.reconnectInterval, this.useBigInt);\n        // Define the client identity to avoid repetition.\n        const clientIdentity = `${host}:${port}`;\n        // Store this client.\n        this.clients[clientIdentity] = {\n            state: (0, $a58372b18a18806e$export$c4f81c6d30ca200f).UNAVAILABLE,\n            connection: client\n        };\n        /**\n\t\t * Define a helper function to evaluate and log cluster status.\n\t\t *\n\t\t * @fires ElectrumCluster#ready\n\t\t * @fires ElectrumCluster#degraded\n\t\t * @fires ElectrumCluster#disabled\n\t\t */ const updateClusterStatus = ()=>{\n            // Calculate the required distribution, taking into account that distribution to all is represented with 0.\n            const distribution = Math.max(this.confidence, this.distribution);\n            // Check if we have enough connections to saturate distribution.\n            if (this.connections >= distribution) // If the cluster is not currently considered ready..\n            {\n                if (this.status !== (0, $a58372b18a18806e$export$c66b56bc0ff967ca).READY) {\n                    // Mark the cluster as ready.\n                    this.status = (0, $a58372b18a18806e$export$c66b56bc0ff967ca).READY;\n                    // Emit the ready signal to indicate the cluster is running in a ready mode.\n                    this.emit(\"ready\");\n                    // Write a log message with an update on the current cluster status.\n                    (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Cluster status is ready (currently ${this.connections} of ${distribution} connections available.)`);\n                }\n            } else if (this.connections >= this.confidence) // If the cluster is not currently considered degraded..\n            {\n                if (this.status !== (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DEGRADED) {\n                    // Mark the cluster as degraded.\n                    this.status = (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DEGRADED;\n                    // Emit the degraded signal to indicate the cluster is running in a degraded mode.\n                    this.emit(\"degraded\");\n                    // Write a log message with an update on the current cluster status.\n                    (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Cluster status is degraded (only ${this.connections} of ${distribution} connections available.)`);\n                }\n            } else if (this.status !== (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DISABLED) {\n                // Mark the cluster as disabled.\n                this.status = (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DISABLED;\n                // Emit the degraded signal to indicate the cluster is disabled.\n                this.emit(\"disabled\");\n                // Write a log message with an update on the current cluster status.\n                (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Cluster status is disabled (only ${this.connections} of the ${distribution} connections are available.)`);\n            }\n        };\n        // Define a function to run when client has connected.\n        const onConnect = async ()=>{\n            // Wrap in a try-catch so we can ignore errors.\n            try {\n                // Check connection status\n                const connectionStatus = client.connection.status;\n                // If the connection is fine..\n                if (connectionStatus === (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED) {\n                    // If this was from an unavailable connection..\n                    if (this.clients[clientIdentity].state === (0, $a58372b18a18806e$export$c4f81c6d30ca200f).UNAVAILABLE) // Update connection counter.\n                    this.connections += 1;\n                    // Set client state to available.\n                    this.clients[clientIdentity].state = (0, $a58372b18a18806e$export$c4f81c6d30ca200f).AVAILABLE;\n                    // update the cluster status.\n                    updateClusterStatus();\n                }\n            } catch (error) {\n            // Do nothing.\n            }\n        };\n        // Define a function to run when client disconnects.\n        const onDisconnect = ()=>{\n            // If this was from an established connection..\n            if (this.clients[clientIdentity].state === (0, $a58372b18a18806e$export$c4f81c6d30ca200f).AVAILABLE) // Update connection counter.\n            this.connections -= 1;\n            // Set client state to unavailable.\n            this.clients[clientIdentity].state = (0, $a58372b18a18806e$export$c4f81c6d30ca200f).UNAVAILABLE;\n            // update the cluster status.\n            updateClusterStatus();\n        };\n        // Set up handlers for connection and disconnection.\n        client.connection.on(\"connect\", onConnect.bind(this));\n        client.connection.on(\"disconnect\", onDisconnect.bind(this));\n        // Set up handler for notification events, that includes the identity of this client so it can be tracked.\n        client.on(\"notification\", this.handleSubscriptionNotifications.bind(this, clientIdentity));\n        // Connect if auto-connect is set to true, returning the connection result.\n        if (autoConnect) try {\n            // Set up the connection.\n            await client.connect();\n        } catch (error) {\n            // Log a message why the connection failed and move on.\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Failed to connect with ${host}: ${error}`);\n        }\n    }\n    /**\n\t * Calls a method on the remote server with the supplied parameters.\n\t * @deprecated\n\t *\n\t * @param {string}    method       name of the method to call.\n\t * @param {...string} parameters   one or more parameters for the method.\n\t *\n\t * @throws {Error} if not enough clients are connected\n\t * @throws {Error} if no response is received with sufficient integrity\n\t * @returns a promise that resolves with the result of the method.\n\t */ async request(method, ...parameters) {\n        // Check if the cluster is unable to serve requests.\n        if (this.status === (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DISABLED) throw new Error(`Cannot request '${method}' when available clients (${this.connections}) is less than required confidence (${this.confidence}).`);\n        // Lock this request method temporarily.\n        const unlock = await this.requestLock.acquire();\n        // Declare requestId outside of try-catch scope.\n        let requestId = 0;\n        // NOTE: If this async method is called very rapidly, it's theoretically possible that the parts below could interfere.\n        try {\n            // Increase the current request counter.\n            this.requestCounter += 1;\n            // Copy the request counter so we can work with the copy and know it won't change\n            // even if the request counter is raised from concurrent requests.\n            requestId = this.requestCounter;\n        } finally{\n            // Unlock this request method now that the concurrency sensitive condition is completed.\n            unlock();\n        }\n        // Initialize an empty list of request promises.\n        this.requestPromises[requestId] = [];\n        // Extract all available client IDs\n        const availableClientIDs = Object.keys(this.clients).filter((clientID)=>this.clients[clientID].state === (0, $a58372b18a18806e$export$c4f81c6d30ca200f).AVAILABLE);\n        // Initialize a sent counter.\n        let sentCounter = 0;\n        // Determine the number of clients we need to send to, taking ClusterDistribution.ALL (=0) into account.\n        let requiredDistribution = this.distribution || availableClientIDs.length;\n        // If the cluster is in degraded status, we do not have enough available clients to\n        // match distribution, but still enough to reach consensus, so we use the clients we have.\n        if (this.status === (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DEGRADED) requiredDistribution = availableClientIDs.length;\n        // Repeat until we have sent the request to the desired number of clients.\n        while(sentCounter < requiredDistribution){\n            // Pick an array index according to our ordering strategy.\n            let currentIndex = 0;\n            // Use a random array index when cluster order is set to RANDOM\n            if (this.order === (0, $a58372b18a18806e$export$161fe3707f756bf9).RANDOM) currentIndex = Math.floor(Math.random() * availableClientIDs.length);\n            // Move a client identity from the client list to its own variable.\n            const [currentClient] = availableClientIDs.splice(currentIndex, 1);\n            // Send the request to the client and store the request promise.\n            const requestPromise = this.clients[currentClient].connection.request(method, ...parameters);\n            this.requestPromises[requestId].push(requestPromise);\n            // Increase the sent counter.\n            sentCounter += 1;\n        }\n        // Define a function to poll for request responses.\n        const pollResponse = (resolve, reject)=>{\n            // Define a function to resolve request responses based on integrity.\n            const resolveRequest = async ()=>{\n                // Set up an empty set of response data.\n                const responseData = {};\n                // Set up a counter to keep track of how many responses we have checked.\n                let checkedResponses = 0;\n                // For each server we issued a request to..\n                for(const currentPromise in this.requestPromises[requestId]){\n                    // Initialize a holder for the response in the required scope to use it.\n                    let response;\n                    // Race the request promise against a pre-resolved request to determine request status.\n                    try {\n                        // Arrange an array of the current promise and an empty promise such that..\n                        const promises = [\n                            this.requestPromises[requestId][currentPromise],\n                            Promise.resolve(undefined)\n                        ];\n                        // .. we can get the result of the current promise if it is currently resolved, but don't need to wait for it otherwise.\n                        response = await Promise.race(promises);\n                    } // Handle case where the request sent resulted in a thrown error / promise rejection, rather then resolving to a response.\n                    // Note that in the worst time case, each request can be expected to  eventually throw an error on timeout.\n                    catch (error) {\n                        // Increase the counter for checked responses.\n                        checkedResponses += 1;\n                        continue;\n                    }\n                    // If the promise is settled..\n                    if (response !== undefined) {\n                        // Calculate a unique identifier for this notification data.\n                        const responseDataIdentifier = (0, $4QiMX$stringify)(response);\n                        // Increase the counter for checked responses.\n                        checkedResponses += 1;\n                        // Either set the response data counter or increase it.\n                        if (responseData[responseDataIdentifier] === undefined) responseData[responseDataIdentifier] = 1;\n                        else responseData[responseDataIdentifier] += 1;\n                        // Check if this response has enough integrity according to our confidence strategy.\n                        if (responseData[responseDataIdentifier] === this.confidence) {\n                            // Write log entry.\n                            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Validated response for '${method}' with sufficient integrity (${this.confidence}).`);\n                            // Resolve the request with this response.\n                            resolve(response);\n                            // Return after resolving since we do not want to continue the execution.\n                            return;\n                        }\n                    }\n                }\n                // If all clients have responded but we failed to reach desired integrity..\n                if (checkedResponses === this.requestPromises[requestId].length) {\n                    // Reject this request with an error message.\n                    reject(new Error(`Unable to complete request for '${method}', response failed to reach sufficient integrity (${this.confidence}).`));\n                    // Return after rejecting since we do not want to continue the execution.\n                    return;\n                }\n                // If we are not ready, but have not timed out and should wait more..\n                setTimeout(resolveRequest, 1000);\n            };\n            // Attempt the initial resolution of the request.\n            resolveRequest();\n        };\n        // return some kind of promise that resolves when integrity number of clients results match.\n        return new Promise(pollResponse);\n    }\n    /**\n\t * Subscribes to the method at the cluster and attaches the callback function to the event feed.\n\t * @deprecated\n\t *\n\t * @note the response for the subscription request is issued as a notification event.\n\t *\n\t * @param {string}    method       one of the subscribable methods the server supports.\n\t * @param {...string} parameters   one or more parameters for the method.\n\t *\n\t * @throws {Error} if not enough clients are connected\n\t * @throws {Error} if no response is received with sufficient integrity for the initial request\n\t */ async subscribe(method, ...parameters) {\n        // Set up event listener for this subscription.\n        for(const currentClient in this.clients){\n            // Copy the current client for brevity.\n            const client = this.clients[currentClient].connection;\n            try {\n                // Send initial subscription request.\n                // NOTE: This stores and manages the subscription even if the initial request fails.\n                await client.subscribe(method, ...parameters);\n            } catch (error) {\n            // Do nothing, as this is handled on a best-effort basis and\n            // not all servers are expected to be ready at all times.\n            }\n        }\n    }\n    /**\n\t * Unsubscribes to the method at the cluster and removes any callback functions\n\t * when there are no more subscriptions for the method.\n\t * @deprecated\n\t *\n\t * @param {string}    method       one of the subscribable methods the server supports.\n\t * @param {...string} parameters   one or more parameters for the method.\n\t *\n\t * @throws {Error} if, for any of the clients, no subscriptions exist for the combination of the provided `method` and `parameters.\n\t */ async unsubscribe(method, ...parameters) {\n        // Initialize an empty list to track subscription requests.\n        const unsubscriptionPromises = [];\n        // For each client..\n        for(const currentClient in this.clients){\n            // Store client in variable for brevity\n            const client = this.clients[currentClient].connection;\n            // unsubscribe this client.\n            unsubscriptionPromises.push(client.unsubscribe(method, ...parameters));\n        }\n        // Wait for all unsubscription promises to resolve.\n        await Promise.all(unsubscriptionPromises);\n    }\n    /**\n\t * Define a callback function to validate server notifications and pass them to the subscribe callback.\n\t * @deprecated\n\t *\n\t * @ignore\n\t */ async handleSubscriptionNotifications(clientIdentity, data) {\n        // Lock this response method temporarily.\n        const unlock = await this.responseLock.acquire();\n        try {\n            // Calculate a unique identifier for this notification data.\n            const responseDataIdentifier = (0, $4QiMX$stringify)(data);\n            // Create an empty list of clients who have responded to this notification, if necessary.\n            if (this.notifications[responseDataIdentifier] === undefined) this.notifications[responseDataIdentifier] = new Set();\n            // Ensure this client is on the list of clients that have provided this specific notification.\n            this.notifications[responseDataIdentifier].add(clientIdentity);\n            // Check if this notification has enough integrity according to our confidence strategy.\n            // NOTE: We check against === instead of >== in order to ensure that we only emit each notification once.\n            if (this.notifications[responseDataIdentifier].size === this.confidence) {\n                // Write log entry.\n                (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Validated notification for '${data.method}' with sufficient integrity (${this.confidence}).`);\n                // Emit an event for the notification data.\n                this.emit(\"notification\", data);\n                // Dismiss the notification data after all nodes are assumed to have sent their notifications.\n                // NOTE: This is a redundant mechanic to ensure that even if some nodes don't provide this notification, we still clear this data.\n                // NOTE: This also introduces a race-condition where if a legit identical notification comes in before/during this timeout, it might get silenced.\n                setTimeout(this.dismissSubscriptionNotification.bind(this, responseDataIdentifier), this.timeout);\n            }\n            // Check if this notification has been fully handled.\n            if (this.notifications[responseDataIdentifier].size === this.distribution) // Dismiss existing response data as we know all related parties have provided their input.\n            this.dismissSubscriptionNotification(responseDataIdentifier);\n        } finally{\n            // Unlock the response method so it can handle the next set of data.\n            unlock();\n        }\n    }\n    /**\n\t * Forgets/Removes notification data for a specific notification.\n\t *\n\t * This is required in order to allow future identical notifications to be properly processed and emitted.\n\t * @deprecated\n\t */ async dismissSubscriptionNotification(responseDataIdentifier) {\n        delete this.notifications[responseDataIdentifier];\n    }\n    /**\n\t * Provides a method to check or wait for the cluster to become ready.\n\t * @deprecated\n\t *\n\t * @returns a promise that resolves when the required servers are available.\n\t */ async ready() {\n        // Store the current timestamp.\n        const readyTimestamp = Date.now();\n        // Define a function to poll for availability of the cluster.\n        const availabilityPoller = (resolve)=>{\n            // Define a function to check if the cluster is ready to be used.\n            const connectionAvailabilityVerifier = ()=>{\n                // Check if the cluster is active..\n                if (this.status === (0, $a58372b18a18806e$export$c66b56bc0ff967ca).READY) {\n                    // Resolve with true to indicate that the cluster is ready to use.\n                    resolve(true);\n                    // Return after resolving since we do not want to continue the execution.\n                    return;\n                }\n                // Calculate how long we have waited, in milliseconds.\n                const timeWaited = Date.now() - readyTimestamp;\n                // Check if we have waited longer than our timeout setting.\n                if (timeWaited > this.timeout) {\n                    // Resolve with false to indicate that we did not get ready in time.\n                    resolve(false);\n                    // Return after resolving since we do not want to continue the execution.\n                    return;\n                }\n                // If we are not ready, but have not timed out and should wait more..\n                setTimeout(connectionAvailabilityVerifier, 50);\n            };\n            // Run the initial verification.\n            connectionAvailabilityVerifier();\n        };\n        // Return a promise that resolves when the available clients is sufficient.\n        return new Promise(availabilityPoller);\n    }\n    /**\n\t * Connects all servers from the cluster and attaches event listeners and handlers\n\t * for all underlying clients and connections.\n\t * @deprecated\n\t *\n\t * @throws {Error} if the cluster's version is not a valid version string.\n\t */ async startup() {\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(\"Starting up cluster.\");\n        // Keep track of all connections\n        const connections = [];\n        // Loop over all clients and reconnect them if they're disconnected\n        for(const clientKey in this.clients){\n            // Retrieve connection information for the client\n            const { host: host, port: port, scheme: scheme } = this.clients[clientKey].connection.connection;\n            // Only connect currently unavailable/disconnected clients\n            if (this.clients[clientKey].state === (0, $a58372b18a18806e$export$c4f81c6d30ca200f).AVAILABLE) // Warn when a server is already connected when calling startup()\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).warning(`Called startup(), but server ${host}:${port} is already connected`);\n            else // Call the addServer() function with the existing connection data\n            // This effectively reconnects the server and re-instates all event listeners\n            connections.push(this.addServer(host, port, scheme));\n        }\n        // Await all connections\n        return Promise.all(connections);\n    }\n    /**\n\t * Disconnects all servers from the cluster. Removes all event listeners and\n\t * handlers from all underlying clients and connections. This includes all\n\t * active subscriptions, unless retainSubscriptions is set to true.\n\t * @deprecated\n\t *\n\t * @param {boolean} retainSubscriptions   retain subscription data so they will be restored on reconnection.\n\t *\n\t * @returns a list with the disconnection result for every client\n\t */ async shutdown(retainSubscriptions = false) {\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(\"Shutting down cluster.\");\n        // Set up a list of disconnections to wait for.\n        const disconnections = [];\n        const disconnectResolver = (resolve)=>{\n            // Resolve once the cluster is marked as disabled\n            this.once(\"disabled\", ()=>resolve(Promise.all(disconnections)));\n            // For each client in this cluster..\n            for(const clientIndex in this.clients)// Force disconnection regardless of current status.\n            disconnections.push(this.clients[clientIndex].connection.disconnect(true, retainSubscriptions));\n        };\n        // Return a list of booleans indicating disconnections from all clients\n        return new Promise(disconnectResolver);\n    }\n}\nvar // Export the cluster.\n$9b2ed2eb52532075$export$2e2bcd8739ae039 = $9b2ed2eb52532075$var$ElectrumCluster;\n\n\n\n\n\n\n\nexport {$620a18299ef8d6fd$export$2e2bcd8739ae039 as ElectrumClient, $9b2ed2eb52532075$export$2e2bcd8739ae039 as ElectrumCluster, $a192ea5a4eec42d4$export$e1f38ab2b4ebdde6 as isVersionRejected, $a192ea5a4eec42d4$export$9598f0c76aa41d73 as isVersionNegotiated, $5abc8fb342687c03$export$d048df559e6d3842 as ElectrumTransport, $5abc8fb342687c03$export$f019be48b3aacb1a as DefaultParameters, $a58372b18a18806e$export$161fe3707f756bf9 as ClusterOrder, $a58372b18a18806e$export$436a960acc41e848 as ClusterDistribution, $a58372b18a18806e$export$c66b56bc0ff967ca as ClusterStatus, $a58372b18a18806e$export$c4f81c6d30ca200f as ClientState, $a58372b18a18806e$export$7516420eb880ab68 as ConnectionStatus};\n//# sourceMappingURL=index.mjs.map\n"],"names":["isInteger","value","INTEGER_REGEX","isNumber","NUMBER_REGEX","isSafeNumber","config","num","str","v","extractSignificantDigits","requiredDigits","UnsafeNumberReason","getUnsafeNumberReason","EXPONENTIAL_PART_REGEX","DOT_REGEX","TRAILING_ZEROS_REGEX","LEADING_MINUS_AND_ZEROS_REGEX","_typeof","obj","_classCallCheck","instance","Constructor","_defineProperties","target","props","i","descriptor","_toPropertyKey","_createClass","protoProps","staticProps","_defineProperty","key","arg","_toPrimitive","input","hint","prim","res","LosslessNumber","unsafeReason","isLosslessNumber","parseLosslessNumber","parseNumberAndBigInt","revive","json","reviver","reviveValue","context","reviveArray","reviveObject","object","array","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","o","minLen","_arrayLikeToArray","iter","len","arr2","parse","text","parseNumber","parseValue","expectValue","expectEndOfInput","parseObject","codeOpeningBrace","skipWhitespace","initial","codeClosingBrace","eatComma","start","parseString","throwObjectKeyExpected","eatColon","_value","throwObjectValueExpected","isDeepEqual","throwDuplicateKey","throwObjectKeyOrEndExpected","parseArray","codeOpeningBracket","codeClosingBracket","_value2","expectArrayItem","throwArrayItemOrEndExpected","_ref","_ref2","_ref3","_ref4","_ref5","_parseString","parseNumeric","parseKeyword","name","isWhitespace","codeDoubleQuote","result","codeBackslash","char","escapeChar","escapeCharacters","isHex","throwInvalidUnicodeCharacter","throwInvalidEscapeCharacter","isValidStringCharacter","throwInvalidCharacter","expectEndOfString","codeMinus","expectDigit","codeZero","isNonZeroDigit","isDigit","codeDot","codeLowercaseE","codeUppercaseE","codePlus","codeComma","gotAt","codeColon","numSoFar","pos","chars","end","got","code","codeSpace","codeNewline","codeTab","codeReturn","codeNine","codeUppercaseA","codeUppercaseF","codeLowercaseA","codeLowercaseF","codeOne","a","b","item","index","isObject","keys","$parcel$export","n","s","$ef5ba40c8abe5a13$var$debug","$4QiMX$debug","$ef5ba40c8abe5a13$export$2e2bcd8739ae039","$c78f59d21170b7a6$var$ElectrumProtocol","method","parameters","requestId","$c78f59d21170b7a6$export$2e2bcd8739ae039","$a192ea5a4eec42d4$exports","$a192ea5a4eec42d4$export$e1f38ab2b4ebdde6","$a192ea5a4eec42d4$export$9598f0c76aa41d73","$5abc8fb342687c03$exports","$5abc8fb342687c03$export$d048df559e6d3842","$5abc8fb342687c03$export$f019be48b3aacb1a","$a58372b18a18806e$exports","$a58372b18a18806e$export$161fe3707f756bf9","$a58372b18a18806e$export$436a960acc41e848","$a58372b18a18806e$export$c66b56bc0ff967ca","$a58372b18a18806e$export$c4f81c6d30ca200f","$a58372b18a18806e$export$7516420eb880ab68","ClusterOrder","ClusterDistribution","ClusterStatus","ClientState","ConnectionStatus","$ea64e414b68fe23b$var$ElectrumSocket","$4QiMX$EventEmitter","host","port","scheme","timeout","socketTypes","connectionOptions","$4QiMX$WebSocket","connectionType","data","callback","timeoutError","args","event","err","$ea64e414b68fe23b$export$2e2bcd8739ae039","$1326c18f93f95fee$var$ElectrumConnection","application","version","pingInterval","reconnectInterval","useBigInt","timer","statementParts","currentStatementList","statementList","$4QiMX$parse","$4QiMX$parseNumberAndBigInt","currentStatement","message","connectionResolver","resolve","reject","rejector","error","versionNegotiator","versionMessage","versionValidator","errorMessage","force","intentional","disconnectResolver","currentTime","verificationTimer","sentTimestamp","$1326c18f93f95fee$export$2e2bcd8739ae039","$7c0fb93e8eea922a$export$d73a2e87a509880","$7c0fb93e8eea922a$export$280de919a0cf6928","$620a18299ef8d6fd$var$ElectrumClient","$4QiMX$Mutex","unlock","retainSubscriptions","requestResolver","id","requestData","notification","subscriptionParameters","resubscriptionPromises","parameterJSON","resolverId","$620a18299ef8d6fd$export$2e2bcd8739ae039"],"mappings":"0DAGO,SAASA,EAAUC,EAAO,CAC/B,OAAOC,GAAc,KAAKD,CAAK,CACjC,CACA,IAAIC,GAAgB,aAMb,SAASC,GAASF,EAAO,CAC9B,OAAOG,GAAa,KAAKH,CAAK,CAChC,CACA,IAAIG,GAAe,gDAUZ,SAASC,GAAaJ,EAAOK,EAAQ,CAC1C,IAAIC,EAAM,WAAWN,CAAK,EACtBO,EAAM,OAAOD,CAAG,EAChBE,EAAIC,EAAyBT,CAAK,EAClC,EAAIS,EAAyBF,CAAG,EACpC,GAAIC,IAAM,EACR,MAAO,GAET,GAAqDH,GAAO,SAAY,GAAM,CAK5E,IAAIK,EAAiB,GACrB,GAAI,CAACX,EAAUC,CAAK,GAAK,EAAE,QAAUU,GAAkBF,EAAE,WAAW,EAAE,UAAU,EAAGE,CAAc,CAAC,EAChG,MAAO,EAEV,CACD,MAAO,EACT,CACO,IAAIC,EAAkC,SAAUA,EAAoB,CACzE,OAAAA,EAAmB,UAAe,YAClCA,EAAmB,SAAc,WACjCA,EAAmB,iBAAsB,mBACzCA,EAAmB,eAAoB,iBAChCA,CACT,EAAE,CAAE,CAAA,EAOG,SAASC,GAAsBZ,EAAO,CAC3C,GAAI,CAAAI,GAAaJ,EAAO,CACtB,OAAQ,EACZ,CAAG,EAGD,IAAID,EAAUC,CAAK,EACjB,OAAOW,EAAmB,iBAE5B,IAAIL,EAAM,WAAWN,CAAK,EAC1B,OAAK,SAASM,CAAG,EAGbA,IAAQ,EACHK,EAAmB,UAErBA,EAAmB,eALjBA,EAAmB,SAM9B,CAyBO,SAASF,EAAyBT,EAAO,CAC9C,OAAOA,EAEN,QAAQa,GAAwB,EAAE,EAGlC,QAAQC,GAAW,EAAE,EAGrB,QAAQC,GAAsB,EAAE,EAGhC,QAAQC,GAA+B,EAAE,CAC5C,CACA,IAAIH,GAAyB,gBACzBG,GAAgC,WAChCF,GAAY,KACZC,GAAuB,MCrH3B,SAASE,EAAQC,EAAK,CAAE,0BAA2B,OAAOD,EAAwB,OAAO,QAArB,YAA2C,OAAO,OAAO,UAA1B,SAAqC,SAAUC,EAAK,CAAE,OAAO,OAAOA,GAAS,SAAUA,EAAK,CAAE,OAAOA,GAAqB,OAAO,QAArB,YAA+BA,EAAI,cAAgB,QAAUA,IAAQ,OAAO,UAAY,SAAW,OAAOA,CAAI,EAAID,EAAQC,CAAG,CAAI,CAChV,SAASC,GAAgBC,EAAUC,EAAa,CAAE,GAAI,EAAED,aAAoBC,GAAgB,MAAM,IAAI,UAAU,mCAAmC,CAAM,CACzJ,SAASC,GAAkBC,EAAQC,EAAO,CAAE,QAASC,EAAI,EAAGA,EAAID,EAAM,OAAQC,IAAK,CAAE,IAAIC,EAAaF,EAAMC,CAAC,EAAGC,EAAW,WAAaA,EAAW,YAAc,GAAOA,EAAW,aAAe,GAAU,UAAWA,IAAYA,EAAW,SAAW,IAAM,OAAO,eAAeH,EAAQI,GAAeD,EAAW,GAAG,EAAGA,CAAU,EAAM,CAC7U,SAASE,GAAaP,EAAaQ,EAAYC,EAAa,CAAE,OAAID,GAAYP,GAAkBD,EAAY,UAAWQ,CAAU,EAAiE,OAAO,eAAeR,EAAa,YAAa,CAAE,SAAU,GAAO,EAAUA,CAAc,CAC7R,SAASU,GAAgBb,EAAKc,EAAKhC,EAAO,CAAE,OAAAgC,EAAML,GAAeK,CAAG,EAAOA,KAAOd,EAAO,OAAO,eAAeA,EAAKc,EAAK,CAAE,MAAOhC,EAAO,WAAY,GAAM,aAAc,GAAM,SAAU,EAAM,CAAA,EAAYkB,EAAIc,CAAG,EAAIhC,EAAgBkB,CAAM,CAC5O,SAASS,GAAeM,EAAK,CAAE,IAAID,EAAME,GAAaD,EAAK,QAAQ,EAAG,OAAOhB,EAAQe,CAAG,IAAM,SAAWA,EAAM,OAAOA,CAAG,CAAI,CAC7H,SAASE,GAAaC,EAAOC,EAAM,CAAE,GAAInB,EAAQkB,CAAK,IAAM,UAAYA,IAAU,KAAM,OAAOA,EAAO,IAAIE,EAAOF,EAAM,OAAO,WAAW,EAAG,GAAIE,IAAS,OAAW,CAAE,IAAIC,EAAMD,EAAK,KAAKF,EAAOC,GAAQ,SAAS,EAAG,GAAInB,EAAQqB,CAAG,IAAM,SAAU,OAAOA,EAAK,MAAM,IAAI,UAAU,8CAA8C,CAAI,CAAC,OAAQF,IAAS,SAAW,OAAS,QAAQD,CAAK,CAAI,CAMtX,IAAII,GAA8B,UAAY,CACnD,SAASA,EAAevC,EAAO,CAK7B,GAJAmB,GAAgB,KAAMoB,CAAc,EAGpCR,GAAgB,KAAM,mBAAoB,EAAI,EAC1C,CAAC7B,GAASF,CAAK,EACjB,MAAM,IAAI,MAAM,2BAA6BA,EAAQ,IAAI,EAE3D,KAAK,MAAQA,CACd,CAaD,OAAA4B,GAAaW,EAAgB,CAAC,CAC5B,IAAK,UACL,MAAO,UAAmB,CACxB,IAAIC,EAAe5B,GAAsB,KAAK,KAAK,EAGnD,GAAI4B,IAAiB,QAAaA,IAAiB7B,EAAmB,eACpE,OAAO,WAAW,KAAK,KAAK,EAI9B,GAAIZ,EAAU,KAAK,KAAK,EACtB,OAAO,OAAO,KAAK,KAAK,EAI1B,MAAM,IAAI,MAAM,oCAAsC,cAAc,OAAO,KAAK,MAAO,UAAU,EAAE,OAAOyC,EAAc,cAAc,EAAE,OAAO,WAAW,KAAK,KAAK,CAAC,CAAC,CACvK,CAKL,EAAK,CACD,IAAK,WACL,MAAO,UAAoB,CACzB,OAAO,KAAK,KACb,CAKF,CAAA,CAAC,EACKD,CACT,IAKO,SAASE,GAAiBzC,EAAO,CAGtC,OAAOA,GAASiB,EAAQjB,CAAK,IAAM,UAAYA,EAAM,mBAAqB,IAAQ,EACpF,CC3EO,SAAS0C,GAAoB1C,EAAO,CACzC,OAAO,IAAIuC,GAAevC,CAAK,CACjC,CACO,SAAS2C,GAAqB3C,EAAO,CAC1C,OAAOD,EAAUC,CAAK,EAAI,OAAOA,CAAK,EAAI,WAAWA,CAAK,CAC5D,CCPA,SAASiB,EAAQC,EAAK,CAAE,0BAA2B,OAAOD,EAAwB,OAAO,QAArB,YAA2C,OAAO,OAAO,UAA1B,SAAqC,SAAUC,EAAK,CAAE,OAAO,OAAOA,GAAS,SAAUA,EAAK,CAAE,OAAOA,GAAqB,OAAO,QAArB,YAA+BA,EAAI,cAAgB,QAAUA,IAAQ,OAAO,UAAY,SAAW,OAAOA,CAAI,EAAID,EAAQC,CAAG,CAAI,CAYzU,SAAS0B,GAAOC,EAAMC,EAAS,CACpC,OAAOC,EAAY,CACjB,GAAIF,CACR,EAAK,GAAIA,EAAMC,CAAO,CACtB,CAKA,SAASC,EAAYC,EAAShB,EAAKhC,EAAO8C,EAAS,CACjD,OAAI,MAAM,QAAQ9C,CAAK,EACd8C,EAAQ,KAAKE,EAAShB,EAAKiB,GAAYjD,EAAO8C,CAAO,CAAC,EACpD9C,GAASiB,EAAQjB,CAAK,IAAM,UAAY,CAACyC,GAAiBzC,CAAK,EAGjE8C,EAAQ,KAAKE,EAAShB,EAAKkB,GAAalD,EAAO8C,CAAO,CAAC,EAEvDA,EAAQ,KAAKE,EAAShB,EAAKhC,CAAK,CAE3C,CAKA,SAASkD,GAAaC,EAAQL,EAAS,CACrC,cAAO,KAAKK,CAAM,EAAE,QAAQ,SAAUnB,EAAK,CACzC,IAAIhC,EAAQ+C,EAAYI,EAAQnB,EAAKmB,EAAOnB,CAAG,EAAGc,CAAO,EACrD9C,IAAU,OACZmD,EAAOnB,CAAG,EAAIhC,EAEd,OAAOmD,EAAOnB,CAAG,CAEvB,CAAG,EACMmB,CACT,CAKA,SAASF,GAAYG,EAAON,EAAS,CACnC,QAASrB,EAAI,EAAGA,EAAI2B,EAAM,OAAQ3B,IAChC2B,EAAM3B,CAAC,EAAIsB,EAAYK,EAAO3B,EAAI,GAAI2B,EAAM3B,CAAC,EAAGqB,CAAO,EAEzD,OAAOM,CACT,CCxDA,SAASnC,EAAQC,EAAK,CAAE,0BAA2B,OAAOD,EAAwB,OAAO,QAArB,YAA2C,OAAO,OAAO,UAA1B,SAAqC,SAAUC,EAAK,CAAE,OAAO,OAAOA,GAAS,SAAUA,EAAK,CAAE,OAAOA,GAAqB,OAAO,QAArB,YAA+BA,EAAI,cAAgB,QAAUA,IAAQ,OAAO,UAAY,SAAW,OAAOA,CAAI,EAAID,EAAQC,CAAG,CAAI,CAChV,SAASmC,EAAmBC,EAAK,CAAE,OAAOC,GAAmBD,CAAG,GAAKE,GAAiBF,CAAG,GAAKG,GAA4BH,CAAG,GAAKI,GAAoB,CAAG,CACzJ,SAASA,IAAqB,CAAE,MAAM,IAAI,UAAU;AAAA,mFAAsI,CAAI,CAC9L,SAASD,GAA4BE,EAAGC,EAAQ,CAAE,GAAKD,EAAW,IAAI,OAAOA,GAAM,SAAU,OAAOE,EAAkBF,EAAGC,CAAM,EAAG,IAAI,EAAI,OAAO,UAAU,SAAS,KAAKD,CAAC,EAAE,MAAM,EAAG,EAAE,EAAgE,GAAzD,IAAM,UAAYA,EAAE,cAAa,EAAIA,EAAE,YAAY,MAAU,IAAM,OAAS,IAAM,MAAO,OAAO,MAAM,KAAKA,CAAC,EAAG,GAAI,IAAM,aAAe,2CAA2C,KAAK,CAAC,EAAG,OAAOE,EAAkBF,EAAGC,CAAM,EAAI,CACha,SAASJ,GAAiBM,EAAM,CAAE,GAAI,OAAO,OAAW,KAAeA,EAAK,OAAO,QAAQ,GAAK,MAAQA,EAAK,YAAY,GAAK,KAAM,OAAO,MAAM,KAAKA,CAAI,CAAI,CAC9J,SAASP,GAAmBD,EAAK,CAAE,GAAI,MAAM,QAAQA,CAAG,EAAG,OAAOO,EAAkBP,CAAG,CAAI,CAC3F,SAASO,EAAkBP,EAAKS,EAAK,EAAMA,GAAO,MAAQA,EAAMT,EAAI,UAAQS,EAAMT,EAAI,QAAQ,QAAS7B,EAAI,EAAGuC,EAAO,IAAI,MAAMD,CAAG,EAAGtC,EAAIsC,EAAKtC,IAAKuC,EAAKvC,CAAC,EAAI6B,EAAI7B,CAAC,EAAG,OAAOuC,CAAO,CAyB5K,SAASC,GAAMC,EAAMpB,EAAS,CACnC,IAAIqB,EAAc,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAY,UAAU,CAAC,EAAIzB,GAClFjB,EAAI,EACJzB,EAAQoE,IACZ,OAAAC,GAAYrE,CAAK,EACjBsE,KACOxB,EAAUF,GAAO5C,EAAO8C,CAAO,EAAI9C,EAC1C,SAASuE,GAAc,CACrB,GAAIL,EAAK,WAAWzC,CAAC,IAAM+C,GAAkB,CAC3C/C,IACAgD,IAGA,QAFItB,EAAS,CAAA,EACTuB,EAAU,GACPjD,EAAIyC,EAAK,QAAUA,EAAK,WAAWzC,CAAC,IAAMkD,GAAkB,CAC5DD,EAIHA,EAAU,IAHVE,IACAH,KAIF,IAAII,EAAQpD,EACRO,EAAM8C,IACN9C,IAAQ,QACV+C,KAEFN,IACAO,KACA,IAAIC,EAASb,IACTa,IAAW,QACbC,KAIE,OAAO,UAAU,eAAe,KAAK/B,EAAQnB,CAAG,GAAK,CAACmD,EAAYF,EAAQ9B,EAAOnB,CAAG,CAAC,GAGvFoD,GAAkBpD,EAAK6C,EAAQ,CAAC,EAElC1B,EAAOnB,CAAG,EAAIiD,CACf,CACD,OAAIf,EAAK,WAAWzC,CAAC,IAAMkD,GACzBU,KAEF5D,IACO0B,CACR,CACF,CACD,SAASmC,GAAa,CACpB,GAAIpB,EAAK,WAAWzC,CAAC,IAAM8D,GAAoB,CAC7C9D,IACAgD,IAGA,QAFIrB,EAAQ,CAAA,EACRsB,EAAU,GACPjD,EAAIyC,EAAK,QAAUA,EAAK,WAAWzC,CAAC,IAAM+D,GAAoB,CAC9Dd,EAGHA,EAAU,GAFVE,IAIF,IAAIa,EAAUrB,IACdsB,GAAgBD,CAAO,EACvBrC,EAAM,KAAKqC,CAAO,CACnB,CACD,OAAIvB,EAAK,WAAWzC,CAAC,IAAM+D,GACzBG,KAEFlE,IACO2B,CACR,CACF,CACD,SAASgB,GAAa,CACpB,IAAIwB,EAAMC,EAAOC,EAAOC,EAAOC,EAAOC,EACtCxB,IACA,IAAIzE,IAAS4F,GAAQC,GAASC,GAASC,GAASC,GAASC,EAAenB,EAAW,KAAQ,MAAQmB,IAAiB,OAASA,EAAeC,GAAY,KAAQ,MAAQF,IAAU,OAASA,EAAQzB,OAAmB,MAAQwB,IAAU,OAASA,EAAQT,EAAY,KAAM,MAAQQ,IAAU,OAASA,EAAQK,EAAa,OAAQ,EAAI,KAAO,MAAQN,IAAU,OAASA,EAAQM,EAAa,QAAS,EAAK,KAAO,MAAQP,IAAS,OAASA,EAAOO,EAAa,OAAQ,IAAI,EAC7c,OAAA1B,IACOzE,EACR,CACD,SAASmG,EAAaC,EAAMpG,EAAO,CACjC,GAAIkE,EAAK,MAAMzC,EAAGA,EAAI2E,EAAK,MAAM,IAAMA,EACrC,OAAA3E,GAAK2E,EAAK,OACHpG,CAEV,CACD,SAASyE,GAAiB,CACxB,KAAO4B,GAAanC,EAAK,WAAWzC,CAAC,CAAC,GACpCA,GAEH,CACD,SAASqD,GAAc,CACrB,GAAIZ,EAAK,WAAWzC,CAAC,IAAM6E,EAAiB,CAC1C7E,IAEA,QADI8E,EAAS,GACN9E,EAAIyC,EAAK,QAAUA,EAAK,WAAWzC,CAAC,IAAM6E,GAAiB,CAChE,GAAIpC,EAAK,WAAWzC,CAAC,IAAM+E,GAAe,CACxC,IAAIC,EAAOvC,EAAKzC,EAAI,CAAC,EACjBiF,EAAaC,GAAiBF,CAAI,EAClCC,IAAe,QACjBH,GAAUG,EACVjF,KACSgF,IAAS,IACdG,EAAM1C,EAAK,WAAWzC,EAAI,CAAC,CAAC,GAAKmF,EAAM1C,EAAK,WAAWzC,EAAI,CAAC,CAAC,GAAKmF,EAAM1C,EAAK,WAAWzC,EAAI,CAAC,CAAC,GAAKmF,EAAM1C,EAAK,WAAWzC,EAAI,CAAC,CAAC,GACjI8E,GAAU,OAAO,aAAa,SAASrC,EAAK,MAAMzC,EAAI,EAAGA,EAAI,CAAC,EAAG,EAAE,CAAC,EACpEA,GAAK,GAELoF,GAA6BpF,CAAC,EAGhCqF,GAA4BrF,CAAC,CAEzC,MACcsF,GAAuB7C,EAAK,WAAWzC,CAAC,CAAC,EAC3C8E,GAAUrC,EAAKzC,CAAC,EAEhBuF,GAAsB9C,EAAKzC,CAAC,CAAC,EAGjCA,GACD,CACD,OAAAwF,KACAxF,IACO8E,CACR,CACF,CACD,SAASL,IAAe,CACtB,IAAIrB,EAAQpD,EAKZ,GAJIyC,EAAK,WAAWzC,CAAC,IAAMyF,KACzBzF,IACA0F,EAAYtC,CAAK,GAEfX,EAAK,WAAWzC,CAAC,IAAM2F,EACzB3F,YACS4F,GAAenD,EAAK,WAAWzC,CAAC,CAAC,EAE1C,IADAA,IACO6F,EAAQpD,EAAK,WAAWzC,CAAC,CAAC,GAC/BA,IAGJ,GAAIyC,EAAK,WAAWzC,CAAC,IAAM8F,GAGzB,IAFA9F,IACA0F,EAAYtC,CAAK,EACVyC,EAAQpD,EAAK,WAAWzC,CAAC,CAAC,GAC/BA,IAGJ,GAAIyC,EAAK,WAAWzC,CAAC,IAAM+F,IAAkBtD,EAAK,WAAWzC,CAAC,IAAMgG,GAMlE,IALAhG,KACIyC,EAAK,WAAWzC,CAAC,IAAMyF,IAAahD,EAAK,WAAWzC,CAAC,IAAMiG,KAC7DjG,IAEF0F,EAAYtC,CAAK,EACVyC,EAAQpD,EAAK,WAAWzC,CAAC,CAAC,GAC/BA,IAGJ,GAAIA,EAAIoD,EACN,OAAOV,EAAYD,EAAK,MAAMW,EAAOpD,CAAC,CAAC,CAE1C,CACD,SAASmD,GAAW,CAClB,GAAIV,EAAK,WAAWzC,CAAC,IAAMkG,GACzB,MAAM,IAAI,YAAY,kCAAkC,OAAOC,EAAK,CAAE,CAAC,EAEzEnG,GACD,CACD,SAASuD,IAAW,CAClB,GAAId,EAAK,WAAWzC,CAAC,IAAMoG,GACzB,MAAM,IAAI,YAAY,0CAA0C,OAAOD,EAAK,CAAE,CAAC,EAEjFnG,GACD,CACD,SAAS4C,GAAYrE,EAAO,CAC1B,GAAIA,IAAU,OACZ,MAAM,IAAI,YAAY,uBAAuB,OAAO4H,EAAK,CAAE,CAAC,CAE/D,CACD,SAASlC,GAAgB1F,EAAO,CAC9B,GAAIA,IAAU,OACZ,MAAM,IAAI,YAAY,uBAAuB,OAAO4H,EAAK,CAAE,CAAC,CAE/D,CACD,SAAStD,IAAmB,CAC1B,GAAI7C,EAAIyC,EAAK,OACX,MAAM,IAAI,YAAY,yBAAyB,OAAO0D,EAAK,CAAE,CAAC,CAEjE,CACD,SAAST,EAAYtC,EAAO,CAC1B,GAAI,CAACyC,EAAQpD,EAAK,WAAWzC,CAAC,CAAC,EAAG,CAChC,IAAIqG,EAAW5D,EAAK,MAAMW,EAAOpD,CAAC,EAClC,MAAM,IAAI,YAAY,mBAAmB,OAAOqG,EAAU,uBAAuB,EAAE,OAAOF,EAAO,CAAA,CAAC,CACnG,CACF,CACD,SAASX,IAAoB,CAC3B,GAAI/C,EAAK,WAAWzC,CAAC,IAAM6E,EACzB,MAAM,IAAI,YAAY,8BAA+B,OAAOsB,EAAK,CAAE,CAAC,CAEvE,CACD,SAAS7C,IAAyB,CAChC,MAAM,IAAI,YAAY,8BAA8B,OAAO6C,EAAK,CAAE,CAAC,CACpE,CACD,SAASxC,GAAkBpD,EAAK+F,EAAK,CACnC,MAAM,IAAI,YAAY,kBAAkB,OAAO/F,EAAK,4BAA4B,EAAE,OAAO+F,CAAG,CAAC,CAC9F,CACD,SAAS1C,IAA8B,CACrC,MAAM,IAAI,YAAY,mDAAmD,OAAOuC,EAAK,CAAE,CAAC,CACzF,CACD,SAASjC,IAA8B,CACrC,MAAM,IAAI,YAAY,2CAA2C,OAAOiC,EAAK,CAAE,CAAC,CACjF,CACD,SAASZ,GAAsBP,EAAM,CACnC,MAAM,IAAI,YAAY,sBAAsB,OAAOA,EAAM,IAAI,EAAE,OAAOsB,EAAK,CAAA,CAAC,CAC7E,CACD,SAASjB,GAA4BjC,EAAO,CAC1C,IAAImD,EAAQ9D,EAAK,MAAMW,EAAOA,EAAQ,CAAC,EACvC,MAAM,IAAI,YAAY,6BAA6B,OAAOmD,EAAO,IAAI,EAAE,OAAOD,EAAK,CAAA,CAAC,CACrF,CACD,SAAS7C,IAA2B,CAClC,MAAM,IAAI,YAAY,mCAAmC,OAAO6C,EAAG,CAAE,CAAC,CACvE,CACD,SAASlB,GAA6BhC,EAAO,CAE3C,QADIoD,EAAMpD,EAAQ,EACX,KAAK,KAAKX,EAAK+D,CAAG,CAAC,GACxBA,IAEF,IAAID,EAAQ9D,EAAK,MAAMW,EAAOoD,CAAG,EACjC,MAAM,IAAI,YAAY,8BAA8B,OAAOD,EAAO,IAAI,EAAE,OAAOD,EAAK,CAAA,CAAC,CACtF,CAGD,SAASA,GAAM,CACb,MAAO,eAAe,OAAOtG,CAAC,CAC/B,CACD,SAASyG,IAAM,CACb,OAAOzG,EAAIyC,EAAK,OAAS,YAAY,OAAOA,EAAKzC,CAAC,EAAG,GAAG,EAAI,0BAC7D,CACD,SAASmG,GAAQ,CACf,OAAOM,GAAK,EAAG,IAAMH,GACtB,CACH,CACA,SAAS1B,GAAa8B,EAAM,CAC1B,OAAOA,IAASC,IAAaD,IAASE,IAAeF,IAASG,IAAWH,IAASI,EACpF,CACA,SAAS3B,EAAMuB,EAAM,CACnB,OAAOA,GAAQf,GAAYe,GAAQK,GAAYL,GAAQM,IAAkBN,GAAQO,IAAkBP,GAAQQ,IAAkBR,GAAQS,EACvI,CACA,SAAStB,EAAQa,EAAM,CACrB,OAAOA,GAAQf,GAAYe,GAAQK,CACrC,CACA,SAASnB,GAAec,EAAM,CAC5B,OAAOA,GAAQU,IAAWV,GAAQK,CACpC,CACO,SAASzB,GAAuBoB,EAAM,CAC3C,OAAOA,GAAQ,IAAQA,GAAQ,OACjC,CACO,SAAShD,EAAY2D,EAAGC,EAAG,CAChC,GAAID,IAAMC,EACR,MAAO,GAET,GAAI,MAAM,QAAQD,CAAC,GAAK,MAAM,QAAQC,CAAC,EACrC,OAAOD,EAAE,SAAWC,EAAE,QAAUD,EAAE,MAAM,SAAUE,EAAMC,EAAO,CAC7D,OAAO9D,EAAY6D,EAAMD,EAAEE,CAAK,CAAC,CACvC,CAAK,EAEH,GAAIC,EAASJ,CAAC,GAAKI,EAASH,CAAC,EAAG,CAC9B,IAAII,EAAO9F,EAAmB,IAAI,IAAI,CAAA,EAAG,OAAOA,EAAmB,OAAO,KAAKyF,CAAC,CAAC,EAAGzF,EAAmB,OAAO,KAAK0F,CAAC,CAAC,CAAC,CAAC,CAAC,EACxH,OAAOI,EAAK,MAAM,SAAUnH,EAAK,CAC/B,OAAOmD,EAAY2D,EAAE9G,CAAG,EAAG+G,EAAE/G,CAAG,CAAC,CACvC,CAAK,CACF,CACD,MAAO,EACT,CACA,SAASkH,EAASlJ,EAAO,CACvB,OAAOiB,EAAQjB,CAAK,IAAM,UAAYA,IAAU,IAClD,CAGA,IAAI2G,GAAmB,CACrB,IAAK,IACL,KAAM,KACN,IAAK,IACL,EAAG,KACH,EAAG,KACH,EAAG;AAAA,EACH,EAAG,KACH,EAAG,GAEL,EAEIH,GAAgB,GAChBhC,GAAmB,IACnBG,EAAmB,IACnBY,GAAqB,GACrBC,EAAqB,GACrB4C,GAAY,GACZC,GAAc,GACdC,GAAU,EACVC,GAAa,GACbjC,EAAkB,GAClBoB,GAAW,GACXR,GAAY,GACZE,EAAW,GACXyB,GAAU,GACVL,EAAW,GACXb,GAAY,GACZJ,GAAU,GACVM,GAAY,GACLY,GAAiB,GACjBE,GAAiB,GACjBlB,GAAiB,GACjBD,GAAiB,IACjBkB,GAAiB,GACjBE,GAAiB,IC5U5B,SAASQ,EAAe,EAAGC,EAAG7I,EAAG8I,EAAG,CAClC,OAAO,eAAe,EAAGD,EAAG,CAAC,IAAK7I,EAAG,IAAK8I,EAAG,WAAY,GAAM,aAAc,EAAK,CAAA,CACpF,CAGA,MAAMC,EAA8B,CAChC,OAAYC,EAAc,uBAAuB,EACjD,QAAaA,EAAc,uBAAuB,EAClD,OAAYA,EAAc,uBAAuB,EACjD,QAAaA,EAAc,uBAAuB,EAClD,QAAaA,EAAc,uBAAuB,EAClD,KAAUA,EAAc,uBAAuB,CACnD,EAEAD,EAA4B,OAAO,MAAQ,IAC3CA,EAA4B,QAAQ,MAAQ,IAC5CA,EAA4B,OAAO,MAAQ,IAC3CA,EAA4B,QAAQ,MAAQ,KAC5CA,EAA4B,QAAQ,MAAQ,IAC5CA,EAA4B,KAAK,MAAQ,IACzC,IACAE,EAA2CF,EAQvC,MAAMG,EAAuC,CAS5C,OAAO,mBAAmBC,EAAQC,EAAYC,EAAW,CAKtD,OAAO,KAAK,UAAU,CAClB,OAAAF,EACA,OAAQC,EACR,GAAIC,CAAA,CACP,CACL,CAKC,WAAW,eAAgB,CACjB,MAAA,eACX,CAKC,WAAW,oBAAqB,CACtB,MAAA;AAAA,CACX,CACJ,CACA,IACAC,EAA2CJ,GAGvCK,GAA4B,CAAA,EAEhCX,EAAeW,GAA2B,oBAAqB,IAAMC,EAAyC,EAC9GZ,EAAeW,GAA2B,sBAAuB,IAAME,EAAyC,EAChH,MAAMD,GAA4C,SAAS7G,EAAQ,CAC/D,MAAO,UAAWA,CACtB,EACM8G,GAA4C,SAAS9G,EAAQ,CACxD,MAAA,aAAcA,GAAU,aAAcA,CACjD,EAGA,IAAI+G,GAA4B,CAAA,EAEhCd,EAAec,GAA2B,oBAAqB,IAAMC,CAAyC,EAC9Gf,EAAec,GAA2B,oBAAqB,IAAME,CAAyC,EAC9G,IAAIC,EAA4B,CAAA,EAEhCjB,EAAeiB,EAA2B,eAAgB,IAAMC,CAAyC,EACzGlB,EAAeiB,EAA2B,sBAAuB,IAAME,CAAyC,EAChHnB,EAAeiB,EAA2B,gBAAiB,IAAMG,CAAyC,EAC1GpB,EAAeiB,EAA2B,cAAe,IAAMI,CAAyC,EACxGrB,EAAeiB,EAA2B,mBAAoB,IAAMK,CAAyC,EAOzG,IAAIJ,GACP,SAASK,EAAc,CACpBA,EAAaA,EAAa,OAAY,CAAC,EAAI,SAC3CA,EAAaA,EAAa,SAAc,CAAC,EAAI,UACjD,GAAGL,IAA8CA,EAA4C,CAAG,EAAA,EAChG,IAAIC,GACH,SAASK,EAAqB,CAC3BA,EAAoBA,EAAoB,IAAS,CAAC,EAAI,KAC1D,GAAGL,IAA8CA,EAA4C,CAAG,EAAA,EAChG,IAAIC,GACH,SAASK,EAAe,CACrBA,EAAcA,EAAc,SAAc,CAAC,EAAI,WAC/CA,EAAcA,EAAc,SAAc,CAAC,EAAI,WAC/CA,EAAcA,EAAc,MAAW,CAAC,EAAI,OAChD,GAAGL,IAA8CA,EAA4C,CAAG,EAAA,EAChG,IAAIC,GACH,SAASK,EAAa,CACnBA,EAAYA,EAAY,YAAiB,CAAC,EAAI,cAC9CA,EAAYA,EAAY,UAAe,CAAC,EAAI,WAChD,GAAGL,IAA8CA,EAA4C,CAAG,EAAA,EAChG,IAAIC,GACH,SAASK,EAAkB,CACxBA,EAAiBA,EAAiB,aAAkB,CAAC,EAAI,eACzDA,EAAiBA,EAAiB,UAAe,CAAC,EAAI,YACtDA,EAAiBA,EAAiB,cAAmB,CAAC,EAAI,gBAC1DA,EAAiBA,EAAiB,WAAgB,CAAC,EAAI,aACvDA,EAAiBA,EAAiB,aAAkB,CAAC,EAAI,cAC7D,GAAGL,IAA8CA,EAA4C,CAAG,EAAA,EAGhG,MAAMP,EAA4C,CAC9C,IAAK,CACD,KAAM,MACN,OAAQ,KACZ,EACA,QAAS,CACL,KAAM,MACN,OAAQ,SACZ,EACA,GAAI,CACA,KAAM,MACN,OAAQ,IACZ,EACA,IAAK,CACD,KAAM,MACN,OAAQ,KACZ,CACJ,EACMC,EAA4C,CAE9C,KAAMD,EAA0C,QAAQ,KAExD,iBAAkBA,EAA0C,QAAQ,OAEpE,UAAW,IAEX,QAAS,IAGT,cAAe,IAEf,mBAAoB,EAEpB,qBAA0BI,EAA2C,IAErE,cAAmBD,EAA2C,OAE9D,YAAa,EACjB,EAmBI,MAAMU,WAAiDC,EAAAA,YAAqB,CAU3E,QAAQC,EAAMC,EAAMC,EAAQC,EAAS,CAElC,GAAI,KAAK,WAAa,KAAK,UAAiB,MAAA,IAAI,MAAM,4EAA4E,EAE7H,KAAA,OAAO,WAAa,WAAW,IAAI,KAAK,oBAAoBH,EAAMC,EAAME,CAAO,EAAGA,CAAO,EAEzF,KAAA,KAAK,UAAW,KAAK,6BAA6B,EAEvD,MAAMC,EAAc,CAChB,CAAKnB,EAA2C,IAAI,MAAM,EAAG,eAC7D,CAAKA,EAA2C,QAAQ,MAAM,EAAG,0BACjE,CAAKA,EAA2C,GAAG,MAAM,EAAG,cAC5D,CAAKA,EAA2C,IAAI,MAAM,EAAG,wBAAA,EAI7D,GADAV,EAA0C,QAAQ,cAAc6B,EAAYF,CAAM,CAAC,mBAAmBF,CAAI,IAAIC,CAAI,IAAI,EACtHC,IAAejB,EAA2C,IAAI,QAAUiB,IAAejB,EAA2C,QAAQ,OAAQ,CAClJ,GAAIiB,IAAejB,EAA2C,QAAQ,OAAQ,CAE1E,MAAMoB,EAAoB,CACtB,mBAAoB,EAAA,EAGnB,YAAYL,CAAI,IAErBK,EAAkB,WAAaL,GAE/B,KAAK,UAAY,eAAeC,EAAMD,EAAMK,CAAiB,EAGxD,KAAA,UAAU,KAAK,gBAAiB,IAAI,CAEjC,GAAA,EAAE,KAAK,qBAAqB,kBAAmB,OAGxB,KAAK,UAAU,qBACf,+BAAmC9B,EAA0C,QAAQ,iBAAiByB,CAAI,IAAIC,CAAI,iCAAiC,CAAA,CACjL,EAED,KAAK,UAAU,GAAG,gBAAiB,KAAK,UAAU,KAAK,KAAMG,EAAYF,CAAM,EAAGF,EAAMC,CAAI,CAAC,CAAA,MAG7F,KAAK,UAAY,gBAAgB,CAC7B,KAAAD,EACA,KAAAC,CAAA,CACH,EAED,KAAK,UAAU,GAAG,UAAW,KAAK,UAAU,KAAK,KAAMG,EAAYF,CAAM,EAAGF,EAAMC,CAAI,CAAC,EAGtF,KAAA,UAAU,YAAY,MAAM,EAE5B,KAAA,UAAU,aAAa,GAAM,CAAC,EAE9B,KAAA,UAAU,WAAW,EAAI,EAE9B,KAAK,UAAU,GAAG,QAAS,KAAK,gBAAgB,QAAQ,CAAA,SACjDC,IAAejB,EAA2C,GAAG,QAAUiB,IAAejB,EAA2C,IAAI,OACxIiB,IAAejB,EAA2C,IAAI,OAE7D,KAAA,UAAY,IAAQqB,EAAkB,SAASN,CAAI,IAAIC,CAAI,EAAE,EAE7D,KAAA,UAAY,IAAQK,EAAkB,QAAQN,CAAI,IAAIC,CAAI,EAAE,EAEjE,KAAK,UAAU,iBAAiB,OAAQ,KAAK,UAAU,KAAK,KAAMG,EAAYF,CAAM,EAAGF,EAAMC,CAAI,CAAC,EAElG,KAAK,UAAU,iBAAiB,QAAS,KAAK,gBAAgB,OAAO,MAEnE,OAAA,IAAI,MAAM,+BAA+B,CACnD,CAOC,UAAUM,EAAgBP,EAAMC,EAAM,CAE/B,KAAK,kBAEL1B,EAA0C,QAAQ,eAAegC,CAAc,qBAAqBP,CAAI,IAAIC,CAAI,IAAI,EACpH,OAAO,KAAK,UAAc,KAE1B,KAAK,UAAU,YAAY,QAAS,KAAK,gBAAgB,UAAU,EACnE,KAAK,UAAU,YAAY,OAAQ,KAAK,gBAAgB,OAAO,GACxD,OAAO,KAAK,UAAc,MAEjC,KAAK,UAAU,iBAAiB,QAAS,KAAK,gBAAgB,UAAU,EACxE,KAAK,UAAU,iBAAiB,UAAW,KAAK,gBAAgB,MAAM,GAG1E,KAAK,gBAAkB,GAEvB,KAAK,KAAK,SAAS,EACvB,CAGC,+BAAgC,CAEzB,KAAK,OAAO,YAAyB,aAAA,KAAK,OAAO,UAAU,CACnE,CAKC,YAAa,CAIV,GAFA,KAAK,8BAA8B,EAE/B,KAAK,UAEL,KAAK,UAAU,eAAe,QAAS,KAAK,gBAAgB,UAAU,EACtE,KAAK,UAAU,eAAe,OAAQ,KAAK,gBAAgB,OAAO,EAClE,KAAK,UAAU,eAAe,QAAS,KAAK,gBAAgB,QAAQ,EAEpE,KAAK,UAAU,UAEf,KAAK,UAAY,eACV,KAAK,UAAe,GAAA,CAE3B,KAAK,UAAU,oBAAoB,QAAS,KAAK,gBAAgB,UAAU,EAC3E,KAAK,UAAU,oBAAoB,UAAW,KAAK,gBAAgB,MAAM,EACzE,KAAK,UAAU,oBAAoB,QAAS,KAAK,gBAAgB,OAAO,EAExE,KAAK,UAAU,aACD,CAAA,QAGhB,CAEE,KAAK,UAAY,MACrB,CAEA,KAAK,gBAAkB,GAEvB,KAAK,KAAK,YAAY,CAC1B,CAUC,MAAMO,EAAMC,EAAU,CACnB,GAAI,KAAK,UAET,OAAO,KAAK,UAAU,MAAMD,EAAMC,CAAQ,EAC1C,GAAI,KAAK,UAEA,YAAA,UAAU,KAAKD,EAAMC,CAAQ,EAE3B,GAGL,MAAA,IAAI,MAAM,2DAA2D,CAC/E,CAOC,oBAAoBT,EAAMC,EAAME,EAAS,CAEjC,KAAA,eAAe,UAAW,KAAK,6BAA6B,EAEjE,MAAMO,EAAe,CACjB,KAAM,YACN,QAAS,kBAAkBV,CAAI,IAAIC,CAAI,qBAAqBE,CAAO,eAAA,EAGlE,KAAA,KAAK,QAASO,CAAY,EAE/B,KAAK,WAAW,CACpB,CACA,eAAeC,EAAK,CAChB,MAAM,GAAGA,CAAI,EAEb,KAAK,OAAS,GAEd,KAAK,gBAAkB,GAEvB,KAAK,gBAAkB,CACnB,WAAY,IAAI,KAAK,KAAK,YAAY,EACtC,QAAUH,GAAO,KAAK,KAAK,OAAQA,CAAI,EACvC,OAASI,GAAQ,KAAK,KAAK,OAAQ,GAAGA,EAAM,IAAI;AAAA,CAAI,EACpD,SAAWC,GAAM,KAAK,KAAK,QAASA,CAAG,EACvC,QAAUD,GAAQ,KAAK,KAAK,QAASA,EAAM,KAAK,CAAA,CAExD,CACJ,CACA,IACAE,GAA2ChB,GASvC,MAAMiB,WAAqDhB,EAAAA,YAAqB,CAe/E,YAAYiB,EAAaC,EAASjB,EAAMC,EAAWf,EAA2C,KAAMgB,EAAahB,EAA2C,iBAAkBiB,EAAcjB,EAA2C,QAASgC,EAAmBhC,EAA2C,cAAeiC,EAAwBjC,EAA2C,UAAWkC,EAAgBlC,EAA2C,YAAY,CAsB/c,GApBM,QACN,KAAK,YAAc8B,EACnB,KAAK,QAAUC,EACf,KAAK,KAAOjB,EACZ,KAAK,KAAOC,EACZ,KAAK,OAASC,EACd,KAAK,QAAUC,EACf,KAAK,aAAee,EACpB,KAAK,kBAAoBC,EACzB,KAAK,UAAYC,EACjB,KACA,OAAS,GACT,KAEA,cAAgB,GAEhB,KAAA,OAAa5B,EAA2C,aACxD,KACA,cAAgB,GAEZ,CAAKZ,EAA0C,cAAc,KAAKqC,CAAO,EAC7E,MAAM,IAAI,MAAM,4BAA4BA,CAAO,2CAA2C,EAE9F,KAAK,aAAa,EAEd,OAAO,SAAa,KAAsB,SAAA,iBAAiB,mBAAoB,KAAK,uBAAuB,KAAK,IAAI,CAAC,CAC7H,CAGC,IAAI,gBAAiB,CAClB,MAAO,GAAG,KAAK,IAAI,IAAI,KAAK,IAAI,EACpC,CAGC,cAAe,CAEP,KAAA,OAAS,IAAQH,GAEtB,KAAK,OAAO,GAAG,UAAW,KAAK,gBAAgB,KAAK,IAAI,CAAC,EACzD,KAAK,OAAO,GAAG,aAAc,KAAK,mBAAmB,KAAK,IAAI,CAAC,EAE/D,KAAK,OAAO,GAAG,OAAQ,KAAK,kBAAkB,KAAK,IAAI,CAAC,CAC5D,CAGC,eAAgB,CAEb,KAAK,OAAO,YAChB,CAOC,kBAAkBN,EAAM,CASrB,IAPK,KAAA,sBAAwB,KAAK,MAElC,KAAK,cAAc,QAASa,GAAQ,aAAaA,CAAK,CAAC,EACvD,KAAK,cAAc,OAAS,EAE5B,KAAK,eAAiBb,EAEhB,KAAK,cAAc,SAAa5B,EAA0C,kBAAkB,GAAE,CAEhG,MAAM0C,EAAiB,KAAK,cAAc,MAAU1C,EAA0C,kBAAkB,EAE1G,KAAA0C,EAAe,OAAS,GAAE,CAE5B,MAAMC,EAAuB,OAAOD,EAAe,MAAO,CAAA,EAEtD,IAAAE,EAAoBC,GAAcF,EAAsB,KAAM,KAAK,UAAgBG,GAA+B,UAAU,EAM1H,IAJD,MAAM,QAAQF,CAAa,IAAmBA,EAAA,CAC/CA,CAAA,GAGEA,EAAc,OAAS,GAAE,CAErB,MAAAG,EAAmBH,EAAc,QAEnC,GAAAG,EAAiB,KAAO,qBAAsB,CAC1CA,EAAiB,MACrB,KAAK,KAAK,UAAW,CACjB,MAAOA,EAAiB,KAAA,CAC3B,EAED,KAAK,KAAK,UAAW,CACjB,SAAUA,EAAiB,OAAO,CAAC,EACnC,SAAUA,EAAiB,OAAO,CAAC,CAAA,CACtC,EACD,QACJ,CAEIA,EAAiB,KAAO,aAEvB,KAAA,KAAK,YAAaA,CAAgB,CAC3C,CACJ,CAEK,KAAA,cAAgBL,EAAe,MAAA,GAAW,EACnD,CACJ,CAMC,MAAO,CAEA/C,EAA0C,KAAK,+BAA+B,KAAK,cAAc,GAAG,EAExG,MAAMqD,EAAchD,EAA0C,mBAAmB,cAAe,CAAA,EAAI,WAAW,EAIxG,OAFQ,KAAK,KAAKgD,CAAO,CAGpC,CAMC,MAAM,SAAU,CAEb,GAAI,KAAK,SAAepC,EAA2C,UAAW,OAEzE,KAAA,OAAaA,EAA2C,WAEvD,MAAAqC,EAAqB,CAACC,EAASC,IAAS,CACpC,MAAAC,EAAYC,GAAQ,CAEjB,KAAA,OAAazC,EAA2C,aAE7DuC,EAAOE,CAAK,CAAA,EAGX,KAAA,OAAO,mBAAmB,OAAO,EACjC,KAAA,OAAO,KAAK,QAASD,CAAQ,EAElC,MAAME,EAAoB,IAAI,CAEtB3D,EAA0C,QAAQ,+BAA+B,KAAK,OAAO,UAAU,KAAK,cAAc,IAAI,EAE7H,KAAA,OAAO,eAAe,QAASyD,CAAQ,EAE5C,MAAMG,EAAqBvD,EAA0C,mBAAmB,iBAAkB,CACtG,KAAK,YACL,KAAK,SACN,oBAAoB,EAEjBwD,EAAoBnB,GAAU,CAE3B,GAAGnC,GAA2CmC,CAAO,EAAG,CAEzD,KAAK,WAAW,EAAI,EAEpB,MAAMoB,EAAe,gCAEjB9D,EAA0C,OAAO,0BAA0B,KAAK,cAAc,WAAW8D,CAAY,EAAE,EAE3HN,EAAOM,CAAY,CAAA,SACZpB,EAAQ,WAAa,KAAK,SAAW,GAAGA,EAAQ,QAAQ,OAAS,KAAK,SAAW,GAAGA,EAAQ,QAAQ,SAAW,KAAK,QAAS,CAEpI,KAAK,WAAW,EAAI,EAEpB,MAAMoB,EAAe,6CAA6CpB,EAAQ,QAAQ,QAAQ,KAAK,OAAO,KAElG1C,EAA0C,OAAO,0BAA0B,KAAK,cAAc,WAAW8D,CAAY,EAAE,EAE3HN,EAAOM,CAAY,CAAA,MAGf9D,EAA0C,QAAQ,+BAA+B0C,EAAQ,QAAQ,UAAU,KAAK,cAAc,iBAAiBA,EAAQ,QAAQ,GAAG,EAEjK,KAAA,OAAazB,EAA2C,UAE7D,KAAK,KAAK,SAAS,EAEXsC,GACZ,EAGC,KAAA,KAAK,UAAWM,CAAgB,EAErC,KAAK,KAAKD,CAAc,CAAA,EAGvB,KAAA,OAAO,KAAK,UAAWD,CAAiB,EAE7C,KAAK,OAAO,GAAG,QAAS,KAAK,cAAc,KAAK,IAAI,CAAC,EAEhD,KAAA,OAAO,QAAQ,KAAK,KAAM,KAAK,KAAM,KAAK,OAAQ,KAAK,OAAO,CAAA,EAGjE,MAAA,IAAI,QAAQL,CAAkB,CACxC,CAGC,MAAM,WAAY,CAEf,MAAM,KAAK,sBAEPtD,EAA0C,QAAQ,2BAA2B,KAAK,cAAc,KAAK,EAEpG,KAAA,OAAaiB,EAA2C,aAE7D,KAAK,cAAc,EACnB,KAAK,aAAa,EACd,GAAA,CAEA,MAAM,KAAK,eACC,CAEhB,CACJ,CAGC,qBAAsB,CAEf,KAAK,OAAO,WAAwB,aAAA,KAAK,OAAO,SAAS,EAE7D,KAAK,OAAO,UAAY,MAC5B,CAGC,qBAAsB,CAEf,KAAK,OAAO,WAAwB,aAAA,KAAK,OAAO,SAAS,EAE7D,KAAK,OAAO,UAAY,MAC5B,CAGC,qBAAsB,CAEd,KAAK,OAAO,YACZ,KAAA,OAAO,UAAY,WAAW,KAAK,KAAK,KAAK,IAAI,EAAG,KAAK,YAAY,EAC9E,CAQC,MAAM,WAAW8C,EAAQ,GAAOC,EAAc,GAAM,CAEjD,GAAI,KAAK,SAAe/C,EAA2C,cAAgB,CAAC8C,EAC7E,MAAA,GAIHC,IACC,KAAA,OAAa/C,EAA2C,eAE7D,MAAM,KAAK,sBAEX,MAAM,KAAK,sBACL,MAAAgD,EAAsBV,GAAU,CAElC,KAAK,KAAK,aAAc,IAAIA,EAAQ,EAAI,CAAC,EAEzC,KAAK,cAAc,CAAA,EAGhB,OAAA,IAAI,QAAQU,CAAkB,CACzC,CAWC,MAAM,wBAAyB,CAExB,SAAS,kBAAoB,UAGxB,KAAA,WAAW,GAAiB,EAAU,EAG3C,SAAS,kBAAoB,WAAW,KAAK,UAAU,CAC/D,CAQC,KAAKZ,EAAS,CAEX,KAAK,oBAAoB,EAEnB,MAAAa,EAAc,KAAK,MAEnBC,EAAoB,WAAW,KAAK,WAAW,KAAK,KAAMD,CAAW,EAAG,KAAK,OAAO,EAErF,YAAA,cAAc,KAAKC,CAAiB,EAEzC,KAAK,oBAAoB,EAElB,KAAK,OAAO,MAAMd,EAAchD,EAA0C,kBAAkB,CACvG,CAKC,WAAW+D,EAAe,CAEvB,GAAI,OAAO,KAAK,qBAAqB,EAAIA,EAAe,CAEhD,GAAA,KAAK,SAAenD,EAA2C,cAAgB,KAAK,SAAeA,EAA2C,cAAe,CACzJjB,EAA0C,OAAO,uDAAuD,KAAK,cAAc,GAAG,EAClI,MACJ,CAEA,KAAK,oBAAoB,EAErBA,EAA0C,QAAQ,kBAAkB,KAAK,cAAc,cAAc,EAIzG,KAAK,OAAO,YAChB,CACJ,CAGC,iBAAkB,CAEf,KAAK,oBAAoB,EAEpB,KAAA,sBAAwB,KAAK,MAElC,KAAK,oBAAoB,EAEpB,KAAA,OAAO,mBAAmB,OAAO,EAEtC,KAAK,OAAO,GAAG,QAAS,KAAK,cAAc,KAAK,IAAI,CAAC,CACzD,CAGC,oBAAqB,CAElB,KAAK,KAAK,YAAY,EAEtB,KAAK,oBAAoB,EAErB,KAAK,SAAeiB,EAA2C,eAE/D,KAAK,oBAAoB,EAEzB,KAAK,mBAAmB,EAEnB,KAAA,OAAaA,EAA2C,aAEzDjB,EAA0C,QAAQ,sBAAsB,KAAK,cAAc,IAAI,IAG/F,KAAK,SAAeiB,EAA2C,WAC/DjB,EAA0C,OAAO,oBAAoB,KAAK,cAAc,wCAAwC,KAAK,kBAAoB,GAAI,WAAW,EAEvK,KAAA,OAAaiB,EAA2C,aAExD,KAAK,OAAO,YACZ,KAAA,OAAO,UAAY,WAAW,KAAK,UAAU,KAAK,IAAI,EAAG,KAAK,iBAAiB,GAE5F,CAGC,cAAcyC,EAAO,CAKlB,GAAI,SAAOA,EAAU,KAGjB,IAAAA,EAAM,OAAS,YAAa,CACxB1D,EAA0C,OAAO,sCAAsC,KAAK,IAAI,IAAI,EACxG,MACJ,CAEI,GAAA0D,EAAM,OAAS,YAAa,CAExB1D,EAA0C,OAAO0D,EAAM,OAAO,EAClE,MACJ,CAEI1D,EAA0C,OAAO,2BAA2B,KAAK,cAAc,OAAQ0D,CAAK,EACpH,CACJ,CACA,IACAW,GAA2C7B,GAQ3C,MAAM8B,GAA2C,SAASjB,EAAS,CACxD,MAAA,OAAQA,GAAW,UAAWA,CACzC,EAIMkB,GAA4C,SAASlB,EAAS,CACzD,MAAA,EAAE,OAAQA,IAAY,WAAYA,CAC7C,EAqBI,MAAMmB,WAAiDhD,EAAAA,YAAqB,CAe3E,YAAYiB,EAAaC,EAASjB,EAAMC,EAAWf,EAA2C,KAAMgB,EAAahB,EAA2C,iBAAkBiB,EAAcjB,EAA2C,QAASgC,EAAmBhC,EAA2C,cAAeiC,EAAwBjC,EAA2C,UAAWkC,EAAgBlC,EAA2C,YAAY,CAEzc,QAEN,KAAK,oBAAsB,GAE3B,KAAK,UAAY,EAEjB,KAAK,iBAAmB,GAEnB,KAAA,eAAiB,IAAQ8D,GAE9B,KAAK,WAAa,IAAQJ,GAA0C5B,EAAaC,EAASjB,EAAMC,EAAMC,EAAQC,EAASe,EAAcC,EAAmBC,CAAS,CACrK,CAMC,MAAM,SAAU,CAEb,MAAM6B,EAAS,MAAM,KAAK,eAAe,QAAQ,EAC7C,GAAA,CAEA,GAAI,KAAK,WAAW,SAAezD,EAA2C,UAAW,OAEzF,KAAK,WAAW,GAAG,YAAa,KAAK,SAAS,KAAK,IAAI,CAAC,EAExD,KAAK,WAAW,GAAG,UAAW,KAAK,qBAAqB,KAAK,IAAI,CAAC,EAE7D,KAAA,WAAW,GAAG,UAAW,KAAK,KAAK,KAAK,KAAM,WAAW,CAAC,EAC/D,KAAK,WAAW,GAAG,aAAc,KAAK,uBAAuB,KAAK,IAAI,CAAC,EAElE,KAAA,WAAW,GAAG,QAAS,KAAK,KAAK,KAAK,KAAM,OAAO,CAAC,EAEnD,MAAA,KAAK,WAAW,SAAQ,QAChC,CACSyD,GACX,CACJ,CAQC,MAAM,WAAWX,EAAQ,GAAOY,EAAsB,GAAO,CAE1D,MAAMD,EAAS,MAAM,KAAK,eAAe,QAAQ,EAC7C,GAAA,CACKC,IAED,KAAK,mBAAmB,EAExB,KAAK,oBAAsB,IAGrB,UAAAnF,KAAS,KAAK,iBAAiB,CAE/B,MAAAoF,EAAkB,KAAK,iBAAiBpF,CAAK,EACnCoF,EAAA,IAAI,MAAM,sBAAsB,CAAC,EAE1C,OAAA,KAAK,iBAAiBpF,CAAK,CACtC,CAEA,OAAO,MAAM,KAAK,WAAW,WAAWuE,CAAK,CAAA,QAC/C,CACSW,GACX,CACJ,CASC,MAAM,QAAQxE,KAAWC,EAAY,CAElC,GAAI,KAAK,WAAW,SAAec,EAA2C,UAC9E,MAAM,IAAI,MAAM,oDAAoD,KAAK,WAAW,IAAI,IAAI,EAE5F,KAAK,WAAa,EAElB,MAAM4D,EAAK,KAAK,UAEVxB,EAAchD,EAA0C,mBAAmBH,EAAQC,EAAY0E,CAAE,EAEjGD,EAAmBrB,GAAU,CAE/B,KAAK,iBAAiBsB,CAAE,EAAI,CAACnB,EAAOzB,IAAO,CAGvCsB,EADIG,GAGIzB,CAFK,CAED,EAGX,KAAA,WAAW,KAAKoB,CAAO,CAAA,EAG/B,OAAGrD,EAA0C,QAAQ,oBAAoBE,CAAM,SAAS,KAAK,WAAW,IAAI,GAAG,EAEzG,IAAI,QAAQ0E,CAAe,CACtC,CAWC,MAAM,UAAU1E,KAAWC,EAAY,CAE/B,KAAK,oBAAoBD,CAAM,SAAQ,oBAAoBA,CAAM,EAAI,IAAI,KAE9E,KAAK,oBAAoBA,CAAM,EAAE,IAAI,KAAK,UAAUC,CAAU,CAAC,EAE/D,MAAM2E,EAAc,MAAM,KAAK,QAAQ5E,EAAQ,GAAGC,CAAU,EAEtD4E,EAAe,CACjB,QAAS,MACT,OAAA7E,EACA,OAAQ,CACJ,GAAGC,EACH2E,CACJ,CAAA,EAGC,KAAA,KAAK,eAAgBC,CAAY,CAC1C,CAWC,MAAM,YAAY7E,KAAWC,EAAY,CAEtC,GAAI,KAAK,WAAW,SAAec,EAA2C,UAAiB,MAAA,IAAI,MAAM,gEAAgE,KAAK,WAAW,IAAI,IAAI,EAE7L,GAAA,CAAC,KAAK,oBAAoBf,CAAM,EACpC,MAAM,IAAI,MAAM,4BAA4BA,CAAM,0CAA0C,EAEtF,MAAA8E,EAAyB,KAAK,UAAU7E,CAAU,EAExD,GAAI,CAAC,KAAK,oBAAoBD,CAAM,EAAE,IAAI8E,CAAsB,EAChE,MAAM,IAAI,MAAM,4BAA4B9E,CAAM,2DAA2D,EAE7G,KAAK,oBAAoBA,CAAM,EAAE,OAAO8E,CAAsB,EAGxD,MAAA,KAAK,QAAQ9E,EAAO,QAAQ,aAAc,cAAc,EAAG,GAAGC,CAAU,EAE1EH,EAA0C,OAAO,sBAAsB,OAAOE,CAAM,CAAC,cAAc8E,CAAsB,eAAe,CAChJ,CASC,MAAM,sBAAuB,CAEtBhF,EAA0C,OAAO,iBAAiB,KAAK,WAAW,cAAc,IAAI,EAExG,MAAMiF,EAAyB,CAAA,EAErB,UAAA/E,KAAU,KAAK,oBAAoB,CAEzC,UAAWgF,KAAiB,KAAK,oBAAoBhF,CAAM,EAAE,SAAS,CAE5D,MAAAC,EAAa,KAAK,MAAM+E,CAAa,EAE3CD,EAAuB,KAAK,KAAK,UAAU/E,EAAQ,GAAGC,CAAU,CAAC,CACrE,CAEM,MAAA,QAAQ,IAAI8E,CAAsB,CAC5C,CAEIA,EAAuB,OAAS,GAAOjF,EAA0C,OAAO,YAAYiF,EAAuB,MAAM,gCAAgC,KAAK,WAAW,cAAc,GAAG,CAC1M,CAQC,SAAS5B,EAAS,CAEV,GAAGkB,GAA2ClB,CAAO,EAAG,CAErDrD,EAA0C,OAAO,8BAA8BqD,EAAQ,MAAM,WAAW,KAAK,WAAW,IAAI,GAAG,EAE9H,KAAA,KAAK,eAAgBA,CAAO,EAEjC,MACJ,CAEA,GAAIA,EAAQ,KAAO,KACb,MAAA,IAAI,MAAM,wDAAwD,EAExE,MAAMuB,EAAkB,KAAK,iBAAiBvB,EAAQ,EAAE,EAExD,GAAI,CAACuB,EACC,MAAA,IAAI,MAAM,sDAAsD,EAE/D,OAAA,KAAK,iBAAiBvB,EAAQ,EAAE,EAE/BiB,GAA0CjB,CAAO,EACzDuB,EAAgB,IAAI,MAAMvB,EAAQ,MAAM,OAAO,CAAC,EAGhCuB,EAAA,OAAWvB,EAAQ,MAAM,CAC7C,CAMC,wBAAyB,CAEtB,KAAK,KAAK,cAAc,EAEd,UAAA8B,KAAc,KAAK,iBAAiB,CAEpC,MAAAP,EAAkB,KAAK,iBAAiBO,CAAU,EAExCP,EAAA,IAAI,MAAM,iBAAiB,CAAC,EAErC,OAAA,KAAK,iBAAiBO,CAAU,CAC3C,CACJ,CACJ,CACA,IACAC,GAA2CZ","x_google_ignoreList":[0,1,2,3,4,5]}