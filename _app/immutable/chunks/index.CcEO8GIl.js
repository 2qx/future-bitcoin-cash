import{$ as S,e as y,M as A,w as L}from"./SvelteToast.svelte_svelte_type_style_lang.X-URgChw.js";async function x(n){if("clipboard"in navigator)await navigator.clipboard.writeText(n);else{const e=document.createElement("input");e.type="text",e.disabled=!0,e.style.setProperty("position","fixed"),e.style.setProperty("z-index","-100"),e.style.setProperty("pointer-events","none"),e.style.setProperty("opacity","0"),e.value=n,document.body.appendChild(e),e.click(),e.select(),document.execCommand("copy"),document.body.removeChild(e)}}const j=(n,e)=>{async function t(){if(s)try{await x(s),n.dispatchEvent(new CustomEvent("svelte-copy",{detail:s}))}catch(o){n.dispatchEvent(new CustomEvent("svelte-copy:error",{detail:o}))}}let i=typeof e=="string"?["click"]:[e.events].flat(1),s=typeof e=="string"?e:e.text;return i.forEach(o=>{n.addEventListener(o,t,!0)}),{update:o=>{const c=typeof o=="string"?["click"]:[o.events].flat(1),u=typeof o=="string"?o:o.text,a=c.filter(l=>!i.includes(l)),f=i.filter(l=>!c.includes(l));a.forEach(l=>{n.addEventListener(l,t,!0)}),f.forEach(l=>{n.removeEventListener(l,t,!0)}),i=c,s=u},destroy:()=>{i.forEach(o=>{n.removeEventListener(o,t,!0)})}}};function m(n,e,t,i){Object.defineProperty(n,e,{get:t,set:i,enumerable:!0,configurable:!0})}const w={client:S("electrum-cash:client "),cluster:S("electrum-cash:cluster"),errors:S("electrum-cash:error  "),warning:S("electrum-cash:warning"),network:S("electrum-cash:network"),ping:S("electrum-cash:pulses ")};w.client.color="2";w.cluster.color="3";w.errors.color="9";w.warning.color="13";w.network.color="4";w.ping.color="8";var r=w;class M{static buildRequestObject(e,t,i){return JSON.stringify({method:e,params:t,id:i})}static get versionRegexp(){return/^\d+(\.\d+)+$/}static get statementDelimiter(){return`
`}}var $=M,g={};m(g,"isVersionRejected",()=>O);m(g,"isVersionNegotiated",()=>_);const O=function(n){return"error"in n},_=function(n){return"software"in n&&"protocol"in n};var P={};m(P,"ElectrumTransport",()=>E);m(P,"DefaultParameters",()=>d);var N={};m(N,"ClusterOrder",()=>T);m(N,"ClusterDistribution",()=>C);m(N,"ClusterStatus",()=>p);m(N,"ClientState",()=>v);m(N,"ConnectionStatus",()=>h);var T;(function(n){n[n.RANDOM=0]="RANDOM",n[n.PRIORITY=1]="PRIORITY"})(T||(T={}));var C;(function(n){n[n.ALL=0]="ALL"})(C||(C={}));var p;(function(n){n[n.DISABLED=0]="DISABLED",n[n.DEGRADED=1]="DEGRADED",n[n.READY=2]="READY"})(p||(p={}));var v;(function(n){n[n.UNAVAILABLE=0]="UNAVAILABLE",n[n.AVAILABLE=1]="AVAILABLE"})(v||(v={}));var h;(function(n){n[n.DISCONNECTED=0]="DISCONNECTED",n[n.CONNECTED=1]="CONNECTED",n[n.DISCONNECTING=2]="DISCONNECTING",n[n.CONNECTING=3]="CONNECTING",n[n.RECONNECTING=4]="RECONNECTING"})(h||(h={}));const E={TCP:{Port:50001,Scheme:"tcp"},TCP_TLS:{Port:50002,Scheme:"tcp_tls"},WS:{Port:50003,Scheme:"ws"},WSS:{Port:50004,Scheme:"wss"}},d={PORT:E.TCP_TLS.Port,TRANSPORT_SCHEME:E.TCP_TLS.Scheme,RECONNECT:15e3,TIMEOUT:12e4,PING_INTERVAL:3e3,CLUSTER_CONFIDENCE:1,CLUSTER_DISTRIBUTION:C.ALL,CLUSTER_ORDER:T.RANDOM};class U extends y.EventEmitter{connect(e,t,i,s){if(this.tcpSocket||this.webSocket)throw new Error("Cannot initiate a new socket connection when an existing connection exists");this.timers.disconnect=setTimeout(()=>this.disconnectOnTimeout(e,t,s),s),this.once("connect",this.clearDisconnectTimerOnTimeout);const o={[E.TCP.Scheme]:"a TCP Socket",[E.TCP_TLS.Scheme]:"an encrypted TCP socket",[E.WS.Scheme]:"a WebSocket",[E.WSS.Scheme]:"an encrypted WebSocket"};if(r.network(`Initiating ${o[i]} connection to '${e}:${t}'.`),i===E.TCP.Scheme||i===E.TCP_TLS.Scheme){if(i===E.TCP_TLS.Scheme){const c={rejectUnauthorized:!1};$4QiMX$isIP(e)||(c.serverName=e),this.tcpSocket=$4QiMX$connect(t,e,c),this.tcpSocket.once("secureConnect",()=>{if(!(this.tcpSocket instanceof $4QiMX$TLSSocket))return;this.tcpSocket.authorizationError==="DEPTH_ZERO_SELF_SIGNED_CERT"&&r.warning(`Connection to ${e}:${t} uses a self-signed certificate`)}),this.tcpSocket.on("secureConnect",this.onConnect.bind(this,o[i],e,t))}else this.tcpSocket=$4QiMX$connect1({host:e,port:t}),this.tcpSocket.on("connect",this.onConnect.bind(this,o[i],e,t));this.tcpSocket.setEncoding("utf8"),this.tcpSocket.setKeepAlive(!0,0),this.tcpSocket.setNoDelay(!0),this.tcpSocket.on("error",this.eventForwarders.tcpError)}else if(i===E.WS.Scheme||i===E.WSS.Scheme)i===E.WSS.Scheme?this.webSocket=new L(`wss://${e}:${t}`):this.webSocket=new L(`ws://${e}:${t}`),this.webSocket.addEventListener("open",this.onConnect.bind(this,o[i],e,t)),this.webSocket.addEventListener("error",this.eventForwarders.wsError);else throw new Error("Incorrect transport specified")}onConnect(e,t,i){this.onConnectHasRun||(r.network(`Established ${e} connection with '${t}:${i}'.`),typeof this.tcpSocket<"u"?(this.tcpSocket.addListener("close",this.eventForwarders.disconnect),this.tcpSocket.addListener("data",this.eventForwarders.tcpData)):typeof this.webSocket<"u"&&(this.webSocket.addEventListener("close",this.eventForwarders.disconnect),this.webSocket.addEventListener("message",this.eventForwarders.wsData)),this.onConnectHasRun=!0,this.emit("connect"))}clearDisconnectTimerOnTimeout(){this.timers.disconnect&&clearTimeout(this.timers.disconnect)}disconnect(){if(this.clearDisconnectTimerOnTimeout(),this.tcpSocket)this.tcpSocket.removeListener("close",this.eventForwarders.disconnect),this.tcpSocket.removeListener("data",this.eventForwarders.tcpData),this.tcpSocket.removeListener("error",this.eventForwarders.tcpError),this.tcpSocket.destroy(),this.tcpSocket=void 0;else if(this.webSocket)try{this.webSocket.removeEventListener("close",this.eventForwarders.disconnect),this.webSocket.removeEventListener("message",this.eventForwarders.wsData),this.webSocket.removeEventListener("error",this.eventForwarders.wsError),this.webSocket.close()}catch{}finally{this.webSocket=void 0}this.onConnectHasRun=!1,this.emit("disconnect")}write(e,t){if(this.tcpSocket)return this.tcpSocket.write(e,t);if(this.webSocket)return this.webSocket.send(e,t),!0;throw new Error("Cannot write to socket when there is no active connection")}disconnectOnTimeout(e,t,i){this.removeListener("connect",this.clearDisconnectTimerOnTimeout);const s={code:"ETIMEDOUT",message:`Connection to '${e}:${t}' timed out after ${i} milliseconds`};this.emit("error",s),this.disconnect()}constructor(...e){super(...e),this.timers={},this.onConnectHasRun=!1,this.eventForwarders={disconnect:()=>this.emit("disconnect"),tcpData:t=>this.emit("data",t),wsData:t=>this.emit("data",`${t.data}
`),tcpError:t=>this.emit("error",t),wsError:t=>this.emit("error",t.error)}}}var B=U;class V extends y.EventEmitter{constructor(e,t,i,s=d.PORT,o=d.TRANSPORT_SCHEME,c=d.TIMEOUT,u=d.PING_INTERVAL,a=d.RECONNECT){if(super(),this.application=e,this.version=t,this.host=i,this.port=s,this.scheme=o,this.timeout=c,this.pingInterval=u,this.reconnectInterval=a,this.timers={},this.verifications=[],this.status=h.DISCONNECTED,this.messageBuffer="",!$.versionRegexp.test(t))throw new Error(`Provided version string (${t}) is not a valid protocol version number.`);this.createSocket(),typeof document<"u"&&document.addEventListener("visibilitychange",this.handleVisibilityChange.bind(this))}get hostIdentifier(){return`${this.host}:${this.port}`}createSocket(){this.socket=new B,this.socket.on("connect",this.onSocketConnect.bind(this)),this.socket.on("disconnect",this.onSocketDisconnect.bind(this)),this.socket.on("data",this.parseMessageChunk.bind(this))}destroySocket(){this.socket.disconnect()}parseMessageChunk(e){for(this.lastReceivedTimestamp=Date.now(),this.verifications.forEach(t=>clearTimeout(t)),this.verifications.length=0,this.messageBuffer+=e;this.messageBuffer.includes($.statementDelimiter);){const t=this.messageBuffer.split($.statementDelimiter);for(;t.length>1;){const i=String(t.shift());let s=JSON.parse(i);for(Array.isArray(s)||(s=[s]);s.length>0;){const o=s.shift();if(o.id==="versionNegotiation"){o.error?this.emit("version",{error:o.error}):this.emit("version",{software:o.result[0],protocol:o.result[1]});continue}o.id!=="keepAlive"&&this.emit("statement",o)}}this.messageBuffer=t.shift()||""}}ping(){r.ping(`Sending keep-alive ping to '${this.hostIdentifier}'`);const e=$.buildRequestObject("server.ping",[],"keepAlive");return this.send(e)}async connect(){if(this.status===h.CONNECTED)return;this.status=h.CONNECTING;const e=(t,i)=>{const s=c=>{this.status=h.DISCONNECTED,i(c)};this.socket.removeAllListeners("error"),this.socket.once("error",s);const o=()=>{r.network(`Requesting protocol version ${this.version} with '${this.hostIdentifier}'.`),this.socket.removeListener("error",s);const c=$.buildRequestObject("server.version",[this.application,this.version],"versionNegotiation"),u=a=>{if(O(a)){this.disconnect(!0);const f="unsupported protocol version.";r.errors(`Failed to connect with ${this.hostIdentifier} due to ${f}`),i(f)}else if(a.protocol!==this.version&&`${a.protocol}.0`!==this.version&&`${a.protocol}.0.0`!==this.version){this.disconnect(!0);const f=`incompatible protocol version negotiated (${a.protocol} !== ${this.version}).`;r.errors(`Failed to connect with ${this.hostIdentifier} due to ${f}`),i(f)}else r.network(`Negotiated protocol version ${a.protocol} with '${this.hostIdentifier}', powered by ${a.software}.`),this.status=h.CONNECTED,this.emit("connect"),t()};this.once("version",u),this.send(c)};this.socket.once("connect",o),this.socket.on("error",this.onSocketError.bind(this)),this.socket.connect(this.host,this.port,this.scheme,this.timeout)};await new Promise(e)}async reconnect(){await this.clearReconnectTimer(),r.network(`Trying to reconnect to '${this.hostIdentifier}'..`),this.status=h.RECONNECTING,this.destroySocket(),this.createSocket();try{await this.connect()}catch{}}clearReconnectTimer(){this.timers.reconnect&&clearTimeout(this.timers.reconnect),this.timers.reconnect=void 0}clearKeepAliveTimer(){this.timers.keepAlive&&clearTimeout(this.timers.keepAlive),this.timers.keepAlive=void 0}setupKeepAliveTimer(){this.timers.keepAlive||(this.timers.keepAlive=setTimeout(this.ping.bind(this),this.pingInterval))}async disconnect(e=!1,t=!0){if(this.status===h.DISCONNECTED&&!e)return!1;t&&(this.status=h.DISCONNECTING),await this.clearKeepAliveTimer(),await this.clearReconnectTimer();const i=s=>{this.once("disconnect",()=>s(!0)),this.destroySocket()};return new Promise(i)}async handleVisibilityChange(){document.visibilityState==="hidden"&&this.disconnect(!0,!1),document.visibilityState==="visible"&&this.reconnect()}send(e){this.clearKeepAliveTimer();const t=Date.now(),i=setTimeout(this.verifySend.bind(this,t),this.timeout);return this.verifications.push(i),this.setupKeepAliveTimer(),this.socket.write(e+$.statementDelimiter)}verifySend(e){if(Number(this.lastReceivedTimestamp)<e){if(this.status===h.DISCONNECTED||this.status===h.DISCONNECTING){r.errors(`Tried to verify already disconnected connection to '${this.hostIdentifier}'`);return}this.clearKeepAliveTimer(),r.network(`Connection to '${this.hostIdentifier}' timed out.`),this.socket.disconnect()}}onSocketConnect(){this.clearReconnectTimer(),this.lastReceivedTimestamp=Date.now(),this.setupKeepAliveTimer(),this.socket.removeAllListeners("error"),this.socket.on("error",this.onSocketError.bind(this))}onSocketDisconnect(){this.emit("disconnect"),this.clearKeepAliveTimer(),this.status===h.DISCONNECTING?(this.clearReconnectTimer(),this.removeAllListeners(),this.status=h.DISCONNECTED,r.network(`Disconnected from '${this.hostIdentifier}'.`)):(this.status===h.CONNECTED&&r.errors(`Connection with '${this.hostIdentifier}' was closed, trying to reconnect in ${this.reconnectInterval/1e3} seconds.`),this.status=h.DISCONNECTED,this.timers.reconnect||(this.timers.reconnect=setTimeout(this.reconnect.bind(this),this.reconnectInterval)))}onSocketError(e){if(!(typeof e>"u")){if(e.code==="EAI_AGAIN"){r.errors(`Failed to look up DNS records for '${this.host}'.`);return}if(e.code==="ETIMEDOUT"){r.errors(e.message);return}r.errors(`Unknown network error ('${this.hostIdentifier}'): `,e)}}}var G=V;const F=function(n){return"id"in n&&"error"in n},W=function(n){return!("id"in n)&&"method"in n};class K extends y.EventEmitter{constructor(e,t,i,s=d.PORT,o=d.TRANSPORT_SCHEME,c=d.TIMEOUT,u=d.PING_INTERVAL,a=d.RECONNECT){super(),this.subscriptionMethods={},this.requestId=0,this.requestResolvers={},this.connectionLock=new A,this.connection=new G(e,t,i,s,o,c,u,a)}async connect(){const e=await this.connectionLock.acquire();try{if(this.connection.status===h.CONNECTED)return;this.connection.on("statement",this.response.bind(this)),this.connection.on("connect",this.resubscribeOnConnect.bind(this)),this.connection.on("connect",this.emit.bind(this,"connected")),this.connection.on("disconnect",this.onConnectionDisconnect.bind(this)),this.connection.on("error",this.emit.bind(this,"error")),await this.connection.connect()}finally{e()}}async disconnect(e=!1,t=!1){const i=await this.connectionLock.acquire();try{t||(this.removeAllListeners(),this.subscriptionMethods={});for(const s in this.requestResolvers){const o=this.requestResolvers[s];o(new Error("Manual disconnection")),delete this.requestResolvers[s]}return await this.connection.disconnect(e)}finally{i()}}async request(e,...t){if(this.connection.status!==h.CONNECTED)throw new Error(`Unable to send request to a disconnected server '${this.connection.host}'.`);this.requestId+=1;const i=this.requestId,s=$.buildRequestObject(e,t,i),o=c=>{this.requestResolvers[i]=(u,a)=>{c(u||a)},this.connection.send(s)};return r.network(`Sending request '${e}' to '${this.connection.host}'`),new Promise(o)}async subscribe(e,...t){this.subscriptionMethods[e]||(this.subscriptionMethods[e]=new Set),this.subscriptionMethods[e].add(JSON.stringify(t));const i=await this.request(e,...t),s={jsonrpc:"2.0",method:e,params:[...t,i]};this.emit("notification",s)}async unsubscribe(e,...t){if(this.connection.status!==h.CONNECTED)throw new Error(`Unable to send unsubscribe request to a disconnected server '${this.connection.host}'.`);if(!this.subscriptionMethods[e])throw new Error(`Cannot unsubscribe from '${e}' since the method has no subscriptions.`);const i=JSON.stringify(t);if(!this.subscriptionMethods[e].has(i))throw new Error(`Cannot unsubscribe from '${e}' since it has no subscription with the given parameters.`);this.subscriptionMethods[e].delete(i),await this.request(e.replace(".subscribe",".unsubscribe"),...t),r.client(`Unsubscribed from '${String(e)}' for the '${i}' parameters.`)}async resubscribeOnConnect(){r.client(`Connected to '${this.connection.hostIdentifier}'.`);const e=[];for(const t in this.subscriptionMethods){for(const i of this.subscriptionMethods[t].values()){const s=JSON.parse(i);e.push(this.subscribe(t,...s))}await Promise.all(e)}e.length>0&&r.client(`Restored ${e.length} previous subscriptions for '${this.connection.hostIdentifier}'`)}response(e){if(W(e)){r.client(`Received notification for '${e.method}' from '${this.connection.host}'`),this.emit("notification",e);return}if(e.id===null)throw new Error("Internal error: Received an RPC response with ID null.");const t=this.requestResolvers[e.id];if(!t)throw new Error("Internal error: Callback for response not available.");delete this.requestResolvers[e.id],F(e)?t(new Error(e.error.message)):t(void 0,e.result)}onConnectionDisconnect(){this.emit("disconnected");for(const e in this.requestResolvers){const t=this.requestResolvers[e];t(new Error("Connection lost")),delete this.requestResolvers[e]}}}var H=K;class z extends y.EventEmitter{constructor(e,t,i=d.CLUSTER_CONFIDENCE,s=d.CLUSTER_DISTRIBUTION,o=d.CLUSTER_ORDER,c=d.TIMEOUT,u=d.PING_INTERVAL,a=d.RECONNECT){super(),this.application=e,this.version=t,this.confidence=i,this.distribution=s,this.order=o,this.timeout=c,this.pingInterval=u,this.reconnectInterval=a,this.clients={},this.connections=0,this.notifications={},this.status=p.DISABLED,this.requestCounter=0,this.requestPromises={},this.requestLock=new A,this.responseLock=new A,r.cluster(`Initialized empty cluster (${i} of ${s||"ALL"})`),(s===C.ALL||i/s<=.5)&&r.warning(`Subscriptions might return multiple valid responses when confidence (${i}) is less than 51% of distribution.`)}async addServer(e,t=d.PORT,i=d.TRANSPORT_SCHEME,s=!0){const o=new H(this.application,this.version,e,t,i,this.timeout,this.pingInterval,this.reconnectInterval),c=`${e}:${t}`;this.clients[c]={state:v.UNAVAILABLE,connection:o};const u=()=>{const l=Math.max(this.confidence,this.distribution);this.connections>=l?this.status!==p.READY&&(this.status=p.READY,this.emit("ready"),r.cluster(`Cluster status is ready (currently ${this.connections} of ${l} connections available.)`)):this.connections>=this.confidence?this.status!==p.DEGRADED&&(this.status=p.DEGRADED,this.emit("degraded"),r.cluster(`Cluster status is degraded (only ${this.connections} of ${l} connections available.)`)):this.status!==p.DISABLED&&(this.status=p.DISABLED,this.emit("disabled"),r.cluster(`Cluster status is disabled (only ${this.connections} of the ${l} connections are available.)`))},a=async()=>{try{o.connection.status===h.CONNECTED&&(this.clients[c].state===v.UNAVAILABLE&&(this.connections+=1),this.clients[c].state=v.AVAILABLE,u())}catch{}},f=()=>{this.clients[c].state===v.AVAILABLE&&(this.connections-=1),this.clients[c].state=v.UNAVAILABLE,u()};if(o.connection.on("connect",a.bind(this)),o.connection.on("disconnect",f.bind(this)),o.on("notification",this.handleSubscriptionNotifications.bind(this,c)),s)try{await o.connect()}catch(l){r.cluster(`Failed to connect with ${e}: ${l}`)}}async request(e,...t){if(this.status===p.DISABLED)throw new Error(`Cannot request '${e}' when available clients (${this.connections}) is less than required confidence (${this.confidence}).`);const i=await this.requestLock.acquire();let s=0;try{this.requestCounter+=1,s=this.requestCounter}finally{i()}this.requestPromises[s]=[];const o=Object.keys(this.clients).filter(f=>this.clients[f].state===v.AVAILABLE);let c=0,u=this.distribution||o.length;for(this.status===p.DEGRADED&&(u=o.length);c<u;){let f=0;this.order===T.RANDOM&&(f=Math.floor(Math.random()*o.length));const[l]=o.splice(f,1),k=this.clients[l].connection.request(e,...t);this.requestPromises[s].push(k),c+=1}const a=(f,l)=>{const k=async()=>{const D={};let R=0;for(const q in this.requestPromises[s]){let I;try{const b=[this.requestPromises[s][q],Promise.resolve(void 0)];I=await Promise.race(b)}catch{R+=1;continue}if(I!==void 0){const b=JSON.stringify(I);if(R+=1,D[b]===void 0?D[b]=1:D[b]+=1,D[b]===this.confidence){r.cluster(`Validated response for '${e}' with sufficient integrity (${this.confidence}).`),f(I);return}}}if(R===this.requestPromises[s].length){l(new Error(`Unable to complete request for '${e}', response failed to reach sufficient integrity (${this.confidence}).`));return}setTimeout(k,1e3)};k()};return new Promise(a)}async subscribe(e,...t){for(const i in this.clients){const s=this.clients[i].connection;try{await s.subscribe(e,...t)}catch{}}}async unsubscribe(e,...t){const i=[];for(const s in this.clients){const o=this.clients[s].connection;i.push(o.unsubscribe(e,...t))}await Promise.all(i)}async handleSubscriptionNotifications(e,t){const i=await this.responseLock.acquire();try{const s=JSON.stringify(t);this.notifications[s]===void 0&&(this.notifications[s]=new Set),this.notifications[s].add(e),this.notifications[s].size===this.confidence&&(r.cluster(`Validated notification for '${t.method}' with sufficient integrity (${this.confidence}).`),this.emit("notification",t),setTimeout(this.dismissSubscriptionNotification.bind(this,s),this.timeout)),this.notifications[s].size===this.distribution&&this.dismissSubscriptionNotification(s)}finally{i()}}async dismissSubscriptionNotification(e){delete this.notifications[e]}async ready(){const e=Date.now(),t=i=>{const s=()=>{if(this.status===p.READY){i(!0);return}if(Date.now()-e>this.timeout){i(!1);return}setTimeout(s,50)};s()};return new Promise(t)}async startup(){r.cluster("Starting up cluster.");const e=[];for(const t in this.clients){const{host:i,port:s,scheme:o}=this.clients[t].connection.connection;this.clients[t].state===v.AVAILABLE?r.warning(`Called startup(), but server ${i}:${s} is already connected`):e.push(this.addServer(i,s,o))}return Promise.all(e)}async shutdown(e=!1){r.cluster("Shutting down cluster.");const t=[],i=s=>{this.once("disabled",()=>s(Promise.all(t)));for(const o in this.clients)t.push(this.clients[o].connection.disconnect(!0,e))};return new Promise(i)}}var Y=z;export{Y as $,T as a,E as b,j as c};
//# sourceMappingURL=index.CcEO8GIl.js.map
