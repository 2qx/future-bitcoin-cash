{"version":3,"file":"vault.UqEITsNb.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/each.js","../../../../../../../lib/dist/main/coupon.js","../../../../../../../lib/dist/main/vault.js"],"sourcesContent":["import { transition_in, transition_out } from './transitions.js';\nimport { run_all } from './utils.js';\n\n// general each functions:\n\nexport function ensure_array_like(array_like_or_iterator) {\n\treturn array_like_or_iterator?.length !== undefined\n\t\t? array_like_or_iterator\n\t\t: Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nexport function destroy_block(block, lookup) {\n\tblock.d(1);\n\tlookup.delete(block.key);\n}\n\n/** @returns {void} */\nexport function outro_and_destroy_block(block, lookup) {\n\ttransition_out(block, 1, 1, () => {\n\t\tlookup.delete(block.key);\n\t});\n}\n\n/** @returns {void} */\nexport function fix_and_destroy_block(block, lookup) {\n\tblock.f();\n\tdestroy_block(block, lookup);\n}\n\n/** @returns {void} */\nexport function fix_and_outro_and_destroy_block(block, lookup) {\n\tblock.f();\n\toutro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nexport function update_keyed_each(\n\told_blocks,\n\tdirty,\n\tget_key,\n\tdynamic,\n\tctx,\n\tlist,\n\tlookup,\n\tnode,\n\tdestroy,\n\tcreate_each_block,\n\tnext,\n\tget_context\n) {\n\tlet o = old_blocks.length;\n\tlet n = list.length;\n\tlet i = o;\n\tconst old_indexes = {};\n\twhile (i--) old_indexes[old_blocks[i].key] = i;\n\tconst new_blocks = [];\n\tconst new_lookup = new Map();\n\tconst deltas = new Map();\n\tconst updates = [];\n\ti = n;\n\twhile (i--) {\n\t\tconst child_ctx = get_context(ctx, list, i);\n\t\tconst key = get_key(child_ctx);\n\t\tlet block = lookup.get(key);\n\t\tif (!block) {\n\t\t\tblock = create_each_block(key, child_ctx);\n\t\t\tblock.c();\n\t\t} else if (dynamic) {\n\t\t\t// defer updates until all the DOM shuffling is done\n\t\t\tupdates.push(() => block.p(child_ctx, dirty));\n\t\t}\n\t\tnew_lookup.set(key, (new_blocks[i] = block));\n\t\tif (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n\t}\n\tconst will_move = new Set();\n\tconst did_move = new Set();\n\t/** @returns {void} */\n\tfunction insert(block) {\n\t\ttransition_in(block, 1);\n\t\tblock.m(node, next);\n\t\tlookup.set(block.key, block);\n\t\tnext = block.first;\n\t\tn--;\n\t}\n\twhile (o && n) {\n\t\tconst new_block = new_blocks[n - 1];\n\t\tconst old_block = old_blocks[o - 1];\n\t\tconst new_key = new_block.key;\n\t\tconst old_key = old_block.key;\n\t\tif (new_block === old_block) {\n\t\t\t// do nothing\n\t\t\tnext = new_block.first;\n\t\t\to--;\n\t\t\tn--;\n\t\t} else if (!new_lookup.has(old_key)) {\n\t\t\t// remove old block\n\t\t\tdestroy(old_block, lookup);\n\t\t\to--;\n\t\t} else if (!lookup.has(new_key) || will_move.has(new_key)) {\n\t\t\tinsert(new_block);\n\t\t} else if (did_move.has(old_key)) {\n\t\t\to--;\n\t\t} else if (deltas.get(new_key) > deltas.get(old_key)) {\n\t\t\tdid_move.add(new_key);\n\t\t\tinsert(new_block);\n\t\t} else {\n\t\t\twill_move.add(old_key);\n\t\t\to--;\n\t\t}\n\t}\n\twhile (o--) {\n\t\tconst old_block = old_blocks[o];\n\t\tif (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n\t}\n\twhile (n) insert(new_blocks[n - 1]);\n\trun_all(updates);\n\treturn new_blocks;\n}\n\n/** @returns {void} */\nexport function validate_each_keys(ctx, list, get_context, get_key) {\n\tconst keys = new Map();\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst key = get_key(get_context(ctx, list, i));\n\t\tif (keys.has(key)) {\n\t\t\tlet value = '';\n\t\t\ttry {\n\t\t\t\tvalue = `with value '${String(key)}' `;\n\t\t\t} catch (e) {\n\t\t\t\t// can't stringify\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} ${value}are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n","import { encodeDataPush, hash256, bigIntToVmNumber, CashAddressNetworkPrefix, hexToBin, lockingBytecodeToCashAddress } from \"@bitauth/libauth\";\nexport class Coupon {\n    amount;\n    lock;\n    static lockingScript = \"00cc00c694a16900c788c08bc39c\";\n    /**\n     * Return the address for a Coupon\n     *\n     *\n     * @param amount - the threshold amount (sats) to redeem coupon\n     * @param lock - the vault locking bytecode\n     * @param network - the network prefix\n     */\n    static getAddress(amount, lock, network = CashAddressNetworkPrefix.mainnet) {\n        let lockingBytecode = this.getLockingBytecode(amount, lock);\n        let addr = lockingBytecodeToCashAddress(lockingBytecode, network, { tokenSupport: true });\n        if (typeof addr !== 'string')\n            throw (addr);\n        return addr;\n    }\n    /**\n     * Return the unlockingBytecode for a Coupon\n     *\n     *\n     * @param amount - the threshold amount (sats) to redeem coupon\n     * @param lock - the vault locking bytecode\n     */\n    static getUnlockingBytecode(amount, lock) {\n        const amountVm = encodeDataPush(bigIntToVmNumber(BigInt(amount)));\n        const lockVm = encodeDataPush(lock);\n        const lockingScript = hexToBin(this.lockingScript);\n        return new Uint8Array([\n            ...lockVm,\n            ...amountVm,\n            ...lockingScript\n        ]);\n    }\n    /**\n     * Return the lockingBytecode for a Coupon\n     *\n     *\n     * @param amount - the threshold amount (sats) to redeem coupon\n     * @param lock - the Vault locking bytecode\n     */\n    static getLockingBytecode(amount, lock) {\n        return new Uint8Array([\n            ...hexToBin(\"aa20\"),\n            ...hash256(this.getUnlockingBytecode(amount, lock)),\n            ...hexToBin(\"87\")\n        ]);\n    }\n    static asInput(amount, lock, utxo) {\n        return {\n            outpointIndex: utxo.vout,\n            outpointTransactionHash: hexToBin(utxo.txid),\n            sequenceNumber: 0,\n            unlockingBytecode: this.getUnlockingBytecode(amount, lock),\n        };\n    }\n}\n//# sourceMappingURL=coupon.js.map","import { encodeDataPush, hash256, bigIntToVmNumber, CashAddressNetworkPrefix, hexToBin, lockingBytecodeToCashAddress } from \"@bitauth/libauth\";\nimport { Coupon } from \"./coupon\";\nexport class Vault {\n    locktime;\n    static lockingScript = \"c0d3c0d0a06376b17568c0cec0d188c0cdc0c788c0d0c0c693c0d3c0cc939c77\";\n    /**\n     * Return the token address for a Vault\n     *\n     *\n     * @param time - block time of the vault lock\n     * @param network - cashaddress network prefix\n     */\n    static getAddress(time, network = CashAddressNetworkPrefix.mainnet) {\n        let lockingBytecode = this.getLockingBytecode(time);\n        let addr = lockingBytecodeToCashAddress(lockingBytecode, network, { tokenSupport: true });\n        if (typeof addr !== 'string')\n            throw (addr);\n        return addr;\n    }\n    /**\n     * Return the coupon for a Vault at specified amount\n     *\n     *\n     * @param amount - the threshold amount (sats) to redeem coupon\n     * @param time - block time of the vault lock\n     */\n    static getCoupon(amount, time, network = CashAddressNetworkPrefix.mainnet) {\n        return Coupon.getAddress(amount, this.getLockingBytecode(time), network);\n    }\n    /**\n     * Return the unlockingBytecode for a Vault\n     *\n     *\n     * @param time - block time of the vault lock\n     */\n    static getUnlockingBytecode(time) {\n        const locktimeVm = encodeDataPush(bigIntToVmNumber(BigInt(time)));\n        const lockingScript = hexToBin(this.lockingScript);\n        return new Uint8Array([\n            ...locktimeVm,\n            ...lockingScript\n        ]);\n    }\n    /**\n     * Return the lockingBytecode for a Vault\n     *\n     *\n     * @param time - block time of the vault lock\n     */\n    static getLockingBytecode(time) {\n        return new Uint8Array([\n            ...hexToBin(\"aa20\"),\n            ...hash256(this.getUnlockingBytecode(time)),\n            ...hexToBin(\"87\")\n        ]);\n    }\n    /**\n     * Return an array of staggered block times\n     *\n     *\n     * @param startTime - block time of the vault lock\n     * @param series - power of 10 to stagger the times\n     * @param limit - length of the array to return\n     */\n    static getSeriesTimes(startTime, series = 3, limit = 10) {\n        const step = Math.pow(10, series);\n        const next = startTime - (startTime % step) + step;\n        return Array.from({ length: limit }, (e, i) => next + (step * i));\n    }\n    /**\n     * Return an array of vaults in a series\n     *\n     *\n     * @param startTime - block time of the vault lock\n     * @param series - power of 10 to stagger the times\n     * @param limit - length of the array to return\n     * @param network - cashaddress network prefix\n     */\n    static getSeries(startTime, series, limit, network = CashAddressNetworkPrefix.mainnet) {\n        let seriesTimes = this.getSeriesTimes(startTime, series, limit);\n        return seriesTimes.map(time => { return this.getAddress(time, network); });\n    }\n    /**\n     * Return an array coupons for vaults in a series\n     *\n     *\n     * @param startTime - block time of the vault lock\n     * @param amount - coupon threshold amount\n     * @param series - power of 10 to stagger the times\n     * @param limit - length of the array to return\n     * @param network - cashaddress network prefix\n     */\n    static getCouponSeries(startTime, amount = 1e8, series, limit, network = CashAddressNetworkPrefix.mainnet) {\n        let seriesTimes = this.getSeriesTimes(startTime, series, limit);\n        return seriesTimes.map(time => {\n            return Coupon.getAddress(amount, this.getLockingBytecode(time), network);\n        });\n    }\n    /**\n    * Return an Unspent Transaction Output as an Input\n    *\n    *\n    * @param time - block time of the vault lock\n    * @param utxo - the unspent transaction output being spent.\n    */\n    static asInput(time, utxo) {\n        return {\n            outpointIndex: utxo.vout,\n            outpointTransactionHash: hexToBin(utxo.txid),\n            sequenceNumber: 0,\n            unlockingBytecode: this.getUnlockingBytecode(time),\n        };\n    }\n    /**\n    * Return an Unspent Transaction Output as an Output\n    *\n    *\n    * @param time - block time of the vault lock\n    * @param utxo - the unspent transaction output being spent.\n    * @param placement - the number of sats being placed *into* the vault.\n    */\n    static asOutput(time, utxo, placement) {\n        return {\n            lockingBytecode: this.getLockingBytecode(time),\n            valueSatoshis: BigInt(utxo.satoshis + placement),\n            token: {\n                amount: utxo.token?.amount - BigInt(placement),\n                category: hexToBin(utxo.token?.tokenId),\n                nft: undefined,\n            },\n        };\n    }\n}\n//# sourceMappingURL=vault.js.map"],"names":["ensure_array_like","array_like_or_iterator","Coupon","amount","lock","network","CashAddressNetworkPrefix","lockingBytecode","addr","lockingBytecodeToCashAddress","amountVm","encodeDataPush","bigIntToVmNumber","lockVm","lockingScript","hexToBin","hash256","utxo","Vault","time","locktimeVm","startTime","series","limit","step","next","e","i","placement"],"mappings":"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","x_google_ignoreList":[0]}