{"version":3,"file":"bch.UjQGvx2B.js","sources":["../../../../../../../../node_modules/.pnpm/electrum-cash@3.2.0_patch_hash=rsa26lmws7guuxutou5s7tqy6i/node_modules/electrum-cash/dist/index.mjs","../../../../../../src/lib/images/bch.svg"],"sourcesContent":["import {EventEmitter as $4QiMX$EventEmitter} from \"events\";\nimport {Mutex as $4QiMX$Mutex} from \"async-mutex\";\nimport $4QiMX$debug from \"debug\";\n//import {connect as $4QiMX$connect, TLSSocket as $4QiMX$TLSSocket} from \"tls\";\n//import {isIP as $4QiMX$isIP, connect as $4QiMX$connect1} from \"net\";\nimport {WebSocket as $4QiMX$WebSocket} from \"@monsterbitar/isomorphic-ws\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n// Create the debug logs.\nconst $ef5ba40c8abe5a13$var$debug = {\n    client: (0, $4QiMX$debug)(\"electrum-cash:client \"),\n    cluster: (0, $4QiMX$debug)(\"electrum-cash:cluster\"),\n    errors: (0, $4QiMX$debug)(\"electrum-cash:error  \"),\n    warning: (0, $4QiMX$debug)(\"electrum-cash:warning\"),\n    network: (0, $4QiMX$debug)(\"electrum-cash:network\"),\n    ping: (0, $4QiMX$debug)(\"electrum-cash:pulses \")\n};\n// Set log colors.\n$ef5ba40c8abe5a13$var$debug.client.color = \"2\";\n$ef5ba40c8abe5a13$var$debug.cluster.color = \"3\";\n$ef5ba40c8abe5a13$var$debug.errors.color = \"9\";\n$ef5ba40c8abe5a13$var$debug.warning.color = \"13\";\n$ef5ba40c8abe5a13$var$debug.network.color = \"4\";\n$ef5ba40c8abe5a13$var$debug.ping.color = \"8\";\nvar // Export the logs.\n$ef5ba40c8abe5a13$export$2e2bcd8739ae039 = $ef5ba40c8abe5a13$var$debug;\n\n\n\n/**\n * Grouping of utilities that simplifies implementation of the Electrum protocol.\n *\n * @ignore\n */ class $c78f59d21170b7a6$var$ElectrumProtocol {\n    /**\n\t * Helper function that builds an Electrum request object.\n\t *\n\t * @param {string} method       method to call.\n\t * @param {array}  parameters   method parameters for the call.\n\t * @param {string} requestId    unique string or number referencing this request.\n\t *\n\t * @returns a properly formatted Electrum request string.\n\t */ static buildRequestObject(method, parameters, requestId) {\n        // Return the formatted request object.\n        // NOTE: Electrum either uses JsonRPC strictly or loosely.\n        //       If we specify protocol identifier without being 100% compliant, we risk being disconnected/blacklisted.\n        //       For this reason, we omit the protocol identifier to avoid issues.\n        return JSON.stringify({\n            method: method,\n            params: parameters,\n            id: requestId\n        });\n    }\n    /**\n\t * Constant used to verify if a provided string is a valid version number.\n\t *\n\t * @returns a regular expression that matches valid version numbers.\n\t */ static get versionRegexp() {\n        return /^\\d+(\\.\\d+)+$/;\n    }\n    /**\n\t * Constant used to separate statements/messages in a stream of data.\n\t *\n\t * @returns the delimiter used by Electrum to separate statements.\n\t */ static get statementDelimiter() {\n        return \"\\n\";\n    }\n}\nvar // export the protocol.\n$c78f59d21170b7a6$export$2e2bcd8739ae039 = $c78f59d21170b7a6$var$ElectrumProtocol;\n\n\nvar $a192ea5a4eec42d4$exports = {};\n\n$parcel$export($a192ea5a4eec42d4$exports, \"isVersionRejected\", () => $a192ea5a4eec42d4$export$e1f38ab2b4ebdde6);\n$parcel$export($a192ea5a4eec42d4$exports, \"isVersionNegotiated\", () => $a192ea5a4eec42d4$export$9598f0c76aa41d73);\nconst $a192ea5a4eec42d4$export$e1f38ab2b4ebdde6 = function(object) {\n    return \"error\" in object;\n};\nconst $a192ea5a4eec42d4$export$9598f0c76aa41d73 = function(object) {\n    return \"software\" in object && \"protocol\" in object;\n};\n\n\nvar $5abc8fb342687c03$exports = {};\n\n$parcel$export($5abc8fb342687c03$exports, \"ElectrumTransport\", () => $5abc8fb342687c03$export$d048df559e6d3842);\n$parcel$export($5abc8fb342687c03$exports, \"DefaultParameters\", () => $5abc8fb342687c03$export$f019be48b3aacb1a);\nvar $a58372b18a18806e$exports = {};\n\n$parcel$export($a58372b18a18806e$exports, \"ClusterOrder\", () => $a58372b18a18806e$export$161fe3707f756bf9);\n$parcel$export($a58372b18a18806e$exports, \"ClusterDistribution\", () => $a58372b18a18806e$export$436a960acc41e848);\n$parcel$export($a58372b18a18806e$exports, \"ClusterStatus\", () => $a58372b18a18806e$export$c66b56bc0ff967ca);\n$parcel$export($a58372b18a18806e$exports, \"ClientState\", () => $a58372b18a18806e$export$c4f81c6d30ca200f);\n$parcel$export($a58372b18a18806e$exports, \"ConnectionStatus\", () => $a58372b18a18806e$export$7516420eb880ab68);\n// Disable indent rule for this file because it is broken (https://github.com/typescript-eslint/typescript-eslint/issues/1824)\n/* eslint-disable @typescript-eslint/indent */ /**\n * Enum that denotes the ordering to use in an ElectrumCluster.\n * @enum {number}\n * @property {0} RANDOM     Send requests to randomly selected servers in the cluster.\n * @property {1} PRIORITY   Send requests to servers in the cluster in the order they were added.\n */ var $a58372b18a18806e$export$161fe3707f756bf9;\n(function(ClusterOrder) {\n    ClusterOrder[ClusterOrder[\"RANDOM\"] = 0] = \"RANDOM\";\n    ClusterOrder[ClusterOrder[\"PRIORITY\"] = 1] = \"PRIORITY\";\n})($a58372b18a18806e$export$161fe3707f756bf9 || ($a58372b18a18806e$export$161fe3707f756bf9 = {}));\nvar $a58372b18a18806e$export$436a960acc41e848;\n(function(ClusterDistribution) {\n    ClusterDistribution[ClusterDistribution[\"ALL\"] = 0] = \"ALL\";\n})($a58372b18a18806e$export$436a960acc41e848 || ($a58372b18a18806e$export$436a960acc41e848 = {}));\nvar $a58372b18a18806e$export$c66b56bc0ff967ca;\n(function(ClusterStatus) {\n    ClusterStatus[ClusterStatus[\"DISABLED\"] = 0] = \"DISABLED\";\n    ClusterStatus[ClusterStatus[\"DEGRADED\"] = 1] = \"DEGRADED\";\n    ClusterStatus[ClusterStatus[\"READY\"] = 2] = \"READY\";\n})($a58372b18a18806e$export$c66b56bc0ff967ca || ($a58372b18a18806e$export$c66b56bc0ff967ca = {}));\nvar $a58372b18a18806e$export$c4f81c6d30ca200f;\n(function(ClientState) {\n    ClientState[ClientState[\"UNAVAILABLE\"] = 0] = \"UNAVAILABLE\";\n    ClientState[ClientState[\"AVAILABLE\"] = 1] = \"AVAILABLE\";\n})($a58372b18a18806e$export$c4f81c6d30ca200f || ($a58372b18a18806e$export$c4f81c6d30ca200f = {}));\nvar $a58372b18a18806e$export$7516420eb880ab68;\n(function(ConnectionStatus) {\n    ConnectionStatus[ConnectionStatus[\"DISCONNECTED\"] = 0] = \"DISCONNECTED\";\n    ConnectionStatus[ConnectionStatus[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    ConnectionStatus[ConnectionStatus[\"DISCONNECTING\"] = 2] = \"DISCONNECTING\";\n    ConnectionStatus[ConnectionStatus[\"CONNECTING\"] = 3] = \"CONNECTING\";\n    ConnectionStatus[ConnectionStatus[\"RECONNECTING\"] = 4] = \"RECONNECTING\";\n})($a58372b18a18806e$export$7516420eb880ab68 || ($a58372b18a18806e$export$7516420eb880ab68 = {}));\n\n\nconst $5abc8fb342687c03$export$d048df559e6d3842 = {\n    TCP: {\n        Port: 50001,\n        Scheme: \"tcp\"\n    },\n    TCP_TLS: {\n        Port: 50002,\n        Scheme: \"tcp_tls\"\n    },\n    WS: {\n        Port: 50003,\n        Scheme: \"ws\"\n    },\n    WSS: {\n        Port: 50004,\n        Scheme: \"wss\"\n    }\n};\nconst $5abc8fb342687c03$export$f019be48b3aacb1a = {\n    // Port number for TCP TLS connections\n    PORT: $5abc8fb342687c03$export$d048df559e6d3842.TCP_TLS.Port,\n    // Transport to connect to the Electrum server\n    TRANSPORT_SCHEME: $5abc8fb342687c03$export$d048df559e6d3842.TCP_TLS.Scheme,\n    // How long to wait before attempting to reconnect, in milliseconds.\n    RECONNECT: 15000,\n    // How long to wait for network operations before following up, in milliseconds.\n    TIMEOUT: 120000,\n    // Time between ping messages, in milliseconds. Pinging keeps the connection alive.\n    // The reason for pinging this frequently is to detect connection problems early.\n    PING_INTERVAL: 3000,\n    // How many servers are required before we trust information provided.\n    CLUSTER_CONFIDENCE: 1,\n    // How many servers we send requests to.\n    CLUSTER_DISTRIBUTION: (0, $a58372b18a18806e$export$436a960acc41e848).ALL,\n    // What order we select servers to send requests to.\n    CLUSTER_ORDER: (0, $a58372b18a18806e$export$161fe3707f756bf9).RANDOM\n};\n\n\n\n\n\n\n\n\n\n/**\n * Isomorphic Socket interface supporting TCP sockets and WebSockets (Node and browser).\n * The interface is a subset of the TLSSocket interface with some slight modifications.\n * It can be expanded when more socket functionality is needed in the rest of the\n * electrum-cash code. Changes from the TLSSocket interface (besides it being a subset):\n * - Event 'close' -> 'disconnect'\n * - New function socket.disconnect()\n *\n * @ignore\n */ class $ea64e414b68fe23b$var$ElectrumSocket extends (0, $4QiMX$EventEmitter) {\n    /**\n\t * Connect to host:port using the specified transport\n\t *\n\t * @param {string} host              Fully qualified domain name or IP address of the host\n\t * @param {number} port              Network port for the host to connect to\n\t * @param {TransportScheme} scheme   Transport scheme to use\n\t * @param {number} timeout           If no connection is established after `timeout` ms, the connection is terminated\n\t *\n\t * @throws {Error} if an incorrect transport scheme is specified\n\t */ connect(host, port, scheme, timeout) {\n        // Check that no existing socket exists before initiating a new connection.\n        if (this.tcpSocket || this.webSocket) throw new Error(\"Cannot initiate a new socket connection when an existing connection exists\");\n        // Set a timer to force disconnect after `timeout` seconds\n        this.timers.disconnect = setTimeout(()=>this.disconnectOnTimeout(host, port, timeout), timeout);\n        // Remove the timer if a connection is successfully established\n        this.once(\"connect\", this.clearDisconnectTimerOnTimeout);\n        // Define how to refer to the connection scheme in debug output.\n        const socketTypes = {\n            [(0, $5abc8fb342687c03$export$d048df559e6d3842).TCP.Scheme]: \"a TCP Socket\",\n            [(0, $5abc8fb342687c03$export$d048df559e6d3842).TCP_TLS.Scheme]: \"an encrypted TCP socket\",\n            [(0, $5abc8fb342687c03$export$d048df559e6d3842).WS.Scheme]: \"a WebSocket\",\n            [(0, $5abc8fb342687c03$export$d048df559e6d3842).WSS.Scheme]: \"an encrypted WebSocket\"\n        };\n        // Log that we are trying to establish a connection.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Initiating ${socketTypes[scheme]} connection to '${host}:${port}'.`);\n        if (scheme === (0, $5abc8fb342687c03$export$d048df559e6d3842).TCP.Scheme || scheme === (0, $5abc8fb342687c03$export$d048df559e6d3842).TCP_TLS.Scheme) {\n            if (scheme === (0, $5abc8fb342687c03$export$d048df559e6d3842).TCP_TLS.Scheme) {\n                // Initialize connection options.\n                const connectionOptions = {\n                    rejectUnauthorized: false\n                };\n                // If the hostname is not an IP address..\n                if (!$4QiMX$isIP(host)) // Set the servername option which enables support for SNI.\n                // NOTE: SNI enables a server that hosts multiple domains to provide the appropriate TLS certificate.\n                connectionOptions.serverName = host;\n                // Initialize this.tcpSocket (allowing self-signed certificates).\n                this.tcpSocket = $4QiMX$connect(port, host, connectionOptions);\n                // Add a 'secureConnect' listener that checks the authorization status of\n                // the socket, and logs a warning when it uses a self signed certificate.\n                this.tcpSocket.once(\"secureConnect\", ()=>{\n                    // Cannot happen, since this event callback *only* exists on TLSSocket\n                    if (!(this.tcpSocket instanceof $4QiMX$TLSSocket)) return;\n                    // Force cast authorizationError from Error to string (through unknown)\n                    // because it is incorrectly typed as an Error\n                    const authorizationError = this.tcpSocket.authorizationError;\n                    if (authorizationError === \"DEPTH_ZERO_SELF_SIGNED_CERT\") (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).warning(`Connection to ${host}:${port} uses a self-signed certificate`);\n                });\n                // Trigger successful connection events.\n                this.tcpSocket.on(\"secureConnect\", this.onConnect.bind(this, socketTypes[scheme], host, port));\n            } else {\n                // Initialize this.tcpSocket.\n                this.tcpSocket = $4QiMX$connect1({\n                    host: host,\n                    port: port\n                });\n                // Trigger successful connection events.\n                this.tcpSocket.on(\"connect\", this.onConnect.bind(this, socketTypes[scheme], host, port));\n            }\n            // Configure encoding.\n            this.tcpSocket.setEncoding(\"utf8\");\n            // Enable persistent connections with an initial delay of 0.\n            this.tcpSocket.setKeepAlive(true, 0);\n            // Disable buffering of outgoing data.\n            this.tcpSocket.setNoDelay(true);\n            // Forward the encountered errors.\n            this.tcpSocket.on(\"error\", this.eventForwarders.tcpError);\n        } else if (scheme === (0, $5abc8fb342687c03$export$d048df559e6d3842).WS.Scheme || scheme === (0, $5abc8fb342687c03$export$d048df559e6d3842).WSS.Scheme) {\n            if (scheme === (0, $5abc8fb342687c03$export$d048df559e6d3842).WSS.Scheme) // Initialize this.webSocket (rejecting self-signed certificates).\n            // We reject self-signed certificates to match functionality of browsers.\n            this.webSocket = new (0, $4QiMX$WebSocket)(`wss://${host}:${port}`);\n            else // Initialize this.webSocket.\n            this.webSocket = new (0, $4QiMX$WebSocket)(`ws://${host}:${port}`);\n            // Trigger successful connection events.\n            this.webSocket.addEventListener(\"open\", this.onConnect.bind(this, socketTypes[scheme], host, port));\n            // Forward the encountered errors.\n            this.webSocket.addEventListener(\"error\", this.eventForwarders.wsError);\n        } else // Throw an error if an incorrect transport is specified\n        throw new Error(\"Incorrect transport specified\");\n    }\n    /**\n\t * Sets up forwarding of events related to the connection.\n\t *\n\t * @param {string} connectionType   Name of the connection/transport type, used for logging.\n\t * @param {string} host             Fully qualified domain name or IP address of the host\n\t * @param {number} port             Network port for the host to connect to\n\t */ onConnect(connectionType, host, port) {\n        // If the onConnect function has already run, do not execute it again.\n        if (this.onConnectHasRun) return;\n        // Log that the connection has been established.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Established ${connectionType} connection with '${host}:${port}'.`);\n        if (typeof this.tcpSocket !== \"undefined\") {\n            // Forward the socket events\n            this.tcpSocket.addListener(\"close\", this.eventForwarders.disconnect);\n            this.tcpSocket.addListener(\"data\", this.eventForwarders.tcpData);\n        } else if (typeof this.webSocket !== \"undefined\") {\n            // Forward the socket events\n            this.webSocket.addEventListener(\"close\", this.eventForwarders.disconnect);\n            this.webSocket.addEventListener(\"message\", this.eventForwarders.wsData);\n        }\n        // Indicate that the onConnect function has run.\n        this.onConnectHasRun = true;\n        // Emit the connect event.\n        this.emit(\"connect\");\n    }\n    /**\n\t * Clears the disconnect timer if it is still active.\n\t */ clearDisconnectTimerOnTimeout() {\n        // Clear the retry timer if it is still active.\n        if (this.timers.disconnect) clearTimeout(this.timers.disconnect);\n    }\n    /**\n\t * Forcibly terminate the connection.\n\t *\n\t * @throws {Error} if no connection was found\n\t */ disconnect() {\n        // Clear the disconnect timer so that the socket does not try to disconnect again later.\n        this.clearDisconnectTimerOnTimeout();\n        // Handle disconnect based differently depending on socket type.\n        if (this.tcpSocket) {\n            // Remove all event forwarders.\n            this.tcpSocket.removeListener(\"close\", this.eventForwarders.disconnect);\n            this.tcpSocket.removeListener(\"data\", this.eventForwarders.tcpData);\n            this.tcpSocket.removeListener(\"error\", this.eventForwarders.tcpError);\n            // Terminate the connection.\n            this.tcpSocket.destroy();\n            // Remove the stored socket.\n            this.tcpSocket = undefined;\n        } else if (this.webSocket) try {\n            // Remove all event forwarders.\n            this.webSocket.removeEventListener(\"close\", this.eventForwarders.disconnect);\n            this.webSocket.removeEventListener(\"message\", this.eventForwarders.wsData);\n            this.webSocket.removeEventListener(\"error\", this.eventForwarders.wsError);\n            // Gracefully terminate the connection.\n            this.webSocket.close();\n        } catch (ignored) {\n        // close() will throw an error if the connection has not been established yet.\n        // We ignore this error, since no similar error gets thrown in the TLS Socket.\n        } finally{\n            // Remove the stored socket regardless of any thrown errors.\n            this.webSocket = undefined;\n        }\n        // Indicate that the onConnect function has not run and it has to be run again.\n        this.onConnectHasRun = false;\n        // Emit a disconnect event\n        this.emit(\"disconnect\");\n    }\n    /**\n\t * Write data to the socket\n\t *\n\t * @param {Uint8Array | string} data   Data to be written to the socket\n\t * @param {function} callback          Callback function to be called when the write has completed\n\t *\n\t * @throws {Error} if no connection was found\n\t * @returns true if the message was fully flushed to the socket, false if part of the message\n\t * is queued in the user memory\n\t */ write(data, callback) {\n        if (this.tcpSocket) // Write data to the TLS Socket and return the status indicating whether the\n        // full message was flushed to the socket\n        return this.tcpSocket.write(data, callback);\n        if (this.webSocket) {\n            // Write data to the WebSocket\n            this.webSocket.send(data, callback);\n            // WebSockets always fit everything in a single request, so we return true\n            return true;\n        }\n        // Throw an error if no active connection is found\n        throw new Error(\"Cannot write to socket when there is no active connection\");\n    }\n    /**\n\t * Force a disconnection if no connection is established after `timeout` milliseconds.\n\t *\n\t * @param {string} host      Host of the connection that timed out\n\t * @param {number} port      Port of the connection that timed out\n\t * @param {number} timeout   Elapsed milliseconds\n\t */ disconnectOnTimeout(host, port, timeout) {\n        // Remove the connect listener.\n        this.removeListener(\"connect\", this.clearDisconnectTimerOnTimeout);\n        // Create a new timeout error.\n        const timeoutError = {\n            code: \"ETIMEDOUT\",\n            message: `Connection to '${host}:${port}' timed out after ${timeout} milliseconds`\n        };\n        // Emit an error event so that connect is rejected upstream.\n        this.emit(\"error\", timeoutError);\n        // Forcibly disconnect to clean up the connection on timeout\n        this.disconnect();\n    }\n    constructor(...args){\n        super(...args);\n        // Declare timers for keep-alive pings and reconnection\n        this.timers = {};\n        // Initialize boolean that indicates whether the onConnect function has run (initialize to false).\n        this.onConnectHasRun = false;\n        // Initialize event forwarding functions.\n        this.eventForwarders = {\n            disconnect: ()=>this.emit(\"disconnect\"),\n            tcpData: (data)=>this.emit(\"data\", data),\n            wsData: (event)=>this.emit(\"data\", `${event.data}\\n`),\n            tcpError: (err)=>this.emit(\"error\", err),\n            wsError: (event)=>this.emit(\"error\", event.error)\n        };\n    }\n}\nvar // export the socket.\n$ea64e414b68fe23b$export$2e2bcd8739ae039 = $ea64e414b68fe23b$var$ElectrumSocket;\n\n\n\n/**\n * Wrapper around TLS/WSS sockets that gracefully separates a network stream into Electrum protocol messages.\n *\n * @ignore\n */ class $1326c18f93f95fee$var$ElectrumConnection extends (0, $4QiMX$EventEmitter) {\n    /**\n\t * Sets up network configuration for an Electrum client connection.\n\t *\n\t * @param {string} application       your application name, used to identify to the electrum host.\n\t * @param {string} version           protocol version to use with the host.\n\t * @param {string} host              fully qualified domain name or IP number of the host.\n\t * @param {number} port              the network port of the host.\n\t * @param {TransportScheme} scheme   the transport scheme to use for connection\n\t * @param {number} timeout           how long network delays we will wait for before taking action, in milliseconds.\n\t * @param {number} pingInterval      the time between sending pings to the electrum host, in milliseconds.\n\t * @param {number} reconnectInterval the time between reconnection attempts to the electrum host, in milliseconds.\n\t *\n\t * @throws {Error} if `version` is not a valid version string.\n\t */ constructor(application, version, host, port = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).PORT, scheme = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).TRANSPORT_SCHEME, timeout = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).TIMEOUT, pingInterval = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).PING_INTERVAL, reconnectInterval = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).RECONNECT){\n        // Initialize the event emitter.\n        super();\n        this.application = application;\n        this.version = version;\n        this.host = host;\n        this.port = port;\n        this.scheme = scheme;\n        this.timeout = timeout;\n        this.pingInterval = pingInterval;\n        this.reconnectInterval = reconnectInterval;\n        this.// Declare timers for keep-alive pings and reconnection\n        timers = {};\n        this.// Initialize an empty array of connection verification timers.\n        // eslint-disable-next-line no-undef\n        verifications = [];\n        this.// Initialize the connected flag to false to indicate that there is no connection\n        status = (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTED;\n        this.// Initialize messageBuffer to an empty string\n        messageBuffer = \"\";\n        // Check if the provided version is a valid version number.\n        if (!(0, $c78f59d21170b7a6$export$2e2bcd8739ae039).versionRegexp.test(version)) // Throw an error since the version number was not valid.\n        throw new Error(`Provided version string (${version}) is not a valid protocol version number.`);\n        // Create an initial network socket.\n        this.createSocket();\n        // Handle visibility changes when run in a browser environment.\n        if (typeof document !== \"undefined\") document.addEventListener(\"visibilitychange\", this.handleVisibilityChange.bind(this));\n    }\n    /**\n\t * Returns a string for the host identifier for usage in debug messages.\n\t */ get hostIdentifier() {\n        return `${this.host}:${this.port}`;\n    }\n    /**\n\t * Create and configures a fresh socket and attaches all relevant listeners.\n\t */ createSocket() {\n        // Initialize a new ElectrumSocket\n        this.socket = new (0, $ea64e414b68fe23b$export$2e2bcd8739ae039)();\n        // Set up handlers for connection and disconnection.\n        this.socket.on(\"connect\", this.onSocketConnect.bind(this));\n        this.socket.on(\"disconnect\", this.onSocketDisconnect.bind(this));\n        // Set up handler for incoming data.\n        this.socket.on(\"data\", this.parseMessageChunk.bind(this));\n    }\n    /**\n\t * Shuts down and destroys the current socket.\n\t */ destroySocket() {\n        // Close the socket connection and destroy the socket.\n        this.socket.disconnect();\n    }\n    /**\n\t * Assembles incoming data into statements and hands them off to the message parser.\n\t *\n\t * @param {string} data   data to append to the current message buffer, as a string.\n\t *\n\t * @throws {SyntaxError} if the passed statement parts are not valid JSON.\n\t */ parseMessageChunk(data) {\n        // Update the timestamp for when we last received data.\n        this.lastReceivedTimestamp = Date.now();\n        // Clear and remove all verification timers.\n        this.verifications.forEach((timer)=>clearTimeout(timer));\n        this.verifications.length = 0;\n        // Add the message to the current message buffer.\n        this.messageBuffer += data;\n        // Check if the new message buffer contains the statement delimiter.\n        while(this.messageBuffer.includes((0, $c78f59d21170b7a6$export$2e2bcd8739ae039).statementDelimiter)){\n            // Split message buffer into statements.\n            const statementParts = this.messageBuffer.split((0, $c78f59d21170b7a6$export$2e2bcd8739ae039).statementDelimiter);\n            // For as long as we still have statements to parse..\n            while(statementParts.length > 1){\n                // Move the first statement to its own variable.\n                const currentStatementList = String(statementParts.shift());\n                // Parse the statement into an object or list of objects.\n                let statementList = JSON.parse(currentStatementList);\n                // Wrap the statement in an array if it is not already a batched statement list.\n                if (!Array.isArray(statementList)) statementList = [\n                    statementList\n                ];\n                // For as long as there is statements in the result set..\n                while(statementList.length > 0){\n                    // Move the first statement from the batch to its own variable.\n                    const currentStatement = statementList.shift();\n                    // If the current statement is a version negotiation response..\n                    if (currentStatement.id === \"versionNegotiation\") {\n                        if (currentStatement.error) // Then emit a failed version negotiation response signal.\n                        this.emit(\"version\", {\n                            error: currentStatement.error\n                        });\n                        else // Emit a successful version negotiation response signal.\n                        this.emit(\"version\", {\n                            software: currentStatement.result[0],\n                            protocol: currentStatement.result[1]\n                        });\n                        continue;\n                    }\n                    // If the current statement is a keep-alive response..\n                    if (currentStatement.id === \"keepAlive\") continue;\n                    // Emit the statements for handling higher up in the stack.\n                    this.emit(\"statement\", currentStatement);\n                }\n            }\n            // Store the remaining statement as the current message buffer.\n            this.messageBuffer = statementParts.shift() || \"\";\n        }\n    }\n    /**\n\t * Sends a keep-alive message to the host.\n\t *\n\t * @returns true if the ping message was fully flushed to the socket, false if\n\t * part of the message is queued in the user memory\n\t */ ping() {\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).ping(`Sending keep-alive ping to '${this.hostIdentifier}'`);\n        // Craft a keep-alive message.\n        const message = (0, $c78f59d21170b7a6$export$2e2bcd8739ae039).buildRequestObject(\"server.ping\", [], \"keepAlive\");\n        // Send the keep-alive message.\n        const status = this.send(message);\n        // Return the ping status.\n        return status;\n    }\n    /**\n\t * Initiates the network connection negotiates a protocol version. Also emits the 'connect' signal if successful.\n\t *\n\t * @throws {Error} if the socket connection fails.\n\t * @returns a promise resolving when the connection is established\n\t */ async connect() {\n        // If we are already connected return true.\n        if (this.status === (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED) return;\n        // Indicate that the connection is connecting\n        this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTING;\n        // Define a function to wrap connection as a promise.\n        const connectionResolver = (resolve, reject)=>{\n            const rejector = (error)=>{\n                // Set the status back to disconnected\n                this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTED;\n                // Reject with the error as reason\n                reject(error);\n            };\n            // Replace previous error handlers to reject the promise on failure.\n            this.socket.removeAllListeners(\"error\");\n            this.socket.once(\"error\", rejector);\n            // Define a function to wrap version negotiation as a callback.\n            const versionNegotiator = ()=>{\n                // Write a log message to show that we have started version negotiation.\n                (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Requesting protocol version ${this.version} with '${this.hostIdentifier}'.`);\n                // remove the one-time error handler since no error was detected.\n                this.socket.removeListener(\"error\", rejector);\n                // Build a version negotiation message.\n                const versionMessage = (0, $c78f59d21170b7a6$export$2e2bcd8739ae039).buildRequestObject(\"server.version\", [\n                    this.application,\n                    this.version\n                ], \"versionNegotiation\");\n                // Define a function to wrap version validation as a function.\n                const versionValidator = (version)=>{\n                    // Check if version negotiation failed.\n                    if ((0, $a192ea5a4eec42d4$export$e1f38ab2b4ebdde6)(version)) {\n                        // Disconnect from the host.\n                        this.disconnect(true);\n                        // Declare an error message.\n                        const errorMessage = \"unsupported protocol version.\";\n                        // Log the error.\n                        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(`Failed to connect with ${this.hostIdentifier} due to ${errorMessage}`);\n                        // Reject the connection with false since version negotiation failed.\n                        reject(errorMessage);\n                    } else if (version.protocol !== this.version && `${version.protocol}.0` !== this.version && `${version.protocol}.0.0` !== this.version) {\n                        // Disconnect from the host.\n                        this.disconnect(true);\n                        // Declare an error message.\n                        const errorMessage = `incompatible protocol version negotiated (${version.protocol} !== ${this.version}).`;\n                        // Log the error.\n                        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(`Failed to connect with ${this.hostIdentifier} due to ${errorMessage}`);\n                        // Reject the connection with false since version negotiation failed.\n                        reject(errorMessage);\n                    } else {\n                        // Write a log message.\n                        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Negotiated protocol version ${version.protocol} with '${this.hostIdentifier}', powered by ${version.software}.`);\n                        // Set connection status to connected\n                        this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED;\n                        // Emit a connect event now that the connection is usable.\n                        this.emit(\"connect\");\n                        // Resolve the connection promise since we successfully connected and negotiated protocol version.\n                        resolve();\n                    }\n                };\n                // Listen for version negotiation once.\n                this.once(\"version\", versionValidator);\n                // Send the version negotiation message.\n                this.send(versionMessage);\n            };\n            // Prepare the version negotiation.\n            this.socket.once(\"connect\", versionNegotiator);\n            // Set up handler for network errors.\n            this.socket.on(\"error\", this.onSocketError.bind(this));\n            // Connect to the server.\n            this.socket.connect(this.host, this.port, this.scheme, this.timeout);\n        };\n        // Wait until connection is established and version negotiation succeeds.\n        await new Promise(connectionResolver);\n    }\n    /**\n\t * Restores the network connection.\n\t */ async reconnect() {\n        // If a reconnect timer is set, remove it\n        await this.clearReconnectTimer();\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Trying to reconnect to '${this.hostIdentifier}'..`);\n        // Set the status to reconnecting for more accurate log messages.\n        this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).RECONNECTING;\n        // Destroy and recreate the socket to get a clean slate.\n        this.destroySocket();\n        this.createSocket();\n        try {\n            // Try to connect again.\n            await this.connect();\n        } catch (error) {\n        // Do nothing as the error should be handled via the disconnect and error signals.\n        }\n    }\n    /**\n\t * Removes the current reconnect timer.\n\t */ clearReconnectTimer() {\n        // If a reconnect timer is set, remove it\n        if (this.timers.reconnect) clearTimeout(this.timers.reconnect);\n        // Reset the timer reference.\n        this.timers.reconnect = undefined;\n    }\n    /**\n\t * Removes the current keep-alive timer.\n\t */ clearKeepAliveTimer() {\n        // If a keep-alive timer is set, remove it\n        if (this.timers.keepAlive) clearTimeout(this.timers.keepAlive);\n        // Reset the timer reference.\n        this.timers.keepAlive = undefined;\n    }\n    /**\n\t * Initializes the keep alive timer loop.\n\t */ setupKeepAliveTimer() {\n        // If the keep-alive timer loop is not currently set up..\n        if (!this.timers.keepAlive) // Set a new keep-alive timer.\n        this.timers.keepAlive = setTimeout(this.ping.bind(this), this.pingInterval);\n    }\n    /**\n\t * Tears down the current connection and removes all event listeners on disconnect.\n\t *\n\t * @param {boolean} force         disconnect even if the connection has not been fully established yet.\n\t * @param {boolean} intentional   update connection state if disconnect is intentional.\n\t *\n\t * @returns true if successfully disconnected, or false if there was no connection.\n\t */ async disconnect(force = false, intentional = true) {\n        // Return early when there is nothing to disconnect from\n        if (this.status === (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTED && !force) // Return false to indicate that there was nothing to disconnect from.\n        return false;\n        // Update connection state if the disconnection is intentional.\n        // NOTE: The state is meant to represent what the client is requesting, but\n        //       is used internally to handle visibility changes in browsers to ensure functional reconnection.\n        if (intentional) // Set connection status to null to indicate tear-down is currently happening.\n        this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTING;\n        // If a keep-alive timer is set, remove it.\n        await this.clearKeepAliveTimer();\n        // If a reconnect timer is set, remove it\n        await this.clearReconnectTimer();\n        const disconnectResolver = (resolve)=>{\n            // Resolve to true after the connection emits a disconnect\n            this.once(\"disconnect\", ()=>resolve(true));\n            // Close the connection and destroy the socket.\n            this.destroySocket();\n        };\n        // Return true to indicate that we disconnected.\n        return new Promise(disconnectResolver);\n    }\n    /**\n\t * Updates connection state based on application visibility.\n\t *\n\t * Some browsers will disconnect network connections when the browser is out of focus,\n\t * which would normally cause our reconnect-on-timeout routines to trigger, but that\n\t * results in a poor user experience since the events are not handled consistently\n\t * and sometimes it can take some time after restoring focus to the browser.\n\t *\n\t * By manually disconnecting when this happens we prevent the default reconnection routines\n\t * and make the behavior consistent across browsers.\n\t */ async handleVisibilityChange() {\n        // Disconnect when application is removed from focus.\n        if (document.visibilityState === \"hidden\") {\n            const forceDisconnect = true;\n            const isIntended = false;\n            this.disconnect(forceDisconnect, isIntended);\n        }\n        // Reconnect when application is returned to focus.\n        if (document.visibilityState === \"visible\") this.reconnect();\n    }\n    /**\n\t * Sends an arbitrary message to the server.\n\t *\n\t * @param {string} message   json encoded request object to send to the server, as a string.\n\t *\n\t * @returns true if the message was fully flushed to the socket, false if part of the message\n\t * is queued in the user memory\n\t */ send(message) {\n        // Remove the current keep-alive timer if it exists.\n        this.clearKeepAliveTimer();\n        // Get the current timestamp in milliseconds.\n        const currentTime = Date.now();\n        // Follow up and verify that the message got sent..\n        const verificationTimer = setTimeout(this.verifySend.bind(this, currentTime), this.timeout);\n        // Store the verification timer locally so that it can be cleared when data has been received.\n        this.verifications.push(verificationTimer);\n        // Set a new keep-alive timer.\n        this.setupKeepAliveTimer();\n        // Write the message to the network socket.\n        return this.socket.write(message + (0, $c78f59d21170b7a6$export$2e2bcd8739ae039).statementDelimiter);\n    }\n    // --- Event managers. --- //\n    /**\n\t * Marks the connection as timed out and schedules reconnection if we have not\n\t * received data within the expected time frame.\n\t */ verifySend(sentTimestamp) {\n        // If we haven't received any data since we last sent data out..\n        if (Number(this.lastReceivedTimestamp) < sentTimestamp) {\n            // If this connection is already disconnected, we do not change anything\n            if (this.status === (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTED || this.status === (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTING) {\n                (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(`Tried to verify already disconnected connection to '${this.hostIdentifier}'`);\n                return;\n            }\n            // Remove the current keep-alive timer if it exists.\n            this.clearKeepAliveTimer();\n            // Write a notification to the logs.\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Connection to '${this.hostIdentifier}' timed out.`);\n            // Close the connection to avoid re-use.\n            // NOTE: This initiates reconnection routines if the connection has not\n            //       been marked as intentionally disconnected.\n            this.socket.disconnect();\n        }\n    }\n    /**\n\t * Updates the connection status when a connection is confirmed.\n\t */ onSocketConnect() {\n        // If a reconnect timer is set, remove it.\n        this.clearReconnectTimer();\n        // Set up the initial timestamp for when we last received data from the server.\n        this.lastReceivedTimestamp = Date.now();\n        // Set up the initial keep-alive timer.\n        this.setupKeepAliveTimer();\n        // Clear all temporary error listeners.\n        this.socket.removeAllListeners(\"error\");\n        // Set up handler for network errors.\n        this.socket.on(\"error\", this.onSocketError.bind(this));\n    }\n    /**\n\t * Updates the connection status when a connection is ended.\n\t */ onSocketDisconnect() {\n        // Send a disconnect signal higher up the stack.\n        this.emit(\"disconnect\");\n        // Remove the current keep-alive timer if it exists.\n        this.clearKeepAliveTimer();\n        // If this is a connection we're trying to tear down..\n        if (this.status === (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTING) {\n            // If a reconnect timer is set, remove it.\n            this.clearReconnectTimer();\n            // Remove all event listeners\n            this.removeAllListeners();\n            // Mark the connection as disconnected.\n            this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTED;\n            // Write a log message.\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Disconnected from '${this.hostIdentifier}'.`);\n        } else {\n            // If this is for an established connection..\n            if (this.status === (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED) // Write a notification to the logs.\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(`Connection with '${this.hostIdentifier}' was closed, trying to reconnect in ${this.reconnectInterval / 1000} seconds.`);\n            // Mark the connection as disconnected for now..\n            this.status = (0, $a58372b18a18806e$export$7516420eb880ab68).DISCONNECTED;\n            // If we don't have a pending reconnection timer..\n            if (!this.timers.reconnect) // Attempt to reconnect after one keep-alive duration.\n            this.timers.reconnect = setTimeout(this.reconnect.bind(this), this.reconnectInterval);\n        }\n    }\n    /**\n\t * Notify administrator of any unexpected errors.\n\t */ onSocketError(error) {\n        // Report a generic error if no error information is present.\n        // NOTE: When using WSS, the error event explicitly\n        //       only allows to send a \"simple\" event without data.\n        //       https://stackoverflow.com/a/18804298\n        if (typeof error === \"undefined\") // Do nothing, and instead rely on the socket disconnect event for further information.\n        return;\n        // If the DNS lookup failed.\n        if (error.code === \"EAI_AGAIN\") {\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(`Failed to look up DNS records for '${this.host}'.`);\n            return;\n        }\n        // If the connection timed out..\n        if (error.code === \"ETIMEDOUT\") {\n            // Log the provided timeout message.\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(error.message);\n            return;\n        }\n        // Log unknown error\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).errors(`Unknown network error ('${this.hostIdentifier}'): `, error);\n    }\n}\nvar // Export the connection.\n$1326c18f93f95fee$export$2e2bcd8739ae039 = $1326c18f93f95fee$var$ElectrumConnection;\n\n\n\n\n\n\n// Acceptable parameter types for RPC messages\nconst $7c0fb93e8eea922a$export$d73a2e87a509880 = function(message) {\n    return \"id\" in message && \"error\" in message;\n};\nconst $7c0fb93e8eea922a$export$81276773828ff315 = function(message) {\n    return \"id\" in message && \"result\" in message;\n};\nconst $7c0fb93e8eea922a$export$280de919a0cf6928 = function(message) {\n    return !(\"id\" in message) && \"method\" in message;\n};\nconst $7c0fb93e8eea922a$export$94e3360fcddccc76 = function(message) {\n    return \"id\" in message && \"method\" in message;\n};\n\n\n\n/**\n * Triggers when the underlying connection is established.\n *\n * @event ElectrumClient#connected\n */ /**\n * Triggers when the underlying connection is lost.\n *\n * @event ElectrumClient#disconnected\n */ /**\n * Triggers when the remote server sends data that is not a request response.\n *\n * @event ElectrumClient#notification\n */ /**\n * High-level Electrum client that lets applications send requests and subscribe to notification events from a server.\n */ class $620a18299ef8d6fd$var$ElectrumClient extends (0, $4QiMX$EventEmitter) {\n    /**\n\t * Initializes an Electrum client.\n\t *\n\t * @param {string} application       your application name, used to identify to the electrum host.\n\t * @param {string} version           protocol version to use with the host.\n\t * @param {string} host              fully qualified domain name or IP number of the host.\n\t * @param {number} port              the TCP network port of the host.\n\t * @param {TransportScheme} scheme   the transport scheme to use for connection\n\t * @param {number} timeout           how long network delays we will wait for before taking action, in milliseconds.\n\t * @param {number} pingInterval      the time between sending pings to the electrum host, in milliseconds.\n\t * @param {number} reconnectInterval the time between reconnection attempts to the electrum host, in milliseconds.\n\t *\n\t * @throws {Error} if `version` is not a valid version string.\n\t */ constructor(application, version, host, port = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).PORT, scheme = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).TRANSPORT_SCHEME, timeout = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).TIMEOUT, pingInterval = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).PING_INTERVAL, reconnectInterval = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).RECONNECT){\n        // Initialize the event emitter.\n        super();\n        // Initialize an empty list of subscription metadata.\n        this.subscriptionMethods = {};\n        // Start counting the request IDs from 0\n        this.requestId = 0;\n        // Initialize an empty dictionary for keeping track of request resolvers\n        this.requestResolvers = {};\n        // Mutex lock used to prevent simultaneous connect() and disconnect() calls.\n        this.connectionLock = new (0, $4QiMX$Mutex)();\n        // Set up a connection to an electrum server.\n        this.connection = new (0, $1326c18f93f95fee$export$2e2bcd8739ae039)(application, version, host, port, scheme, timeout, pingInterval, reconnectInterval);\n    }\n    /**\n\t * Connects to the remote server.\n\t *\n\t * @throws {Error} if the socket connection fails.\n\t * @returns a promise resolving when the connection is established.\n\t */ async connect() {\n        // Create a lock so that multiple connects/disconnects cannot race each other.\n        const unlock = await this.connectionLock.acquire();\n        try {\n            // If we are already connected, do not attempt to connect again.\n            if (this.connection.status === (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED) return;\n            // Listen for parsed statements.\n            this.connection.on(\"statement\", this.response.bind(this));\n            // Hook up resubscription on connection.\n            this.connection.on(\"connect\", this.resubscribeOnConnect.bind(this));\n            // Relay connect and disconnect events.\n            this.connection.on(\"connect\", this.emit.bind(this, \"connected\"));\n            this.connection.on(\"disconnect\", this.onConnectionDisconnect.bind(this));\n            // Relay error events.\n            this.connection.on(\"error\", this.emit.bind(this, \"error\"));\n            // Connect with the server.\n            await this.connection.connect();\n        } finally{\n            unlock();\n        }\n    }\n    /**\n\t * Disconnects from the remote server and removes all event listeners/subscriptions and open requests.\n\t *\n\t * @param {boolean} force                 disconnect even if the connection has not been fully established yet.\n\t * @param {boolean} retainSubscriptions   retain subscription data so they will be restored on reconnection.\n\t *\n\t * @returns true if successfully disconnected, or false if there was no connection.\n\t */ async disconnect(force = false, retainSubscriptions = false) {\n        // Create a lock so that multiple connects/disconnects cannot race each other.\n        const unlock = await this.connectionLock.acquire();\n        try {\n            if (!retainSubscriptions) {\n                // Cancel all event listeners.\n                this.removeAllListeners();\n                // Remove all subscription data\n                this.subscriptionMethods = {};\n            }\n            // For each pending request..\n            for(const index in this.requestResolvers){\n                // Reject the request.\n                const requestResolver = this.requestResolvers[index];\n                requestResolver(new Error(\"Manual disconnection\"));\n                // Remove the request.\n                delete this.requestResolvers[index];\n            }\n            // Disconnect from the remove server.\n            return await this.connection.disconnect(force);\n        } finally{\n            unlock();\n        }\n    }\n    /**\n\t * Calls a method on the remote server with the supplied parameters.\n\t *\n\t * @param {string} method          name of the method to call.\n\t * @param {...string} parameters   one or more parameters for the method.\n\t *\n\t * @throws {Error} if the client is disconnected.\n\t * @returns a promise that resolves with the result of the method or an Error.\n\t */ async request(method, ...parameters) {\n        // If we are not connected to a server..\n        if (this.connection.status !== (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED) // Reject the request with a disconnected error message.\n        throw new Error(`Unable to send request to a disconnected server '${this.connection.host}'.`);\n        // Increase the request ID by one.\n        this.requestId += 1;\n        // Store a copy of the request id.\n        const id = this.requestId;\n        // Format the arguments as an electrum request object.\n        const message = (0, $c78f59d21170b7a6$export$2e2bcd8739ae039).buildRequestObject(method, parameters, id);\n        // Define a function to wrap the request in a promise.\n        const requestResolver = (resolve)=>{\n            // Add a request resolver for this promise to the list of requests.\n            this.requestResolvers[id] = (error, data)=>{\n                // If the resolution failed..\n                if (error) // Resolve the promise with the error for the application to handle.\n                resolve(error);\n                else // Resolve the promise with the request results.\n                resolve(data);\n            };\n            // Send the request message to the remote server.\n            this.connection.send(message);\n        };\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).network(`Sending request '${method}' to '${this.connection.host}'`);\n        // return a promise to deliver results later.\n        return new Promise(requestResolver);\n    }\n    /**\n\t * Subscribes to the method and payload at the server.\n\t *\n\t * @note the response for the subscription request is issued as a notification event.\n\t *\n\t * @param {string}    method       one of the subscribable methods the server supports.\n\t * @param {...string} parameters   one or more parameters for the method.\n\t *\n\t * @throws {Error} if the client is disconnected.\n\t * @returns a promise resolving when the subscription is established.\n\t */ async subscribe(method, ...parameters) {\n        // Initialize an empty list of subscription payloads, if needed.\n        if (!this.subscriptionMethods[method]) this.subscriptionMethods[method] = new Set();\n        // Store the subscription parameters to track what data we have subscribed to.\n        this.subscriptionMethods[method].add(JSON.stringify(parameters));\n        // Send initial subscription request.\n        const requestData = await this.request(method, ...parameters);\n        // Construct a notification structure to package the initial result as a notification.\n        const notification = {\n            jsonrpc: \"2.0\",\n            method: method,\n            params: [\n                ...parameters,\n                requestData\n            ]\n        };\n        // Manually emit an event for the initial response.\n        this.emit(\"notification\", notification);\n    }\n    /**\n\t * Unsubscribes to the method at the server and removes any callback functions\n\t * when there are no more subscriptions for the method.\n\t *\n\t * @param {string}    method       a previously subscribed to method.\n\t * @param {...string} parameters   one or more parameters for the method.\n\t *\n\t * @throws {Error} if no subscriptions exist for the combination of the provided `method` and `parameters.\n\t * @throws {Error} if the client is disconnected.\n\t * @returns a promise resolving when the subscription is removed.\n\t */ async unsubscribe(method, ...parameters) {\n        // Throw an error if the client is disconnected.\n        if (this.connection.status !== (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED) throw new Error(`Unable to send unsubscribe request to a disconnected server '${this.connection.host}'.`);\n        // If this method has no subscriptions..\n        if (!this.subscriptionMethods[method]) // Reject this promise with an explanation.\n        throw new Error(`Cannot unsubscribe from '${method}' since the method has no subscriptions.`);\n        // Pack up the parameters as a long string.\n        const subscriptionParameters = JSON.stringify(parameters);\n        // If the method payload could not be located..\n        if (!this.subscriptionMethods[method].has(subscriptionParameters)) // Reject this promise with an explanation.\n        throw new Error(`Cannot unsubscribe from '${method}' since it has no subscription with the given parameters.`);\n        // Remove this specific subscription payload from internal tracking.\n        this.subscriptionMethods[method].delete(subscriptionParameters);\n        // Send unsubscription request to the server\n        // NOTE: As a convenience we allow users to define the method as the subscribe or unsubscribe version.\n        await this.request(method.replace(\".subscribe\", \".unsubscribe\"), ...parameters);\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).client(`Unsubscribed from '${String(method)}' for the '${subscriptionParameters}' parameters.`);\n    }\n    /**\n\t * Restores existing subscriptions without updating status or triggering manual callbacks.\n\t *\n\t * @throws {Error} if subscription data cannot be found for all stored event names.\n\t * @throws {Error} if the client is disconnected.\n\t * @returns a promise resolving to true when the subscriptions are restored.\n\t *\n\t * @ignore\n\t */ async resubscribeOnConnect() {\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).client(`Connected to '${this.connection.hostIdentifier}'.`);\n        // Initialize an empty list of resubscription promises.\n        const resubscriptionPromises = [];\n        // For each method we have a subscription for..\n        for(const method in this.subscriptionMethods){\n            // .. and for each parameter we have previously been subscribed to..\n            for (const parameterJSON of this.subscriptionMethods[method].values()){\n                // restore the parameters from JSON.\n                const parameters = JSON.parse(parameterJSON);\n                // Send a subscription request.\n                resubscriptionPromises.push(this.subscribe(method, ...parameters));\n            }\n            // Wait for all re-subscriptions to complete.\n            await Promise.all(resubscriptionPromises);\n        }\n        // Write a log message if there was any subscriptions to restore.\n        if (resubscriptionPromises.length > 0) (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).client(`Restored ${resubscriptionPromises.length} previous subscriptions for '${this.connection.hostIdentifier}'`);\n    }\n    /**\n\t * Parser messages from the remote server to resolve request promises and emit subscription events.\n\t *\n\t * @param {RPCNotification | RPCResponse} message   the response message\n\t *\n\t * @throws {Error} if the message ID does not match an existing request.\n\t * @ignore\n\t */ response(message) {\n        // If the received message is a notification, we forward it to all event listeners\n        if ((0, $7c0fb93e8eea922a$export$280de919a0cf6928)(message)) {\n            // Write a log message.\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).client(`Received notification for '${message.method}' from '${this.connection.host}'`);\n            // Forward the message content to all event listeners.\n            this.emit(\"notification\", message);\n            // Return since it does not have an associated request resolver\n            return;\n        }\n        // If the response ID is null we cannot use it to index our request resolvers\n        if (message.id === null) // Throw an internal error, this should not happen.\n        throw new Error(\"Internal error: Received an RPC response with ID null.\");\n        // Look up which request promise we should resolve this.\n        const requestResolver = this.requestResolvers[message.id];\n        // If we do not have a request resolver for this response message..\n        if (!requestResolver) // Throw an internal error, this should not happen.\n        throw new Error(\"Internal error: Callback for response not available.\");\n        // Remove the promise from the request list.\n        delete this.requestResolvers[message.id];\n        // If the message contains an error..\n        if ((0, $7c0fb93e8eea922a$export$d73a2e87a509880)(message)) // Forward the message error to the request resolver and omit the `result` parameter.\n        requestResolver(new Error(message.error.message));\n        else // Forward the message content to the request resolver and omit the `error` parameter\n        // (by setting it to undefined).\n        requestResolver(undefined, message.result);\n    }\n    /**\n\t * Callback function that is called when connection to the Electrum server is lost.\n\t * Aborts all active requests with an error message indicating that connection was lost.\n\t *\n\t * @ignore\n\t */ onConnectionDisconnect() {\n        // Emit a disconnection signal to any listeners.\n        this.emit(\"disconnected\");\n        // Loop over active requests\n        for(const resolverId in this.requestResolvers){\n            // Extract request resolver for readability\n            const requestResolver = this.requestResolvers[resolverId];\n            // Resolve the active request with an error indicating that the connection was lost.\n            requestResolver(new Error(\"Connection lost\"));\n            // Remove the promise from the request list.\n            delete this.requestResolvers[resolverId];\n        }\n    }\n}\nvar // Export the client.\n$620a18299ef8d6fd$export$2e2bcd8739ae039 = $620a18299ef8d6fd$var$ElectrumClient;\n\n\n\n\n\n\n\n\n/**\n * Triggers when the cluster connects to enough servers to satisfy both the cluster confidence and distribution policies.\n *\n * @event ElectrumCluster#ready\n */ /**\n * Triggers when the cluster loses a connection and can no longer satisfy the cluster distribution policy.\n *\n * @event ElectrumCluster#degraded\n */ /**\n * Triggers when the cluster loses a connection and can no longer satisfy the cluster confidence policy.\n *\n * @event ElectrumCluster#disabled\n */ /**\n * Triggers when the cluster verifies the integrity of remote server sent data that is not a request responses.\n *\n * @event ElectrumCluster#notification\n */ /**\n * High-level electrum client that provides transparent load balancing, confidence checking and/or low-latency polling.\n */ class $9b2ed2eb52532075$var$ElectrumCluster extends (0, $4QiMX$EventEmitter) {\n    /**\n\t * @param {string} application    your application name, used to identify to the electrum hosts.\n\t * @param {string} version        protocol version to use with the hosts.\n\t * @param {number} confidence     wait for this number of hosts to provide identical results.\n\t * @param {number} distribution   request information from this number of hosts.\n\t * @param {ClusterOrder} order    select hosts to communicate with in this order.\n\t * @param {number} timeout        how long network delays we will wait for before taking action, in milliseconds.\n\t * @param {number} pingInterval      the time between sending pings to the electrum host, in milliseconds.\n\t * @param {number} reconnectInterval the time between reconnection attempts to the electrum host, in milliseconds.\n\t */ constructor(application, version, confidence = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).CLUSTER_CONFIDENCE, distribution = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).CLUSTER_DISTRIBUTION, order = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).CLUSTER_ORDER, timeout = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).TIMEOUT, pingInterval = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).PING_INTERVAL, reconnectInterval = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).RECONNECT){\n        // Initialize the event emitter.\n        super();\n        this.application = application;\n        this.version = version;\n        this.confidence = confidence;\n        this.distribution = distribution;\n        this.order = order;\n        this.timeout = timeout;\n        this.pingInterval = pingInterval;\n        this.reconnectInterval = reconnectInterval;\n        this.// Initialize an empty dictionary of clients in the cluster\n        clients = {};\n        this.// Start at 0 connected clients\n        connections = 0;\n        this.// Set up an empty set of notification data.\n        notifications = {};\n        this.// Start the cluster in DISABLED state\n        status = (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DISABLED;\n        this.// Start counting request IDs at 0\n        requestCounter = 0;\n        this.// Initialize an empty dictionary for keeping track of request resolvers\n        requestPromises = {};\n        this.// Lock to prevent concurrency race conditions when sending requests.\n        requestLock = new (0, $4QiMX$Mutex)();\n        this.// Lock to prevent concurrency race conditions when receiving responses.\n        responseLock = new (0, $4QiMX$Mutex)();\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Initialized empty cluster (${confidence} of ${distribution || \"ALL\"})`);\n        // Print out a warning if we cannot guarantee consensus for subscription notifications.\n        // Case 1: we don't know how many servers will be used, so warning just to be safe\n        // Case 2: we know the number of servers needed to trust a response is less than 50%.\n        if (distribution === (0, $a58372b18a18806e$export$436a960acc41e848).ALL || confidence / distribution <= 0.50) (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).warning(`Subscriptions might return multiple valid responses when confidence (${confidence}) is less than 51% of distribution.`);\n    }\n    /**\n\t * Adds a server to the cluster.\n\t *\n\t * @param {string} host              fully qualified domain name or IP number of the host.\n\t * @param {number} port              the TCP network port of the host.\n\t * @param {TransportScheme} scheme   the transport scheme to use for connection\n\t * @param {boolean} autoConnect      flag indicating whether the server should automatically connect (default true)\n\t *\n\t * @throws {Error} if the cluster's version is not a valid version string.\n\t * @returns a promise that resolves when the connection has been initiated.\n\t */ async addServer(host, port = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).PORT, scheme = (0, $5abc8fb342687c03$export$f019be48b3aacb1a).TRANSPORT_SCHEME, autoConnect = true) {\n        // Set up a new electrum client.\n        const client = new (0, $620a18299ef8d6fd$export$2e2bcd8739ae039)(this.application, this.version, host, port, scheme, this.timeout, this.pingInterval, this.reconnectInterval);\n        // Define the client identity to avoid repetition.\n        const clientIdentity = `${host}:${port}`;\n        // Store this client.\n        this.clients[clientIdentity] = {\n            state: (0, $a58372b18a18806e$export$c4f81c6d30ca200f).UNAVAILABLE,\n            connection: client\n        };\n        /**\n\t\t * Define a helper function to evaluate and log cluster status.\n\t\t *\n\t\t * @fires ElectrumCluster#ready\n\t\t * @fires ElectrumCluster#degraded\n\t\t * @fires ElectrumCluster#disabled\n\t\t */ const updateClusterStatus = ()=>{\n            // Calculate the required distribution, taking into account that distribution to all is represented with 0.\n            const distribution = Math.max(this.confidence, this.distribution);\n            // Check if we have enough connections to saturate distribution.\n            if (this.connections >= distribution) // If the cluster is not currently considered ready..\n            {\n                if (this.status !== (0, $a58372b18a18806e$export$c66b56bc0ff967ca).READY) {\n                    // Mark the cluster as ready.\n                    this.status = (0, $a58372b18a18806e$export$c66b56bc0ff967ca).READY;\n                    // Emit the ready signal to indicate the cluster is running in a ready mode.\n                    this.emit(\"ready\");\n                    // Write a log message with an update on the current cluster status.\n                    (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Cluster status is ready (currently ${this.connections} of ${distribution} connections available.)`);\n                }\n            } else if (this.connections >= this.confidence) // If the cluster is not currently considered degraded..\n            {\n                if (this.status !== (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DEGRADED) {\n                    // Mark the cluster as degraded.\n                    this.status = (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DEGRADED;\n                    // Emit the degraded signal to indicate the cluster is running in a degraded mode.\n                    this.emit(\"degraded\");\n                    // Write a log message with an update on the current cluster status.\n                    (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Cluster status is degraded (only ${this.connections} of ${distribution} connections available.)`);\n                }\n            } else if (this.status !== (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DISABLED) {\n                // Mark the cluster as disabled.\n                this.status = (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DISABLED;\n                // Emit the degraded signal to indicate the cluster is disabled.\n                this.emit(\"disabled\");\n                // Write a log message with an update on the current cluster status.\n                (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Cluster status is disabled (only ${this.connections} of the ${distribution} connections are available.)`);\n            }\n        };\n        // Define a function to run when client has connected.\n        const onConnect = async ()=>{\n            // Wrap in a try-catch so we can ignore errors.\n            try {\n                // Check connection status\n                const connectionStatus = client.connection.status;\n                // If the connection is fine..\n                if (connectionStatus === (0, $a58372b18a18806e$export$7516420eb880ab68).CONNECTED) {\n                    // If this was from an unavailable connection..\n                    if (this.clients[clientIdentity].state === (0, $a58372b18a18806e$export$c4f81c6d30ca200f).UNAVAILABLE) // Update connection counter.\n                    this.connections += 1;\n                    // Set client state to available.\n                    this.clients[clientIdentity].state = (0, $a58372b18a18806e$export$c4f81c6d30ca200f).AVAILABLE;\n                    // update the cluster status.\n                    updateClusterStatus();\n                }\n            } catch (error) {\n            // Do nothing.\n            }\n        };\n        // Define a function to run when client disconnects.\n        const onDisconnect = ()=>{\n            // If this was from an established connection..\n            if (this.clients[clientIdentity].state === (0, $a58372b18a18806e$export$c4f81c6d30ca200f).AVAILABLE) // Update connection counter.\n            this.connections -= 1;\n            // Set client state to unavailable.\n            this.clients[clientIdentity].state = (0, $a58372b18a18806e$export$c4f81c6d30ca200f).UNAVAILABLE;\n            // update the cluster status.\n            updateClusterStatus();\n        };\n        // Set up handlers for connection and disconnection.\n        client.connection.on(\"connect\", onConnect.bind(this));\n        client.connection.on(\"disconnect\", onDisconnect.bind(this));\n        // Set up handler for notification events, that includes the identity of this client so it can be tracked.\n        client.on(\"notification\", this.handleSubscriptionNotifications.bind(this, clientIdentity));\n        // Connect if auto-connect is set to true, returning the connection result.\n        if (autoConnect) try {\n            // Set up the connection.\n            await client.connect();\n        } catch (error) {\n            // Log a message why the connection failed and move on.\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Failed to connect with ${host}: ${error}`);\n        }\n    }\n    /**\n\t * Calls a method on the remote server with the supplied parameters.\n\t *\n\t * @param {string}    method       name of the method to call.\n\t * @param {...string} parameters   one or more parameters for the method.\n\t *\n\t * @throws {Error} if not enough clients are connected\n\t * @throws {Error} if no response is received with sufficient integrity\n\t * @returns a promise that resolves with the result of the method.\n\t */ async request(method, ...parameters) {\n        // Check if the cluster is unable to serve requests.\n        if (this.status === (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DISABLED) throw new Error(`Cannot request '${method}' when available clients (${this.connections}) is less than required confidence (${this.confidence}).`);\n        // Lock this request method temporarily.\n        const unlock = await this.requestLock.acquire();\n        // Declare requestId outside of try-catch scope.\n        let requestId = 0;\n        // NOTE: If this async method is called very rapidly, it's theoretically possible that the parts below could interfere.\n        try {\n            // Increase the current request counter.\n            this.requestCounter += 1;\n            // Copy the request counter so we can work with the copy and know it won't change\n            // even if the request counter is raised from concurrent requests.\n            requestId = this.requestCounter;\n        } finally{\n            // Unlock this request method now that the concurrency sensitive condition is completed.\n            unlock();\n        }\n        // Initialize an empty list of request promises.\n        this.requestPromises[requestId] = [];\n        // Extract all available client IDs\n        const availableClientIDs = Object.keys(this.clients).filter((clientID)=>this.clients[clientID].state === (0, $a58372b18a18806e$export$c4f81c6d30ca200f).AVAILABLE);\n        // Initialize a sent counter.\n        let sentCounter = 0;\n        // Determine the number of clients we need to send to, taking ClusterDistribution.ALL (=0) into account.\n        let requiredDistribution = this.distribution || availableClientIDs.length;\n        // If the cluster is in degraded status, we do not have enough available clients to\n        // match distribution, but still enough to reach consensus, so we use the clients we have.\n        if (this.status === (0, $a58372b18a18806e$export$c66b56bc0ff967ca).DEGRADED) requiredDistribution = availableClientIDs.length;\n        // Repeat until we have sent the request to the desired number of clients.\n        while(sentCounter < requiredDistribution){\n            // Pick an array index according to our ordering strategy.\n            let currentIndex = 0;\n            // Use a random array index when cluster order is set to RANDOM\n            if (this.order === (0, $a58372b18a18806e$export$161fe3707f756bf9).RANDOM) currentIndex = Math.floor(Math.random() * availableClientIDs.length);\n            // Move a client identity from the client list to its own variable.\n            const [currentClient] = availableClientIDs.splice(currentIndex, 1);\n            // Send the request to the client and store the request promise.\n            const requestPromise = this.clients[currentClient].connection.request(method, ...parameters);\n            this.requestPromises[requestId].push(requestPromise);\n            // Increase the sent counter.\n            sentCounter += 1;\n        }\n        // Define a function to poll for request responses.\n        const pollResponse = (resolve, reject)=>{\n            // Define a function to resolve request responses based on integrity.\n            const resolveRequest = async ()=>{\n                // Set up an empty set of response data.\n                const responseData = {};\n                // Set up a counter to keep track of how many responses we have checked.\n                let checkedResponses = 0;\n                // For each server we issued a request to..\n                for(const currentPromise in this.requestPromises[requestId]){\n                    // Initialize a holder for the response in the required scope to use it.\n                    let response;\n                    // Race the request promise against a pre-resolved request to determine request status.\n                    try {\n                        // Arrange an array of the current promise and an empty promise such that..\n                        const promises = [\n                            this.requestPromises[requestId][currentPromise],\n                            Promise.resolve(undefined)\n                        ];\n                        // .. we can get the result of the current promise if it is currently resolved, but don't need to wait for it otherwise.\n                        response = await Promise.race(promises);\n                    } // Handle case where the request sent resulted in a thrown error / promise rejection, rather then resolving to a response.\n                    // Note that in the worst time case, each request can be expected to  eventually throw an error on timeout.\n                    catch (error) {\n                        // Increase the counter for checked responses.\n                        checkedResponses += 1;\n                        continue;\n                    }\n                    // If the promise is settled..\n                    if (response !== undefined) {\n                        // Calculate a unique identifier for this notification data.\n                        const responseDataIdentifier = JSON.stringify(response);\n                        // Increase the counter for checked responses.\n                        checkedResponses += 1;\n                        // Either set the response data counter or increase it.\n                        if (responseData[responseDataIdentifier] === undefined) responseData[responseDataIdentifier] = 1;\n                        else responseData[responseDataIdentifier] += 1;\n                        // Check if this response has enough integrity according to our confidence strategy.\n                        if (responseData[responseDataIdentifier] === this.confidence) {\n                            // Write log entry.\n                            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Validated response for '${method}' with sufficient integrity (${this.confidence}).`);\n                            // Resolve the request with this response.\n                            resolve(response);\n                            // Return after resolving since we do not want to continue the execution.\n                            return;\n                        }\n                    }\n                }\n                // If all clients have responded but we failed to reach desired integrity..\n                if (checkedResponses === this.requestPromises[requestId].length) {\n                    // Reject this request with an error message.\n                    reject(new Error(`Unable to complete request for '${method}', response failed to reach sufficient integrity (${this.confidence}).`));\n                    // Return after rejecting since we do not want to continue the execution.\n                    return;\n                }\n                // If we are not ready, but have not timed out and should wait more..\n                setTimeout(resolveRequest, 1000);\n            };\n            // Attempt the initial resolution of the request.\n            resolveRequest();\n        };\n        // return some kind of promise that resolves when integrity number of clients results match.\n        return new Promise(pollResponse);\n    }\n    /**\n\t * Subscribes to the method at the cluster and attaches the callback function to the event feed.\n\t *\n\t * @note the response for the subscription request is issued as a notification event.\n\t *\n\t * @param {string}    method       one of the subscribable methods the server supports.\n\t * @param {...string} parameters   one or more parameters for the method.\n\t *\n\t * @throws {Error} if not enough clients are connected\n\t * @throws {Error} if no response is received with sufficient integrity for the initial request\n\t */ async subscribe(method, ...parameters) {\n        // Set up event listener for this subscription.\n        for(const currentClient in this.clients){\n            // Copy the current client for brevity.\n            const client = this.clients[currentClient].connection;\n            try {\n                // Send initial subscription request.\n                // NOTE: This stores and manages the subscription even if the initial request fails.\n                await client.subscribe(method, ...parameters);\n            } catch (error) {\n            // Do nothing, as this is handled on a best-effort basis and\n            // not all servers are expected to be ready at all times.\n            }\n        }\n    }\n    /**\n\t * Unsubscribes to the method at the cluster and removes any callback functions\n\t * when there are no more subscriptions for the method.\n\t *\n\t * @deprecated\n\t *\n\t * @param {string}    method       one of the subscribable methods the server supports.\n\t * @param {...string} parameters   one or more parameters for the method.\n\t *\n\t * @throws {Error} if, for any of the clients, no subscriptions exist for the combination of the provided `method` and `parameters.\n\t */ async unsubscribe(method, ...parameters) {\n        // Initialize an empty list to track subscription requests.\n        const unsubscriptionPromises = [];\n        // For each client..\n        for(const currentClient in this.clients){\n            // Store client in variable for brevity\n            const client = this.clients[currentClient].connection;\n            // unsubscribe this client.\n            unsubscriptionPromises.push(client.unsubscribe(method, ...parameters));\n        }\n        // Wait for all unsubscription promises to resolve.\n        await Promise.all(unsubscriptionPromises);\n    }\n    /**\n\t * Define a callback function to validate server notifications and pass them to the subscribe callback.\n\t *\n\t * @ignore\n\t */ async handleSubscriptionNotifications(clientIdentity, data) {\n        // Lock this response method temporarily.\n        const unlock = await this.responseLock.acquire();\n        try {\n            // Calculate a unique identifier for this notification data.\n            const responseDataIdentifier = JSON.stringify(data);\n            // Create an empty list of clients who have responded to this notification, if necessary.\n            if (this.notifications[responseDataIdentifier] === undefined) this.notifications[responseDataIdentifier] = new Set();\n            // Ensure this client is on the list of clients that have provided this specific notification.\n            this.notifications[responseDataIdentifier].add(clientIdentity);\n            // Check if this notification has enough integrity according to our confidence strategy.\n            // NOTE: We check against === instead of >== in order to ensure that we only emit each notification once.\n            if (this.notifications[responseDataIdentifier].size === this.confidence) {\n                // Write log entry.\n                (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(`Validated notification for '${data.method}' with sufficient integrity (${this.confidence}).`);\n                // Emit an event for the notification data.\n                this.emit(\"notification\", data);\n                // Dismiss the notification data after all nodes are assumed to have sent their notifications.\n                // NOTE: This is a redundant mechanic to ensure that even if some nodes don't provide this notification, we still clear this data.\n                // NOTE: This also introduces a race-condition where if a legit identical notification comes in before/during this timeout, it might get silenced.\n                setTimeout(this.dismissSubscriptionNotification.bind(this, responseDataIdentifier), this.timeout);\n            }\n            // Check if this notification has been fully handled.\n            if (this.notifications[responseDataIdentifier].size === this.distribution) // Dismiss existing response data as we know all related parties have provided their input.\n            this.dismissSubscriptionNotification(responseDataIdentifier);\n        } finally{\n            // Unlock the response method so it can handle the next set of data.\n            unlock();\n        }\n    }\n    /**\n\t * Forgets/Removes notification data for a specific notification.\n\t *\n\t * This is required in order to allow future identical notifications to be properly processed and emitted.\n\t */ async dismissSubscriptionNotification(responseDataIdentifier) {\n        delete this.notifications[responseDataIdentifier];\n    }\n    /**\n\t * Provides a method to check or wait for the cluster to become ready.\n\t *\n\t * @returns a promise that resolves when the required servers are available.\n\t */ async ready() {\n        // Store the current timestamp.\n        const readyTimestamp = Date.now();\n        // Define a function to poll for availability of the cluster.\n        const availabilityPoller = (resolve)=>{\n            // Define a function to check if the cluster is ready to be used.\n            const connectionAvailabilityVerifier = ()=>{\n                // Check if the cluster is active..\n                if (this.status === (0, $a58372b18a18806e$export$c66b56bc0ff967ca).READY) {\n                    // Resolve with true to indicate that the cluster is ready to use.\n                    resolve(true);\n                    // Return after resolving since we do not want to continue the execution.\n                    return;\n                }\n                // Calculate how long we have waited, in milliseconds.\n                const timeWaited = Date.now() - readyTimestamp;\n                // Check if we have waited longer than our timeout setting.\n                if (timeWaited > this.timeout) {\n                    // Resolve with false to indicate that we did not get ready in time.\n                    resolve(false);\n                    // Return after resolving since we do not want to continue the execution.\n                    return;\n                }\n                // If we are not ready, but have not timed out and should wait more..\n                setTimeout(connectionAvailabilityVerifier, 50);\n            };\n            // Run the initial verification.\n            connectionAvailabilityVerifier();\n        };\n        // Return a promise that resolves when the available clients is sufficient.\n        return new Promise(availabilityPoller);\n    }\n    /**\n\t * Connects all servers from the cluster and attaches event listeners and handlers\n\t * for all underlying clients and connections.\n\t *\n\t * @throws {Error} if the cluster's version is not a valid version string.\n\t */ async startup() {\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(\"Starting up cluster.\");\n        // Keep track of all connections\n        const connections = [];\n        // Loop over all clients and reconnect them if they're disconnected\n        for(const clientKey in this.clients){\n            // Retrieve connection information for the client\n            const { host: host , port: port , scheme: scheme  } = this.clients[clientKey].connection.connection;\n            // Only connect currently unavailable/disconnected clients\n            if (this.clients[clientKey].state === (0, $a58372b18a18806e$export$c4f81c6d30ca200f).AVAILABLE) // Warn when a server is already connected when calling startup()\n            (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).warning(`Called startup(), but server ${host}:${port} is already connected`);\n            else // Call the addServer() function with the existing connection data\n            // This effectively reconnects the server and re-instates all event listeners\n            connections.push(this.addServer(host, port, scheme));\n        }\n        // Await all connections\n        return Promise.all(connections);\n    }\n    /**\n\t * Disconnects all servers from the cluster. Removes all event listeners and\n\t * handlers from all underlying clients and connections. This includes all\n\t * active subscriptions, unless retainSubscriptions is set to true.\n\t *\n\t * @param {boolean} retainSubscriptions   retain subscription data so they will be restored on reconnection.\n\t *\n\t * @returns a list with the disconnection result for every client\n\t */ async shutdown(retainSubscriptions = false) {\n        // Write a log message.\n        (0, $ef5ba40c8abe5a13$export$2e2bcd8739ae039).cluster(\"Shutting down cluster.\");\n        // Set up a list of disconnections to wait for.\n        const disconnections = [];\n        const disconnectResolver = (resolve)=>{\n            // Resolve once the cluster is marked as disabled\n            this.once(\"disabled\", ()=>resolve(Promise.all(disconnections)));\n            // For each client in this cluster..\n            for(const clientIndex in this.clients)// Force disconnection regardless of current status.\n            disconnections.push(this.clients[clientIndex].connection.disconnect(true, retainSubscriptions));\n        };\n        // Return a list of booleans indicating disconnections from all clients\n        return new Promise(disconnectResolver);\n    }\n}\nvar // Export the cluster.\n$9b2ed2eb52532075$export$2e2bcd8739ae039 = $9b2ed2eb52532075$var$ElectrumCluster;\n\n\n\n\n\n\n\nexport {$620a18299ef8d6fd$export$2e2bcd8739ae039 as ElectrumClient, $9b2ed2eb52532075$export$2e2bcd8739ae039 as ElectrumCluster, $a192ea5a4eec42d4$export$e1f38ab2b4ebdde6 as isVersionRejected, $a192ea5a4eec42d4$export$9598f0c76aa41d73 as isVersionNegotiated, $5abc8fb342687c03$export$d048df559e6d3842 as ElectrumTransport, $5abc8fb342687c03$export$f019be48b3aacb1a as DefaultParameters, $a58372b18a18806e$export$161fe3707f756bf9 as ClusterOrder, $a58372b18a18806e$export$436a960acc41e848 as ClusterDistribution, $a58372b18a18806e$export$c66b56bc0ff967ca as ClusterStatus, $a58372b18a18806e$export$c4f81c6d30ca200f as ClientState, $a58372b18a18806e$export$7516420eb880ab68 as ConnectionStatus};\n//# sourceMappingURL=index.mjs.map\n","export default \"data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20standalone='no'?%3e%3csvg%20xmlns:dc='http://purl.org/dc/elements/1.1/'%20xmlns:cc='http://creativecommons.org/ns%23'%20xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23'%20xmlns:svg='http://www.w3.org/2000/svg'%20xmlns='http://www.w3.org/2000/svg'%20height='40'%20viewBox='0%20-960%20960%20960'%20width='40'%20version='1.1'%20id='svg1584'%3e%3cmetadata%20id='metadata1590'%3e%3crdf:RDF%3e%3ccc:Work%20rdf:about=''%3e%3cdc:format%3eimage/svg+xml%3c/dc:format%3e%3cdc:type%20rdf:resource='http://purl.org/dc/dcmitype/StillImage'%20/%3e%3cdc:title%3e%3c/dc:title%3e%3c/cc:Work%3e%3c/rdf:RDF%3e%3c/metadata%3e%3cdefs%20id='defs1588'%20/%3e%3crect%20style='fill:%238dc351;fill-opacity:1;stroke:none;stroke-width:0;stroke-linecap:round;stroke-opacity:0.00392157'%20id='rect988'%20width='960'%20height='960'%20x='-1.5108347e-16'%20y='-960'%20rx='9798.04'%20ry='960'%20/%3e%3cg%20transform='matrix(0.05649551,0,0,0.05649551,34.309165,-945.515)'%20fill='%23ffffff'%20id='g56-1-2'%20style='stroke-width:0.735607'%3e%3cpath%20d='m%207751,13046%20c%20-6,-17%20-62,-222%20-127,-456%20-195,-713%20-262,-951%20-266,-956%20-3,-2%20-398,103%20-879,234%20-481,131%20-875,238%20-877,237%20-3,-3%20-112,-1041%20-112,-1071%200,-17%208,-23%2033,-28%2075,-14%20558,-147%20627,-172%20101,-38%20181,-113%20204,-193%2028,-95%2021,-155%20-43,-390%20-33,-119%20-139,-504%20-236,-856%20-97,-352%20-239,-867%20-315,-1145%20-76,-278%20-193,-703%20-260,-945%20-67,-242%20-142,-514%20-166,-605%20-25,-91%20-57,-185%20-72,-210%20-44,-77%20-110,-138%20-190,-177%20-67,-34%20-84,-38%20-171,-41%20-134,-6%20-233,16%20-734,162%20-81,23%20-120,30%20-122,22%20-7,-20%20-247,-901%20-249,-910%200,-4%2087,-33%20194,-62%20107,-30%20499,-138%20870,-241%20371,-102%20678,-189%20682,-192%204,-3%20-81,-323%20-188,-711%20-107,-388%20-192,-710%20-190,-715%202,-6%2028,-17%2057,-24%2030,-8%20222,-61%20428,-117%20206,-57%20376,-103%20377,-101%201,1%2088,315%20193,697%20106,382%20194,696%20196,698%202,2%20137,-35%20302,-83%20164,-48%20318,-92%20343,-100%2035,-10%2044,-17%2042,-31%20-2,-11%20-87,-320%20-188,-689%20-101,-368%20-184,-674%20-184,-680%200,-9%20858,-250%20865,-243%202,2%2091,322%20198,711%20107,389%20196,710%20199,712%202,3%2042,-2%2089,-10%20416,-74%20899,-94%201184,-51%20672,104%201078,440%201283,1061%20196,592%2097,1085%20-302,1499%20l%20-73,76%20h%20118%20c%20828,0%201344,393%201564,1190%20130,470%20135,910%2015,1273%20-41,126%20-137,313%20-218,427%20-145,205%20-419,444%20-699,612%20-277,166%20-754,378%20-1083,483%20-30,10%20-58,20%20-62,24%20-4,3%2071,290%20166,636%2096,347%20185,671%20198,721%20l%2025,91%20-426,117%20c%20-234,64%20-431,116%20-436,116%20-6,0%20-98,-318%20-204,-707%20-107,-390%20-195,-709%20-196,-710%20-1,-2%20-143,35%20-316,81%20-173,46%20-329,87%20-346,91%20-18,3%20-33,12%20-33,18%200,11%2016,68%20259,952%2071,259%20128,471%20126,473%20-1,1%20-196,56%20-433,121%20l%20-431,118%20z%20m%20442,-2762%20c%20928,-243%201429,-470%201733,-785%2093,-98%20132,-151%20179,-252%2054,-113%2070,-186%2069,-317%200,-211%20-79,-419%20-214,-563%20-317,-339%20-883,-384%20-1824,-143%20-226,58%20-696,197%20-696,207%200,4%20117,433%20260,953%20143,520%20260,948%20260,951%200,10%2022,5%20233,-51%20z%20M%207391,7495%20c%20657,-172%201015,-321%201295,-540%2097,-76%20161,-145%20225,-243%2060,-91%2087,-161%20107,-277%2019,-113%207,-234%20-39,-369%20-102,-305%20-310,-473%20-660,-532%20-82,-13%20-140,-16%20-298,-11%20-227,6%20-400,32%20-681,103%20-171,42%20-609,170%20-618,179%20-4,4%20126,484%20431,1588%2024,87%2046,147%2053,147%206,0%2090,-20%20185,-45%20z'%20fill='%23ffffff'%20id='path54-2-8'%20style='stroke-width:0.541117'%20/%3e%3c/g%3e%3c/svg%3e\""],"names":["$parcel$export","e","n","v","s","$ef5ba40c8abe5a13$var$debug","$4QiMX$debug","$ef5ba40c8abe5a13$export$2e2bcd8739ae039","$c78f59d21170b7a6$var$ElectrumProtocol","method","parameters","requestId","$c78f59d21170b7a6$export$2e2bcd8739ae039","$a192ea5a4eec42d4$exports","$a192ea5a4eec42d4$export$e1f38ab2b4ebdde6","$a192ea5a4eec42d4$export$9598f0c76aa41d73","object","$5abc8fb342687c03$exports","$5abc8fb342687c03$export$d048df559e6d3842","$5abc8fb342687c03$export$f019be48b3aacb1a","$a58372b18a18806e$exports","$a58372b18a18806e$export$161fe3707f756bf9","$a58372b18a18806e$export$436a960acc41e848","$a58372b18a18806e$export$c66b56bc0ff967ca","$a58372b18a18806e$export$c4f81c6d30ca200f","$a58372b18a18806e$export$7516420eb880ab68","ClusterOrder","ClusterDistribution","ClusterStatus","ClientState","ConnectionStatus","$ea64e414b68fe23b$var$ElectrumSocket","$4QiMX$EventEmitter","host","port","scheme","timeout","socketTypes","connectionOptions","$4QiMX$WebSocket","connectionType","data","callback","timeoutError","args","event","err","$ea64e414b68fe23b$export$2e2bcd8739ae039","$1326c18f93f95fee$var$ElectrumConnection","application","version","pingInterval","reconnectInterval","timer","statementParts","currentStatementList","statementList","currentStatement","message","connectionResolver","resolve","reject","rejector","error","versionNegotiator","versionMessage","versionValidator","errorMessage","force","intentional","disconnectResolver","currentTime","verificationTimer","sentTimestamp","$1326c18f93f95fee$export$2e2bcd8739ae039","$7c0fb93e8eea922a$export$d73a2e87a509880","$7c0fb93e8eea922a$export$280de919a0cf6928","$620a18299ef8d6fd$var$ElectrumClient","$4QiMX$Mutex","unlock","retainSubscriptions","index","requestResolver","id","requestData","notification","subscriptionParameters","resubscriptionPromises","parameterJSON","resolverId","$620a18299ef8d6fd$export$2e2bcd8739ae039","$9b2ed2eb52532075$var$ElectrumCluster","confidence","distribution","order","autoConnect","client","clientIdentity","updateClusterStatus","onConnect","onDisconnect","availableClientIDs","clientID","sentCounter","requiredDistribution","currentIndex","currentClient","requestPromise","pollResponse","resolveRequest","responseData","checkedResponses","currentPromise","response","promises","responseDataIdentifier","unsubscriptionPromises","readyTimestamp","availabilityPoller","connectionAvailabilityVerifier","connections","clientKey","disconnections","clientIndex","$9b2ed2eb52532075$export$2e2bcd8739ae039","bch"],"mappings":"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","x_google_ignoreList":[0]}